<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://2734209032.github.io/hyh.github.io">
  <title>小辉辉</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="小辉辉">
<meta property="og:url" content="https://2734209032.github.io/hyh.github.io/index.html">
<meta property="og:site_name" content="小辉辉">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="hyh">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="小辉辉" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/hyh.github.io/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d">
</div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<!-- <img src="" class="js-avatar"> -->
			<img src="https://pic2.zhimg.com/v2-31950bdf84df84a86e471abf28f83da9_b.webp?consumer=ZHI_MENG" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/hyh.github.io/">主页</a></li>
	        
				<li><a href="/hyh.github.io/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<!-- <a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
					<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
					<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
		       -->
			   
				<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
			
				<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			
				<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			
				<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author"></h1>
			</hgroup>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/hyh.github.io/">主页</a></li>
		        
					<li style="width: 50%"><a href="/hyh.github.io/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-hyh-blog" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hyh.github.io/2023/06/29/hyh-blog/">1.一些小技巧</a>
    </h1>
  

        
        <a href="/hyh.github.io/2023/06/29/hyh-blog/" class="archive-article-date">
  	<time datetime="2023-06-29T07:18:39.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2023-06-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-js文档注释"><a href="#1-js文档注释" class="headerlink" title="1.js文档注释"></a>1.js文档注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Yuan &lt;123<span class="doctag">@gmail</span>&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">function</span>&#125; ks  //第一个参数是数据类型，第二个参数是目标函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; [msg] //第一个参数是数据类型，第二个参数是目标变量，加中括号代表可选</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Funtion</span>&#125;      </span></span><br><span class="line"><span class="comment"> * 函数防抖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">ks, msg = <span class="number">100</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-github上浏览源码"><a href="#2-github上浏览源码" class="headerlink" title="2.github上浏览源码"></a>2.github上浏览源码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//github1s.com/zxdfe/FE-Interview  </span></span><br><span class="line">我们平时不是看到github上的源码就密密麻麻的一片，不想看，在github地址上添加一个1s，如图所示，就能像vscode一样的查看源码了</span><br><span class="line">快捷键都是一样的，所以方便快捷，快用起来吧</span><br></pre></td></tr></table></figure>

<h4 id="3-通过emmet语法快速生成dom结构"><a href="#3-通过emmet语法快速生成dom结构" class="headerlink" title="3.通过emmet语法快速生成dom结构"></a>3.通过emmet语法快速生成dom结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">el-form&gt;(el-form-item[label]&gt;el-input&#123;&#125;)*<span class="number">4</span></span><br><span class="line"><span class="comment">//生成 &lt;el-form&gt;便签下4个el-form-item[label]&gt;el-input&#123;&#125;</span></span><br><span class="line">[]代表给el-form-item标签加一个label属性，</span><br><span class="line">&#123;&#125;可以给标签上写内容</span><br></pre></td></tr></table></figure>

<h4 id="4-电脑快捷键"><a href="#4-电脑快捷键" class="headerlink" title="4.电脑快捷键"></a>4.电脑快捷键</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开电脑搜索面板  两下alt </span></span><br><span class="line">移动代码 ，选中 alt+上下箭头</span><br></pre></td></tr></table></figure>

<h4 id="5-发布网站"><a href="#5-发布网站" class="headerlink" title="5.发布网站"></a>5.发布网站</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">安装 cnpm install -g vercel</span><br><span class="line"><span class="comment">//您可以使用以下命令来访问 Vercel CLI：</span></span><br><span class="line">npx vercel login</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>在官网 <span class="attr">https</span>:<span class="comment">//vercel.com/ 注册账号并登录；</span></span><br><span class="line"><span class="number">2.</span>创建 <span class="title class_">Vercel</span> 项目：在 <span class="title class_">Dashboard</span> 页面点击“<span class="title class_">New</span> <span class="title class_">Project</span>”按钮，然后选择要部署的 <span class="title class_">Git</span> 存储库，并按照提示进行授权和设置；</span><br><span class="line"><span class="number">3.</span>选择项目类型：如果您要部署静态网站，请选择“<span class="title class_">Static</span> <span class="title class_">Site</span>”并填写相应信息。其中，您需要指定要部署的源代码目录（例如 dist 或 build 目录），还可以选择构建命令和部署分支等相关设置；</span><br><span class="line"><span class="number">4.</span>配置环境变量：如果您的应用程序需要使用一些敏感数据或配置文件，可以通过 <span class="title class_">Vercel</span> 的环境变量功能来存储和管理它们。具体操作方法请参考相关文档。</span><br><span class="line"><span class="number">5.</span>点击“<span class="title class_">Deploy</span>”按钮部署应用程序。<span class="title class_">Vercel</span> 会自动构建和处理代码，并将静态资源上传到其全球 <span class="variable constant_">CDN</span> 上进行分发和缓存。此时，您可以在 <span class="title class_">Vercel</span> 控制台中查看和管理部署的应用程序，并访问其生成的唯一网址以测试和部署应用程序。</span><br><span class="line"></span><br><span class="line">注意，<span class="title class_">Vercel</span> 提供了丰富的功能和设置，可以帮助您管理和优化应用程序的性能、安全性、可靠性等方面。例如，您可以在 <span class="title class_">Vercel</span> 控制台中添加自定义域名、设置 <span class="variable constant_">HTTPS</span> 加密协议、启用缓存策略、监控应用程序性能等。具体操作方法请参考相关文档和教程。</span><br></pre></td></tr></table></figure>


      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/hyh.github.io/2023/06/29/hyh-blog/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-面试题" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hyh.github.io/2023/06/29/%E9%9D%A2%E8%AF%95%E9%A2%98/">2.一些常见前端面试题</a>
    </h1>
  

        
        <a href="/hyh.github.io/2023/06/29/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="archive-article-date">
  	<time datetime="2023-06-29T07:18:39.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2023-06-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-js"><a href="#一-js" class="headerlink" title="一.js"></a><strong>一.js</strong></h3><h4 id="1-什么是BFC"><a href="#1-什么是BFC" class="headerlink" title="1.什么是BFC"></a>1.什么是BFC</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">BFC</span>叫块级格式化上下文</span><br><span class="line"><span class="variable constant_">BFC</span>是一个完全独立的空间（布局环境），块级格式化上下文，它是指一个独立的块级渲染区域,让空间里的子元素不会影响到外面的布局。那么怎么使用<span class="variable constant_">BFC</span>呢，<span class="variable constant_">BFC</span>可以看做是一个<span class="variable constant_">CSS</span>元素属性</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">BFC</span>的方式都能清除浮动，但是常使用的清除浮动的<span class="variable constant_">BFC</span>方式只有<span class="string">`overflow:hidden`</span>,原因是使用float或者position方式清除浮动，虽然父级盒子内部浮动被清除了，但是父级本身又脱离文档流了，会对父级后面的兄弟盒子的布局造成影响。如果设置父级为<span class="string">`display:flex`</span>，内部的浮动就会失效。所以通常只是用<span class="string">`overflow: hidden`</span>清除浮动</span><br></pre></td></tr></table></figure>

<p><strong>触发条件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这里简单列举几个触发<span class="variable constant_">BFC</span>使用的<span class="variable constant_">CSS</span>属性</span><br><span class="line"><span class="number">1.</span> <span class="attr">overflow</span>: hidden    <span class="comment">//清除浮动，本质就是触发了BFC</span></span><br><span class="line"><span class="number">2.</span> <span class="attr">display</span>: inline-block</span><br><span class="line"><span class="number">3.</span> <span class="attr">position</span>: absolute</span><br><span class="line"><span class="number">4.</span> <span class="attr">position</span>: fixed</span><br><span class="line"><span class="number">5.</span> <span class="attr">display</span>: table-cell</span><br><span class="line"><span class="number">6.</span> <span class="attr">display</span>: flex</span><br><span class="line"><span class="number">7.</span>float的值不是none</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 应用场景：</span></span><br><span class="line"><span class="comment">// 1. 防止外边距塌陷</span></span><br><span class="line"><span class="comment">// 2. 清浮动，（包含浮动元素），计算BFC高度的时候，浮动的子元素也会参与计算。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-统计字符串中的字符出现次数"><a href="#2-统计字符串中的字符出现次数" class="headerlink" title="2.统计字符串中的字符出现次数"></a>2.统计字符串中的字符出现次数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.let str = &#x27;ashdkahsfukaysduiqewke&#x27;</span></span><br><span class="line">   <span class="comment">// 现在有一段字符串，要求统计字符串种出现的字符和次数</span></span><br><span class="line">   <span class="keyword">let</span> str = <span class="string">&#x27;ashdkahsfukaysduiqewke&#x27;</span></span><br><span class="line">   <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     key = str[i]</span><br><span class="line">     <span class="keyword">if</span> (obj[key]) &#123;</span><br><span class="line">       obj[key]++</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">       obj[key] = <span class="number">1</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br></pre></td></tr></table></figure>

<h4 id="3-扁平数组"><a href="#3-扁平数组" class="headerlink" title="3.扁平数组"></a>3.扁平数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// let arr = [1, 2, 3, [4, 5, [6, 7, [8, 9]]]]，将数组arr转变成[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>]]]]</span><br><span class="line">    <span class="keyword">let</span> newarr = []</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr, newarr</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[k] <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">          <span class="title function_">fn</span>(arr[k], newarr)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          newarr.<span class="title function_">push</span>(arr[k])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn</span>(arr, newarr)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newarr)</span><br><span class="line">arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>) <span class="comment">//直接可以把多维数组变成一个数组</span></span><br></pre></td></tr></table></figure>

<h4 id="4-typeof-和instanceof的区别"><a href="#4-typeof-和instanceof的区别" class="headerlink" title="4.typeof 和instanceof的区别"></a>4.typeof 和instanceof的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">相同点：都是用来检测数据类型的</span><br><span class="line">不同点：</span><br><span class="line"><span class="number">1.</span><span class="attr">typeof</span>:只能检测简单数据类型除了<span class="literal">null</span>以外，不能检测复杂数据类型，除了<span class="keyword">function</span>以外，且返回的是数据类型的字符串</span><br><span class="line"><span class="number">2.</span><span class="keyword">instanceof</span>：检测复杂数据类型 ，不能检测简单数据类型，返回的是布尔值，原理 ：而<span class="keyword">instanceof</span>还可以用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上，返回布尔值</span><br><span class="line">之所以 arr <span class="keyword">instanceof</span> <span class="title class_">Object</span> 为<span class="literal">true</span>  就是因为<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>出现在arr的原型上</span><br><span class="line"><span class="keyword">typeof</span> 原理：js 在底层存储变量的时候，会在变量的机器码的低位<span class="number">1</span>-<span class="number">3</span>位存储其类型信息  </span><br><span class="line"><span class="number">000</span>：对象</span><br><span class="line"><span class="number">010</span>：浮点数</span><br><span class="line"><span class="number">100</span>：字符串</span><br><span class="line"><span class="number">110</span>：布尔</span><br><span class="line"><span class="number">1</span>：整数</span><br><span class="line">对于 <span class="literal">undefined</span> 和 <span class="literal">null</span> 来说，这两个值的信息存储是有点特殊的。</span><br><span class="line"><span class="literal">null</span>：所有机器码均为<span class="number">0</span></span><br><span class="line"><span class="literal">undefined</span>：用 −<span class="number">2</span>^<span class="number">30</span> 整数来表示</span><br><span class="line">所以，<span class="keyword">typeof</span> 在判断 <span class="literal">null</span> 的时候就出现问题了，由于 <span class="literal">null</span> 的所有机器码均为<span class="number">0</span>，因此直接被当做了对象来看待。</span><br><span class="line"><span class="literal">null</span> 其实属于自己的类型 <span class="title class_">Null</span>，而不属于<span class="title class_">Object</span>类型，<span class="keyword">typeof</span> 之所以会判定为 <span class="title class_">Object</span> 类型，是因为<span class="title class_">JavaScript</span> 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 <span class="number">0</span> 会被 <span class="keyword">typeof</span> 判断为对象类型，而 <span class="literal">null</span> 的二进制位恰好都是 <span class="number">0</span> ，因此，<span class="literal">null</span> 被误判断为 <span class="title class_">Object</span> 类型</span><br></pre></td></tr></table></figure>

<h4 id="5-检测数据类型的几种方式"><a href="#5-检测数据类型的几种方式" class="headerlink" title="5.检测数据类型的几种方式"></a>5.检测数据类型的几种方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型：<span class="title class_">Number</span> <span class="title class_">String</span> <span class="title class_">Boolean</span> / <span class="literal">undefined</span> <span class="literal">null</span> / <span class="title class_">Symbol</span> <span class="title class_">BigInt</span> </span><br><span class="line"><span class="title class_">Symbol</span>是<span class="title class_">ES6</span>新出的一种数据类型，这种数据类型的特点就是没有重复的数据，可以作为object的key。</span><br><span class="line">    <span class="comment">// 引用类型：Object ==&gt;  Function Array Date Math RegExp</span></span><br><span class="line"><span class="number">1.</span> <span class="keyword">typeof</span>    缺陷：只能检测简单数据类型，检测复杂类型不准确 ege <span class="keyword">typeof</span> arr  <span class="comment">//Object</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">instanceof</span> 缺陷：检测复杂数据类型，还可以用于检测构造函数的prototype 属性是否出现在某个实例对象的原型链上</span><br><span class="line"><span class="number">3.</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>()  最完美的检测数据类型的方式</span><br><span class="line"><span class="number">4.</span>正则</span><br><span class="line"><span class="number">5.</span>constructor</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-事件对象需要记住两个方法"><a href="#6-事件对象需要记住两个方法" class="headerlink" title="6.  事件对象需要记住两个方法"></a>6.  事件对象需要记住两个方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> e.<span class="title function_">stopPropagation</span>()  阻止事件冒泡 </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> e.<span class="title function_">preventDefault</span>()   阻止默认行为 </span><br></pre></td></tr></table></figure>

<h4 id="7-this"><a href="#7-this" class="headerlink" title="7. this"></a>7. this</h4><p><code> this 就是一个变量，值是一个对象， 程序运行时内部自动生成的，代表着当前的运行环境</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">普通函数调用 ：<span class="variable language_">this</span>指向调用者，</span><br><span class="line">定时器中的回调函数指向的是<span class="variable language_">window</span></span><br><span class="line">事件绑定中的回调函数指向 事件源</span><br><span class="line">对象中的方法调用指向对象本身</span><br><span class="line">构造函数里面的<span class="variable language_">this</span>指向实例</span><br><span class="line">prototype上的方法指向实例</span><br></pre></td></tr></table></figure>



<h4 id="8-事件流"><a href="#8-事件流" class="headerlink" title="8.事件流"></a>8.事件流</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件流： 事件执行过程中的流动路径。    // 事件流描述的是元素在页面中接收事件的顺序。</span></span><br><span class="line">事件流有三个阶段 <span class="number">1.</span>捕获阶段 <span class="number">2.</span>当前目标阶段 <span class="number">3.</span>冒泡阶段    </span><br><span class="line"><span class="comment">// div.addEventListener(type, listener, useCapture);   </span></span><br><span class="line"><span class="comment">// 1. type 事件类型  </span></span><br><span class="line"><span class="comment">// 2. listener 回调函数  </span></span><br><span class="line"><span class="comment">// 3. useCapture 是否使用捕获 如果使用，传true, 否则 false (如果这个参数不传，默认是false)不传参 默认就是冒泡   `` 阻止冒泡 e.stopPropagation()`  `` 阻止默认行为  e.preventDefault()`</span></span><br></pre></td></tr></table></figure>

<h4 id="9-事件委托"><a href="#9-事件委托" class="headerlink" title="9.事件委托"></a>9.事件委托</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">事件委托的原理:利用事件冒泡，我们给父元素绑定事件，当点击了子元素冒泡到父元素上，父元素有事件，触发事件</span><br><span class="line">==&gt; 触发事件的元素e .<span class="property">target</span>==&gt; 绑定事件的元素</span><br><span class="line"><span class="variable language_">this</span></span><br><span class="line">e.<span class="property">currentTarget</span> ==&gt; 绑定事件的元素</span><br><span class="line">/e.<span class="property">target</span>.<span class="property">tagName</span> === 标签名 (大写) 用它来判断点击的是否是某些标签</span><br><span class="line">也可以用e.<span class="property">target</span>.<span class="property">className</span>===<span class="string">&#x27;类名&#x27;</span> 来判断是否点击的某些标签</span><br><span class="line">  事件委托的好处： 减少注册事件的次数 提高程序的性能</span><br><span class="line">   缺点：</span><br><span class="line">   <span class="number">1.</span>事件委托给予冒泡,对于不冒泡的事件不支持.</span><br><span class="line">   <span class="number">2.</span>层级过多,冒泡过程中,可能会被某层阻止掉</span><br><span class="line">   <span class="number">3.</span>理论上委托会导致浏览器频繁调用处理函数,虽然很可能不需要处理,所以建议就近委托,比如在table上代理id, 而不是在doncument上代理td</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="10-页面加载事件的区别"><a href="#10-页面加载事件的区别" class="headerlink" title="10.页面加载事件的区别"></a>10.页面加载事件的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="params"><span class="string">&#x27;load&#x27;</span></span>)&#123;</span><br><span class="line">&#125;            <span class="comment">//当页面的所有资源包括外联的资源全部加载完毕，再执行里面的代码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, fn)</span><br><span class="line">             <span class="comment">//仅当DOM元素加载完成，执行里面的代码</span></span><br></pre></td></tr></table></figure>

<h4 id="11-页面滑动效果"><a href="#11-页面滑动效果" class="headerlink" title="11.页面滑动效果"></a>11.页面滑动效果</h4><p>就是做返回顶部，让画面带点动画效果</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 让页面是滑动的效果 */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  scroll-behavior: smooth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*滤镜*/</span></span><br><span class="line"> <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="comment">/* filter: blur(10px);      变模糊 */</span></span><br><span class="line">    <span class="comment">/* filter: saturate(1)      饱和度*/</span></span><br><span class="line">    <span class="comment">/* filter: grayscale(1);       全页面变灰色 */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="12-立即执行函数的优点"><a href="#12-立即执行函数的优点" class="headerlink" title="12.立即执行函数的优点"></a>12.立即执行函数的优点</h4><p><code>立即执行函数的作用  ： 创建一个独立的作用域，防止变量名冲突，避免变量污染立即执行函数中的this指向window没有事件对象</code></p>
<h4 id="13-构造函数实例化对象-原型的考点"><a href="#13-构造函数实例化对象-原型的考点" class="headerlink" title="13.构造函数实例化对象 原型的考点"></a>13.构造函数实例化对象 原型的考点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化： 通过构造函数创建对象的过程就叫做实例化</span></span><br><span class="line"> <span class="comment">// 实例： 实际的例子，具体的某一个对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  构造函数名字首字母一般要大写（为了从视觉上区分构造函数和普通函数）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>  构造函数里 属性和方法前面必须添加 <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="number">3.</span>  构造函数不需要 <span class="keyword">return</span> 就可以返回结果（构造函数的返回值即为新创建的对象）</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>  我们调用构造函数 必须使用 <span class="keyword">new</span></span><br></pre></td></tr></table></figure>

<p><strong>new的执行过程</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 执行过程 当我们执行<span class="keyword">new</span>的时候，会去执行构造函数里面的代码</span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span>的执行过程？</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>首先会创建一个空对象 obj</span><br><span class="line"><span class="number">2.</span>给这个obj对象加__proto__属性，链接构造函数的prototype</span><br><span class="line"><span class="number">3.</span>构造函数调用<span class="title function_">call</span>()方法 参数是创建的对象，让当前构造函数的执行上下文中的<span class="variable language_">this</span>环境指向这个对象</span><br><span class="line"><span class="number">4.</span>执行构造函数里面的代码</span><br><span class="line"><span class="number">6.</span>判断构造函数中有没有<span class="keyword">return</span> 有<span class="keyword">return</span>的话，返回<span class="keyword">return</span>后面的</span><br><span class="line"><span class="number">5.</span>没有<span class="keyword">return</span> 返回这个新创建的对象</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2.原型的五大规则</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法糖</span></span><br><span class="line"><span class="comment">// const obj = &#123;&#125;   ===&gt;  const obj = new Object()</span></span><br><span class="line"><span class="comment">// const arr = []      ===&gt;  const arr = new Array()</span></span><br><span class="line"></span><br><span class="line"> <span class="number">1.</span> 所有的引用类型（数组对象函数），都具有对象的特性，可以自由的扩展属性。</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;        <span class="comment">// obj.a = 1 </span></span><br><span class="line"><span class="keyword">const</span> arr = []        <span class="comment">// arr.b = 2</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;   <span class="comment">// fn.c = 3</span></span><br><span class="line"></span><br><span class="line"> <span class="number">2.</span> 所有的对象，都有一个__proto__属性，属性值是一个普通的对象。 （__proto__ 隐式原型）</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">__proto__</span>)</span><br><span class="line"></span><br><span class="line"> <span class="number">3.</span> 所有的函数，都有一个prototype属性，属性值也是一个普通的对象  (prototype 显示原型)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property"><span class="keyword">prototype</span></span>)   </span><br><span class="line"></span><br><span class="line"> <span class="number">4.</span> 所有对象的隐式原型（__proto__） 指向它的构造函数的显示原型（prototype）</span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">fn.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"></span><br><span class="line"> <span class="number">5.</span> 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__中寻找</span><br></pre></td></tr></table></figure>

<p><strong>构造函数 实例 原型对象 关系</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 当<span class="keyword">new</span>时，构造函数实例化了对象</span><br><span class="line"><span class="number">2.</span> 构造函数中的prototype属性指向原型对象</span><br><span class="line"><span class="number">3.</span> 原型对象里面有constructor属性指回构造函数</span><br><span class="line"><span class="number">4.</span> 实例中的隐式原型(__proto_)指向构造函数的原型对象</span><br></pre></td></tr></table></figure>

<p><strong>实例成员和静态成员</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>实例成员：在实例上(对象)的属性和方法叫实例成员，只能实例自己访问，构造函数访问不了</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>静态成员：在构造函数本身的属性和方法叫静态成员，只能构造函数本身访问  静态成员中的<span class="variable language_">this</span>指向构造函数本身</span><br></pre></td></tr></table></figure>

<p><strong>1.原型</strong></p>
<p><strong>什么是原型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 每个函数都有prototype属性，它的值是一个指针，指向的就是原型对象</span><br><span class="line"><span class="number">2.</span> 通过构造函数生成的实例，都有一个__proto__属性，也指向原型对象</span><br><span class="line"><span class="number">3.</span> 原型对象上默认有一个constructor属性，指回构造函数</span><br><span class="line"></span><br><span class="line">**原型的作用**</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 我们可以把一些公共的属性和方法放到原型上</span><br><span class="line"><span class="number">2.</span> 通过构造函数创建的实例，都共享原型上的属性和方法</span><br></pre></td></tr></table></figure>

<p><strong>2.原型链</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每个对象通过__proto__都能访问到它的原型，原型也有它的原型</span><br><span class="line"></span><br><span class="line">当访问一个对象的属性和方法时，先在自身上寻找</span><br><span class="line"></span><br><span class="line"> 如果没有的话，就会沿着__proto__ 这条链，向上查找，一直找到最顶层<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>为止</span><br></pre></td></tr></table></figure>

<h4 id="14-本地储存考点"><a href="#14-本地储存考点" class="headerlink" title="14.本地储存考点"></a>14.本地储存考点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">面试题 如果问 <span class="variable language_">localStorage</span> 和 <span class="variable language_">sessionStorage</span> 、cookie 的区别？</span><br><span class="line">得分点 数据存储位置、生命周期、存储大小、写入方式、数据共享、发送请求时是否携带、应用场景 标准回答</span><br><span class="line"><span class="title class_">Cookie</span>、<span class="title class_">SessionStorage</span>、 <span class="title class_">LocalStorage</span>都是浏览器的本地存储。 它们的共同点：都是存储在浏览器本地的 它们的区别：cookie是由服务器端写入的，而<span class="title class_">SessionStorage</span>、 <span class="title class_">LocalStorage</span>都是由前端写入的，cookie的生命周期是由服务器端在写入的时候就设置好的，<span class="title class_">LocalStorage</span>是写入就一直存在，除非手动清除或卸载浏览器，<span class="title class_">SessionStorage</span>是页面关闭的时候就会自动清除。cookie的存储空间比较小大概4KB，<span class="title class_">SessionStorage</span>、 <span class="title class_">LocalStorage</span>存储空间比较大，大概5M。<span class="title class_">Cookie</span>、<span class="title class_">SessionStorage</span>、 <span class="title class_">LocalStorage</span>数据共享都遵循同源原则，<span class="title class_">SessionStorage</span>还限制必须是同一个页面。在前端给后端发送请求的时候会自动携带<span class="title class_">Cookie</span>中的数据，但是<span class="title class_">SessionStorage</span>、 <span class="title class_">LocalStorage</span>不会 加分回答 由于它们的以上区别，所以它们的应用场景也不同，<span class="title class_">Cookie</span>一般用于存储登录验证信息<span class="title class_">SessionID</span>或者token，<span class="title class_">LocalStorage</span>常用于存储不易变动的数据，减轻服务器的压力，<span class="title class_">SessionStorage</span>可以用来检测用户是否是刷新进入页面，如音乐播放器恢复播放进度条的功能(因为它只关闭页面就丢失数据，如果是刷新的话，数据还会存在，判断的就是它的数据是否存在)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如何实现可过期的localstorage数据？ </span><br><span class="line">目前有两种方法，一种是惰性删除，另一种是定时删除。 惰性删除是指某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。实现方法是，存储的数据类型是个对象，该对象有两个key，一个是要存储的value值，另一个是当前时间。获取数据的时候，拿到存储的时间和当前时间做对比，如果超过过期时间就清除<span class="title class_">Cookie</span>。 定时删除是指，每隔一段时间执行一次删除操作</span><br></pre></td></tr></table></figure>

<h4 id="15-js-执行机制"><a href="#15-js-执行机制" class="headerlink" title="15.js 执行机制"></a>15.js 执行机制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首先判断JS任务是同步的还是异步的，同步任务会在主线程的执行栈中依次执行</span></span><br><span class="line">        <span class="comment">// 2. 异步任务会提交给异步进程处理，（比如setTimeout,click事件等，）当满足触发条件的时候，</span></span><br><span class="line">        <span class="comment">//    异步进程会把异步任务（回调函数）放到任务队列中</span></span><br><span class="line">        <span class="comment">// 3. 当主线程执行完所有的同步任务后，会去任务队列中查找，看是否有可以执行的异步任务，如果有，</span></span><br><span class="line">        <span class="comment">//    放到主线程中执行，执行完之后再去任务队列中查看，依次循环。</span></span><br></pre></td></tr></table></figure>

<h4 id="16-作用域"><a href="#16-作用域" class="headerlink" title="16.作用域"></a>16.作用域</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>js作用域分为全局作用域<span class="number">2.</span>局部作用域（函数作用域和块作用域）</span><br><span class="line"><span class="comment">// 函数作用域，在函数内部声明的变量，只能在函数内部被访问</span></span><br><span class="line"><span class="comment">//函数内部未声明直接赋值的变量，是全局变量，会挂载到window上</span></span><br><span class="line"><span class="comment">// 函数的参数，相当于函数内部的局部变量 </span></span><br><span class="line"><span class="comment">// 块作用域：在 JavaScript 中使用 `&#123;&#125;` 包裹的代码称为代码块，</span></span><br><span class="line"><span class="comment">//  使用let/const声明的变量，在&#123;&#125;中就会产生块级作用域。</span></span><br></pre></td></tr></table></figure>

<h4 id="17-var-let-const-区别"><a href="#17-var-let-const-区别" class="headerlink" title="17.var let const 区别"></a>17.var let const 区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">let</span> <span class="keyword">const</span> 可以形成块作用域，<span class="keyword">var</span>不可以</span><br><span class="line">块级作用域解决了<span class="title class_">ES5</span>中的两个问题：</span><br><span class="line">内层变量可能覆盖外层变量</span><br><span class="line">用来计数的循环变量泄露为全局变量</span><br><span class="line"><span class="number">2.</span> <span class="keyword">let</span>  <span class="keyword">const</span> 是不存在变量提升的，<span class="keyword">var</span>可以</span><br><span class="line"><span class="number">3.</span> <span class="keyword">let</span> <span class="keyword">const</span> 不能重复声明 ，<span class="keyword">var</span>可以</span><br><span class="line"><span class="number">4.</span> <span class="keyword">let</span> <span class="keyword">const</span> 不能再声明之前使用（暂时性死区），<span class="keyword">var</span>可以,<span class="keyword">let</span> <span class="keyword">const</span> 的暂时性死区，在声明前的作用域无法访问到<span class="keyword">let</span> <span class="keyword">const</span>声明的相同变量</span><br><span class="line"><span class="number">5.</span> <span class="keyword">const</span> 声明变量的同时必须赋初始值，且不能重新赋值</span><br><span class="line"><span class="number">6.</span> 浏览器中，<span class="keyword">var</span>声明的全局变量会挂载到<span class="variable language_">window</span>对象下，<span class="keyword">let</span> / <span class="keyword">const</span> 不会</span><br></pre></td></tr></table></figure>

<h4 id="18-作用域链"><a href="#18-作用域链" class="headerlink" title="18.作用域链"></a>18.作用域链</h4><p><strong>定义</strong></p>
<p>变量查找机制，先从当前作用域查找，如果没有就往上一级查找，一直查找到全局作用域（就近原则）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用域链本质上是底层的变量查找机制，</span></span><br><span class="line">   <span class="comment">//   在函数被执行时，会优先查找当前函数作用域中查找变量，</span></span><br><span class="line">   <span class="comment">//   如果当前作用域查找不到则会依次逐级查找上一级作用域直到全局作用域</span></span><br><span class="line">   <span class="comment">//   let a = 1</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">// let a = 2</span></span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">//   a = 3</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="title function_">g</span>()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">f</span>()</span><br></pre></td></tr></table></figure>

<h4 id="19-垃圾回收机制"><a href="#19-垃圾回收机制" class="headerlink" title="19.垃圾回收机制"></a>19.垃圾回收机制</h4><p><strong>垃圾回收机制</strong></p>
<p> 垃圾回收机制（garbage collection）简称GC， JS中内存的分配和回收是自动完成的，内存在不使用的时候会被JS引擎&#x2F;垃圾回收程序自动回收。<code>一般来说回收机制，当在函数声明一个变量  函数内部声明的这个num变量，当函数执行完后，不再使用了，会`被垃圾回收程序回收掉</code><br>   <code> 全局变量是当 页面关闭 时被销毁</code></p>
<p><strong>内存泄漏</strong></p>
<p>内存泄漏: 不再使用的内存，没有及时的释放。</p>
<ol>
<li><p>全局变量在页面关闭的时候会被回收</p>
</li>
<li><p>函数里面的变量当函数调用完就回收</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>闭包  <span class="number">2.</span>垃圾回收机制的引用计数法 <span class="number">3.</span>意外的全局变量 <span class="number">4.</span><span class="variable language_">console</span>.<span class="title function_">log</span>()打印一个局部变量，或者是引用数据类型也会导致内存泄漏，所以我们项目一般上线前会把<span class="variable language_">console</span>.<span class="title function_">log</span>()代码注释掉</span><br><span class="line"><span class="number">5.</span>、<span class="variable constant_">DOM</span> 元素的引用、 <span class="number">6.</span>定时器</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>垃圾回收机制的两种方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 引用计数法 ：跟踪每个值的引用次数，每引用一次次数累加，少引用一次，次数减少一次，当引用次数为<span class="number">0</span>的时候，释放内存</span><br><span class="line">缺陷： 堆内存空间中的对象 互相引用，计数永远不能为<span class="number">0</span>，无法被回收，内存泄漏</span><br><span class="line"><span class="number">2.</span>标记清除法：从全局作用查找，查找得到的话，就标记为活动对象，查找不到的话标记为非活动对象，查找完之后，非活动对象回收</span><br><span class="line">缺陷：内存碎片化，解决方法：标记清除整理算法</span><br><span class="line"><span class="number">3.</span>谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。</span><br></pre></td></tr></table></figure>

<p><strong>栈空间的垃圾回收机制</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当执行一段js代码，首先创建全局执行上下文，压入栈底，当执行函数的时候，会创建函数执行上下文，压入栈中，还有一个记录</span><br><span class="line">当前执行状态的指针（称为 <span class="variable constant_">ESP</span>），当执行函数的时候<span class="variable constant_">ESP</span>指向这个函数 ，当执行完之后，<span class="variable constant_">ESP</span>指向下一个函数，当前函数的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</span><br><span class="line">函数尾调用的原理就是这样来的，尾调用节约内存，当前函数调用完，再调用另一个函数，就销毁上一个函数执行上下文，尾递归，也是这个原理，不会造成栈溺出，他表示的是一个函数在执行最后一步时自己调用自己，从始至终自会有一个函数执行上下文，所以比较节约内存</span><br></pre></td></tr></table></figure>

<p><strong>堆空间的垃圾回收机制</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">根据代际假说(<span class="number">1.</span>大部分对象在刚分配内存，很快就变得不能访问了 <span class="number">2.</span>不死的对象，会活得很久)，v8中把堆分为新生代和老生代，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。新生代使用副垃圾回收器，老生代使用主垃圾回收器</span><br><span class="line"><span class="number">1.</span>新生区的垃圾回收：</span><br><span class="line">新生代采用<span class="title class_">Scavenge</span>算法，把新生代空间分为对象区域和空闲区域，新加入的对象会放到对象区域，当对象区域要满的时候，执行垃圾回收，标记活动对象，和非活动对象，所有的活动对象整理好后复制到空闲区，回收非活动对象，清理完后，空闲区和对象区进行角色互换</span><br><span class="line">缺陷：新生区空间较少，很容易对象区域的内存就满了，执行垃圾回收的次数会很频繁</span><br><span class="line">js引擎解决方案：对象晋升策略，凡是经过<span class="number">2</span>次垃圾回收机制存活下来的，就会晋升到老生区</span><br><span class="line"><span class="number">2.</span>老生区的垃圾回收</span><br><span class="line">老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。，老生区是主垃圾回收机制负责，采用的是标记清除法，</span><br><span class="line">标记阶段：从根元素递归遍历这组根元素，查找得到标记为活动对象，查找不到标记为非活动对象，清除阶段：清除所有标记为非活动对象，</span><br><span class="line">缺陷：内存碎片化 解决方案：标记整理算法 原理：这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</span><br><span class="line">全停顿： js是运行在主线程之上的，一旦执行垃圾回收算法，都需要把正在执行的js脚本暂停下来，等到垃圾回收完了再恢复，</span><br><span class="line">解决方法：增量标记算法</span><br><span class="line">为了降低老生代的垃圾回收而造成的卡顿，<span class="variable constant_">V8</span> 将标记过程分为一个个的子标记过程，同时</span><br><span class="line">让垃圾回收标记和 <span class="title class_">JavaScript</span> 应用逻辑交替进行，直到标记阶段完成</span><br></pre></td></tr></table></figure>

<p><strong>判断对象是否存活</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">现代虚拟机基本都是采用 可达性分析算法 来判断对象是否存活，可达性算法的原理是以一系列叫做  <span class="variable constant_">GC</span> <span class="title class_">Root</span>  的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。这样通过 <span class="variable constant_">GC</span> <span class="title class_">Root</span> 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 <span class="variable constant_">GC</span> <span class="title class_">Root</span> 为起点的引用链中，则这些对象会被判断为垃圾对象,会被 <span class="variable constant_">GC</span> 回收。</span><br><span class="line">哪些对象可以作为 <span class="variable constant_">GC</span> <span class="title class_">Root</span> 呢？</span><br><span class="line"><span class="number">1.</span>虚拟机栈（栈帧中的本地变量表）中引用的对象</span><br><span class="line"><span class="number">2.</span>本地方法栈中 <span class="variable constant_">JNI</span>（即一般说的 <span class="title class_">Native</span> 方法）引用的对象</span><br><span class="line"><span class="number">3.</span>方法区中类静态属性引用的对象</span><br><span class="line"><span class="number">4.</span>方法区中常量引用的对象</span><br></pre></td></tr></table></figure>



<h4 id="20-闭包"><a href="#20-闭包" class="headerlink" title="20.闭包"></a>20.闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 闭包：内层函数引用外层函数中的变量的集合，内层函数用到外层函数的变量，此时这个变量所在的这个函数就叫做闭包函数</span><br><span class="line">  闭包=内层函数+外层函数的变量</span><br><span class="line">闭包形成的原理：作用域链，当前作用域可以访问上级作用域中的变量</span><br><span class="line">内存泄漏:关系到上面的栈空间的执行过程</span><br></pre></td></tr></table></figure>

<p><code>闭包的问题：内存泄漏 由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出。</code></p>
<p><strong>闭包的作用：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 延伸变量的范围</span><br><span class="line"><span class="number">2.</span> 实现变量的私有化</span><br><span class="line"><span class="number">3.</span> 节流 ，防抖(实际开发作用)</span><br><span class="line"><span class="number">4.</span>柯里化函数的实现</span><br><span class="line"><span class="number">5.</span>能够模仿块级作用域</span><br></pre></td></tr></table></figure>

<h4 id="21-函数相关面试"><a href="#21-函数相关面试" class="headerlink" title="21.函数相关面试"></a>21.函数相关面试</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 函数用<span class="keyword">function</span>声明的函数才存在函数提升在当前作用域的顶部，用函数表达式声明的函数不会提升，因为其本质是声明变量的过程，只不过值是函数而已</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">function</span>声明的函数，会被提升到当前作用域的最前面  在<span class="keyword">var</span>的前面</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 表达式的函数，如果是<span class="keyword">var</span>声明的，只提升声明，不提升赋值（必须先声明和赋值，再调用）</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="keyword">let</span> <span class="keyword">const</span> 声明的函数必须先声明再调用</span><br></pre></td></tr></table></figure>

<p><strong>arguments</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个函数内部都有<span class="variable language_">arguments</span>参数，箭头函数没有，<span class="variable language_">arguments</span>是一个伪数组，不能用数组的方法</span><br></pre></td></tr></table></figure>

<p><strong>rest参数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rest参数语法 ...rest ，接收剩余参数，是一个真数组，可以用数组的方法，一般我们都用rest参数代替了<span class="variable language_">arguments</span>参数</span><br><span class="line">rest参数只能写在形参的最后面，否则会报错</span><br><span class="line">作用：</span><br><span class="line"><span class="number">1.</span> 求最大最小值</span><br><span class="line"><span class="number">2.</span> 合并、复制数组</span><br><span class="line"><span class="number">3.</span> 用途<span class="number">3</span> ：展开字符串</span><br><span class="line"><span class="number">4.</span> 伪数组转换为真数组</span><br></pre></td></tr></table></figure>

<h4 id="22-箭头函数考点"><a href="#22-箭头函数考点" class="headerlink" title="22.箭头函数考点"></a>22.箭头函数考点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.</span>当箭头函数需要返回一个对象时，如果要简写，需要把对象用小括号包裹起来</span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">fn5</span> = x =&gt; (&#123; <span class="attr">name</span>: xxx &#125;)</span><br><span class="line"> <span class="number">6.</span>箭头函数里面没有<span class="variable language_">arguments</span>，没有绑定<span class="variable language_">this</span>，<span class="variable language_">this</span>的指向是当前作用域<span class="variable language_">this</span>的指向，或上一级作用域<span class="variable language_">this</span>的指向</span><br><span class="line"> <span class="number">7.</span>箭头函数中的<span class="variable language_">this</span>指向</span><br><span class="line">  <span class="comment">// 普通函数的this：谁调用它，指向谁（跟函数定义的位置无关）</span></span><br><span class="line"> <span class="comment">// 箭头函数的this：没有自己的this，取决于函数定义的位置（与谁调用它无关），</span></span><br><span class="line"> <span class="comment">// 即包裹该箭头函数的第一个普通函数的this，没有包裹它的普通函数，则指向window</span></span><br></pre></td></tr></table></figure>

<p><strong>箭头函数注意点</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">没有<span class="variable language_">this</span>、<span class="variable language_">this</span>是从外部获取、不能使用<span class="keyword">new</span>、没有<span class="variable language_">arguments</span>、没有原型和<span class="variable language_">super</span>  箭头函数相当于匿名函数，简化了函数定义</span><br><span class="line"><span class="number">1.</span> 箭头函数没有prototype属性，也没有原型</span><br><span class="line"> <span class="number">2.</span> 不能使用<span class="keyword">new</span> 调用箭头函数，也就是说箭头函数不能作为构造函数</span><br><span class="line"> <span class="number">3.</span> 箭头函数没有<span class="variable language_">arguments</span>，利用rest接收剩余参数  <span class="comment">//在箭头函数里访问arguments访问的是外部环境的arguments</span></span><br><span class="line"> <span class="number">4.</span> 箭头函数本身没有<span class="variable language_">this</span> </span><br><span class="line">    <span class="comment">//  箭头函数的this指向在定义的时候就确定了，指向的是上层作用域中的this</span></span><br><span class="line">    <span class="comment">// ===&gt;  箭头函数内部的this指向是固定的。普通函数的this指向是可变的</span></span><br></pre></td></tr></table></figure>

<h4 id="23-浅拷贝"><a href="#23-浅拷贝" class="headerlink" title="23.浅拷贝"></a>23.浅拷贝</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 面试</span><br><span class="line">     <span class="variable constant_">Q1</span>：什么是浅拷贝？</span><br><span class="line">     在堆内存中新开辟空间，创建一个新的对象</span><br><span class="line">     拷贝第一层基本数据类型的值和引用类型的地址</span><br><span class="line">     <span class="variable constant_">Q2</span>：实现浅拷贝的方式有哪些？</span><br><span class="line">       <span class="number">1.</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>()</span><br><span class="line">        <span class="number">2.</span> 扩展运算符</span><br><span class="line">        <span class="number">3.</span> 数组的<span class="title function_">concat</span>()       <span class="comment">//详情见js进阶第四天</span></span><br><span class="line">        <span class="number">4.</span>数组的<span class="title function_">slice</span>()</span><br><span class="line">        <span class="number">5.</span><span class="title class_">Array</span>的静态方法  <span class="title class_">Array</span>.<span class="title function_">from</span>()  <span class="comment">//这个方法可以将arguments对象转换为数组</span></span><br><span class="line">其实浅拷贝也可以这样实现</span><br><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;hah&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:&#123;</span><br><span class="line">        <span class="attr">yi</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">现在我们要把obj浅拷贝给一个空对象， <span class="keyword">const</span> obj1=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    obj1[k]=obj[k]          <span class="comment">//这样就能实现一个简单的浅拷贝，深拷贝的原理也是根据这个来的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-深拷贝"><a href="#24-深拷贝" class="headerlink" title="24.深拷贝"></a>24.深拷贝</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  面试题：</span><br><span class="line">         <span class="variable constant_">Q1</span> : 什么是深拷贝 ？</span><br><span class="line"></span><br><span class="line">在堆内存中新开辟一个空间存放新的对象  递归的拷贝原对象的所有属性和方法，拷贝前后两个对象，相互不影响       </span><br></pre></td></tr></table></figure>

<p>  Q2 : 实现深拷贝的方式？</p>
<pre><code>        1. JSON.parse(JSON.stringify(obj))
        缺陷：1.当属性值是undefined 和函数时，则会丢失，当然不止这两种情况会丢失，正则等等
        2. .手写递归实现
        3. 使用一些JS库，比如lodash等
        4.jQuery.extend()
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 深拷贝 ： 在堆内存中新开辟一个空间存放新的对象</span></span><br><span class="line">    <span class="comment">//                递归的拷贝原对象的所有属性和方法，拷贝前后两个对象，相互不影响</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归的拷贝：一层一层，每一层都新建一个内存空间</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;JS&#x27;</span>,</span><br><span class="line">      <span class="attr">book</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="string">&quot;169&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">手写递归实现深拷贝,实现简单的深拷贝，很多情况都没考虑进去，只考虑了对象的属性值是对象和数组的情况</span><br><span class="line"><span class="keyword">const</span> obj2=&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">ollobj,newobj</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> ollobj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ollobj[k] <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;         <span class="comment">//为什么要先判断数组，因为，数组属于对象，如果想要不按照顺序来的话可以用                                                   Object.prototype.tostring.call() 方法 </span></span><br><span class="line">            newobj[k]=[]</span><br><span class="line">            <span class="title function_">clone</span>(ollobj[k],newobj[k])</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ollobj[k] <span class="keyword">instanceof</span> <span class="title class_">Object</span>)&#123;</span><br><span class="line">               newobj[k]=&#123;&#125;</span><br><span class="line">             <span class="title function_">clone</span>(ollobj[k],newobj[k])</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              newobj[k]=ollobj[k]</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="title function_">clone</span>(obj,obj1)</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h4 id="25-js实现继承的方式"><a href="#25-js实现继承的方式" class="headerlink" title="25. js实现继承的方式"></a>25. js实现继承的方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 原型链继承  </span><br><span class="line"><span class="number">2.</span> 借用构造函数（经典继承）</span><br><span class="line"><span class="number">3.</span> 组合继承</span><br><span class="line"><span class="number">4.</span> 原型式继承</span><br><span class="line"><span class="number">5.</span> 寄生式继承</span><br><span class="line"><span class="number">6.</span> 寄生式组合继承 ==&gt; 最完美的</span><br><span class="line"><span class="number">7.</span> <span class="keyword">extends</span>继承 (===&gt;语法糖，寄生式组合继承)</span><br></pre></td></tr></table></figure>

<p><strong>原型链继承</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原理：子构造函数的原型等于父构造函数的实例</span><br></pre></td></tr></table></figure>

<p><strong>寄生式继承</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;哈UN沟通与内购会&#x27;</span>,</span><br><span class="line">   <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(obj2)</span><br><span class="line"> obj2.<span class="property">__proto__</span> = obj      <span class="comment">//原理</span></span><br></pre></td></tr></table></figure>

<h4 id="26-call-aplly-bind-面试题"><a href="#26-call-aplly-bind-面试题" class="headerlink" title="26.call aplly bind 面试题"></a>26.call aplly bind 面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 总结 </span></span><br><span class="line"><span class="comment">// 面试题</span></span><br><span class="line">call / apply/ bind 的区别</span><br><span class="line">call/apply/bind的核心理念：借用方法。</span><br><span class="line">借助已实现的方法，改变方法中数据的<span class="variable language_">this</span>指向，减少重复代码，节省内存。</span><br><span class="line"><span class="number">1.</span>都是改变<span class="variable language_">this</span>的指向 </span><br><span class="line"><span class="number">2.</span>call接收的是参数列表，apply接收的是数组 ,他们两个都会立即调用函数</span><br><span class="line"><span class="number">3.</span>call和aplly是立即执行的，bind返回一个已经改变<span class="variable language_">this</span>的函数，需要手动调用​</span><br><span class="line"><span class="number">4.</span>调用call/apply/bind的必须是个函数，call、apply和bind是挂在<span class="title class_">Function</span>对象上的三个方法,只有函数才有这些方法。</span><br><span class="line">应用场景:</span><br><span class="line"><span class="number">1.</span>判断数据类型 <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>()</span><br><span class="line"><span class="number">2.</span>类数组借用数组的方法</span><br><span class="line"><span class="number">3.</span>apply获取数组最大值最小值  <span class="keyword">const</span> arr = [<span class="number">15</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>]; <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, arr); <span class="comment">// 16</span></span><br><span class="line"><span class="number">4.</span>继承 <span class="title class_">ES5</span>的继承也都是通过借用父类的构造方法来实现父类方法/属性的继承</span><br></pre></td></tr></table></figure>

<p><strong>call源码实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_call</span>=<span class="keyword">function</span>(<span class="params">obj,...args</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;fn&#x27;</span>)  <span class="comment">//Symbol 是创建一个独一无二的属性，防止与原对象属性冲突覆盖</span></span><br><span class="line">    obj[fn]=<span class="variable language_">this</span>;          <span class="comment">//这里的this就是要改变this指向的那个函数</span></span><br><span class="line">    <span class="keyword">let</span> result = obj[fn](...args)</span><br><span class="line">    <span class="keyword">delete</span> obj[fn];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;&#125;;</span><br><span class="line">fn.<span class="title function_">_call</span>(obj)</span><br></pre></td></tr></table></figure>

<p><strong>aplly源码实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;​</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_aplly</span>=<span class="keyword">function</span>(<span class="params">obj,args</span>)&#123;</span><br><span class="line">     <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;fn&#x27;</span>)  <span class="comment">//Symbol 是创建一个独一无二的属性，防止与原对象属性冲突覆盖</span></span><br><span class="line">     obj[fn]=<span class="variable language_">this</span>;          <span class="comment">//这里的this就是要改变this指向的那个函数</span></span><br><span class="line">     <span class="keyword">let</span> result = obj[fn](...args)</span><br><span class="line">     <span class="keyword">delete</span> obj[fn];</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;&#125;;</span><br><span class="line">fn.<span class="title function_">_aplly</span>(obj)</span><br></pre></td></tr></table></figure>

<p><strong>bind源码实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;•</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_bind</span>=<span class="keyword">function</span>(<span class="params">obj,...args</span>)&#123;  </span><br><span class="line">    <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line">    <span class="comment">//Symbol 是创建一个独一无二的属性，防止与原对象属性冲突覆盖   </span></span><br><span class="line">    obj[fn]=<span class="variable language_">this</span>;          <span class="comment">//这里的this就是要改变this指向的那个函数    </span></span><br><span class="line">    <span class="keyword">let</span> result = obj[fn](...args)  </span><br><span class="line">    <span class="keyword">delete</span> obj[fn];    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;&#125;;</span><br><span class="line">fn.<span class="title function_">_bind</span>(obj)</span><br></pre></td></tr></table></figure>



<h4 id="27-防抖"><a href="#27-防抖" class="headerlink" title="27.防抖"></a>27.防抖</h4><p>什么是防抖： 这题可以补充一些防抖或节流在页面中的应用场景，会加分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">防抖：debounce</span><br><span class="line">    <span class="comment">// 当持续触发事件时，一定时间内没有再触发事件，回调函数才会执行一次。</span></span><br><span class="line">    <span class="comment">// 如果设定的延迟时间到来之前，又触发了事件，就重新计时。</span></span><br></pre></td></tr></table></figure>

<p><strong>防抖的场景</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">防抖：防止抖动，你先抖动着，啥时候停了，再执行下一步。</span><br><span class="line">    <span class="comment">// 游戏 回城键 b回城。按下了回城键，等待5s回城。再5s之内，继续又按一下回城，又会重新计时。</span></span><br><span class="line">    <span class="comment">// 防抖的应用场景</span></span><br><span class="line">    <span class="comment">// 1. 搜索框输入查询的时候</span></span><br><span class="line">    <span class="comment">// 2. 鼠标连续点击按钮提交等</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>防抖函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendMsg</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn,ms=<span class="number">0</span></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">            fn.<span class="title function_">call</span>(<span class="variable language_">this</span>)      <span class="comment">//这里用call的原因是因为事件里面的回调函数本来是指向事件源的，但这里的fn的this是指向window的，但为什么call的第一个参数是this，是因为箭头函数没有自己的this，会往上一层作用域去找，return function中的this是指向事件源的，所以用this</span></span><br><span class="line">        &#125;,ms)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="title function_">debounce</span>(sendMsg, <span class="number">500</span>).<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h4 id="28-节流"><a href="#28-节流" class="headerlink" title="28.节流"></a>28.节流</h4><p><strong>什么是节流</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节流：throttle</span><br><span class="line">    <span class="comment">// 持续的触发事件，在一段时间内，只允许函数执行一次</span></span><br><span class="line">    <span class="comment">// ==&gt; 节流：减少一段时间内，事件的触发频率</span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">应用场景：</span><br><span class="line">    <span class="comment">// 1. 浏览器窗口缩放 ，resize事件</span></span><br><span class="line">    <span class="comment">// 2. scroll滚动事件 / mousemove 事件等。</span></span><br><span class="line">   <span class="comment">//滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……</span></span><br></pre></td></tr></table></figure>

<p><strong>节流定时器版</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">move</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 只要鼠标一移动，i就会变化</span></span><br><span class="line">      box.<span class="property">innerHTML</span> = i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// box.addEventListener(&#x27;mousemove&#x27;, move)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节流：throttle</span></span><br><span class="line">    <span class="comment">// 持续的触发事件，在一段时间内，只允许函数执行一次</span></span><br><span class="line">    <span class="comment">// ==&gt; 节流：减少一段时间内，事件的触发频率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用场景：</span></span><br><span class="line">    <span class="comment">// 1. 浏览器窗口缩放 ，resize事件</span></span><br><span class="line">    <span class="comment">// 2. scroll滚动事件 / mousemove 事件等。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求： 每隔100ms只执行一次。setTimeout</span></span><br><span class="line">    <span class="comment">// 整个程序 ，应该只有一个定时器在走</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, ms = <span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> timerId</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有定时器，就开启定时器</span></span><br><span class="line">        <span class="keyword">if</span> (!timerId) &#123;</span><br><span class="line">          <span class="comment">//开启第一个定时器后</span></span><br><span class="line">          timerId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">            <span class="comment">//这里，让下一次定时器又可以开启</span></span><br><span class="line">            timerId = <span class="literal">null</span></span><br><span class="line">          &#125;, ms)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="title function_">throttle</span>(move, <span class="number">1000</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>节流时间戳版</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line">   <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">move</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">     <span class="comment">// 只要鼠标一移动，i就会变化</span></span><br><span class="line">     box.<span class="property">innerHTML</span> = i++</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 需求 ：每隔100ms 只执行一次 。</span></span><br><span class="line">   <span class="comment">// 时间戳的写法</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, ms = <span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">     <span class="keyword">let</span> pre = <span class="number">0</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">       <span class="keyword">if</span> (now - pre &gt; ms) &#123;</span><br><span class="line">         move.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">         pre = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="title function_">throttle</span>(move, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<h4 id="29-lodash防抖节流"><a href="#29-lodash防抖节流" class="headerlink" title="29.lodash防抖节流"></a>29.lodash防抖节流</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lodash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">move</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">     box.<span class="property">innerHTML</span> = i++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 节流 _.throttle(fn, ms)</span></span><br><span class="line">   <span class="comment">// 防抖 _.debounce(fn, ms)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// box.addEventListener(&#x27;mousemove&#x27;, _.throttle(move, 10))</span></span><br><span class="line">   box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, _.<span class="title function_">debounce</span>(move, <span class="number">300</span>))</span><br><span class="line">   <span class="comment">// ----------------------------------------------------------------------------------</span></span><br><span class="line">   <span class="comment">// 防抖和节流的面试点</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. 能说出什么是防抖，什么是节流</span></span><br><span class="line">   <span class="comment">// 防抖： 你先抖动着，什么时候停了，我再执行。</span></span><br><span class="line">   <span class="comment">// ===&gt; 防抖是将多次密集触发，合并为一次。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 节流：减少一定时间内，事件触发的频率。 （减少水流）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 能说出它们的应用场景</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 应用场景：</span></span><br><span class="line">   <span class="comment">// 防抖：1. 搜索框输入查询</span></span><br><span class="line">   <span class="comment">//      2. 多次点击按钮提交</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 节流：</span></span><br><span class="line">   <span class="comment">//     1. 窗口的resize事件</span></span><br><span class="line">   <span class="comment">//     2. scroll事件，mousemove事件等。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. ==&gt; 高级一点，手写防抖节流</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 防抖</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn, ms = <span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">     <span class="keyword">let</span> timerId</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">       <span class="built_in">clearTimeout</span>(timerId)</span><br><span class="line">       timerId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">       &#125;, ms);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 节流</span></span><br><span class="line">       <span class="comment">// 事件戳版本 / 定时器版本</span></span><br></pre></td></tr></table></figure>

<h4 id="30-extends继承"><a href="#30-extends继承" class="headerlink" title="30.extends继承"></a>30.extends继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 寄生式组合继承 </span></span><br><span class="line">    <span class="comment">// ===&gt; extends ES6 类的继承  完美的 perfect~~~</span></span><br><span class="line">    <span class="comment">// 继承： 让子类拥有父类的属性和方法</span></span><br><span class="line">    <span class="comment">//定义一个父类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;奔跑&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写一个子Dog 继承Animal 这个父类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;西瓜&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dog);</span><br><span class="line">    dog.<span class="title function_">run</span>()</span><br><span class="line"><span class="comment">// 子类 创建的实例，可以调用父类的方法 （继承父类的属性和方法）</span></span><br><span class="line"><span class="comment">// 子类里面没有写属性和方法，但是 通过extends，直接继承了父类的name和age</span></span><br><span class="line"><span class="comment">// 子类 创建的实例，可以调用父类的方法 （继承父类的属性和方法）</span></span><br></pre></td></tr></table></figure>

<h4 id="31-super-继承"><a href="#31-super-继承" class="headerlink" title="31.super 继承"></a>31.super 继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">     <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义一个son继承Father</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">     <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">super</span>()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 1. 子类实现继承的时候必须在constructor方法里面，调用super(), 否则会报错。</span></span><br><span class="line">   <span class="comment">//  ===&gt; 如果子类里面写了constructor() ，就必须要写super()</span></span><br><span class="line">   <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 如果子类没有写constructor(), 这个方法会默认添加，并且里面还会默认调用super()</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 等同于</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">     <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">super</span>()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 正常情况下，我们都会在子类里写constructor，并且写super()</span></span><br></pre></td></tr></table></figure>

<p><strong>super注意点</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">      <span class="comment">// 这里的constructor叫做构造函数</span></span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 求和 </span></span><br><span class="line">      <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span> + <span class="variable language_">this</span>.<span class="property">y</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个子类，继承父类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">      <span class="comment">// 1. super() 必须在子类的this前面调用</span></span><br><span class="line">      <span class="comment">// 2. super() 代表了父类的构造函数</span></span><br><span class="line">      <span class="comment">// 3. super() 里面的this 指向的是谁呢？</span></span><br><span class="line">      <span class="comment">//  ===&gt; 指向的是子类的实例，Son的实例 p这个对象</span></span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">x, y, color</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(x, y) <span class="comment">// ==&gt; super(x, y)  父类的constructor(x, y)</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 怎么理解super()要在this前面调用？</span></span><br><span class="line">      <span class="comment">// 我们现在是不是在实现继承，让子类拥有父类的属性和方法</span></span><br><span class="line">      <span class="comment">// 我们需要先继承父类的属性和方法，然后再扩展自己的属性和方法。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">5</span>, <span class="number">3</span>, <span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">    p.<span class="title function_">sum</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line"><span class="number">1.</span> 子类不能往父类构造函数传参， 通过<span class="variable language_">super</span>() 就可以往父类构造函数传参</span><br></pre></td></tr></table></figure>

<h4 id="32-事件循环"><a href="#32-事件循环" class="headerlink" title="32.事件循环"></a>32.事件循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">老师的：  答的时候随便答一下<span class="variable language_">this</span>.<span class="property">$nextTick</span></span><br><span class="line"><span class="comment">//     事件循环（eventloop）:</span></span><br><span class="line"><span class="comment">// 1、主线程上面的同步代码，</span></span><br><span class="line"><span class="comment">// 2、取出微任务列表里面所有的微任务，全部执行</span></span><br><span class="line"><span class="comment">// 3、取出宏任务队列里面的一个宏任务，执行</span></span><br><span class="line"><span class="comment">// 4、继续执行第2步</span></span><br><span class="line"><span class="comment">// 5、继续执行第3步</span></span><br><span class="line"><span class="comment">// 6、继续执行第2步</span></span><br><span class="line"><span class="comment">// 7、继续执行第3步</span></span><br><span class="line">我的：</span><br><span class="line">事件循环，最开始，执行script这个宏任务，执行过程中，同步任务立即执行，宏任务放入宏任务队列中，微任务放入微任务队列中，等整个script脚本这个宏任务执行完之后，再去微任务队列中看有没有需要执行的微任务如果有的话就依次执行，执行完了之后，执行完，是否需要渲染页面,浏览器更新渲染完成，去看宏任务队列中是否有宏任务，如果有拿一个出来执行，执行完了之后再去看微任务队列中有需要执行的微任务，如果有，全部执行完，再去宏任务里看，依次循环</span><br><span class="line">浏览器和<span class="title class_">Node</span> 环境下，微任务 任务队列的执行时机不同 - <span class="title class_">Node</span>端，微任务 在事件循环的各个阶段之间执行 - 浏览器端，微任务 在事件循环的 宏任务 执行完之后执行</span><br><span class="line">node的几大阶段</span><br><span class="line"><span class="number">1.</span>timers 阶段：这个阶段执行timer（<span class="built_in">setTimeout</span>、<span class="built_in">setInterval</span>）的回调</span><br><span class="line"><span class="number">2.</span>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</span><br><span class="line"><span class="number">3.</span>idle, prepare 阶段：仅node内部使用</span><br><span class="line"><span class="number">4.</span>poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</span><br><span class="line"><span class="number">5.</span>check 阶段：执行 <span class="title function_">setImmediate</span>() 的回调</span><br><span class="line"><span class="number">6.</span>close callbacks 阶段：执行 socket 的 close 事件回调</span><br></pre></td></tr></table></figure>

<img src="../image/image-20230219132516276.png" alt="image-20230219132516276" style="zoom:80%;" />

<h4 id="33-宏任务-微任务"><a href="#33-宏任务-微任务" class="headerlink" title="33.宏任务 微任务"></a>33.宏任务 微任务</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Event Loop 事件循环</span></span><br><span class="line"> 宏任务：</span><br><span class="line"><span class="comment">// 1. script代码块</span></span><br><span class="line"><span class="comment">// 2. setTimeout / setInterval </span></span><br><span class="line"><span class="comment">// 3. setImmediate</span></span><br><span class="line"> <span class="comment">//4.UI rendering</span></span><br><span class="line"> <span class="comment">//5.I/O</span></span><br><span class="line"> <span class="comment">//6.MessageChannel</span></span><br><span class="line"></span><br><span class="line"> 微任务：</span><br><span class="line"><span class="comment">// 1. promise.then() 和 promise.catch()</span></span><br><span class="line"><span class="comment">// 2. async await (generator和yeild的语法糖)  ==&gt; await 这一行后面的那些会放到微任务队列中</span></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// await 这一行的代码，同步执行的</span></span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="comment">// await 后面的代码会放到微任务队列中</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3.MutationObserver  ==&gt; 监听DOM元素的变化，执行回调函数</span></span><br><span class="line"><span class="comment">// 4.process.nextTick  ==&gt; node中的</span></span><br><span class="line"><span class="comment">//5.Object.observe</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>事件循环理解</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 微任务是包含在宏任务里面的吗？</span></span><br><span class="line"><span class="comment">// 一个宏任务可以包含微任务</span></span><br><span class="line"><span class="comment">// 2. 一个宏任务里面可以有多个微任务吗？ 可以 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 什么时候是一个宏任务结束呢 ， 当当前宏任务中的所有微任务队列清空完，本轮tick执行完</span></span><br><span class="line"><span class="comment">//    之后，再执行下一个宏任务 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 微任务在本次事件循环的最后吗 是</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 首先script代码块可以看做第一个宏任务，开始第一个Tick事件循环</span></span><br><span class="line"><span class="comment">// 2. 会先执行script代码块中的同步代码，</span></span><br><span class="line"><span class="comment">// 3. 如果遇到宏任务，就放到宏任务队列中等待执行,  如果遇到微任务，放到微任务队列中</span></span><br><span class="line"><span class="comment">// 3. 当主线程执行完同步代码的时候，首先，去微任务队列中清空当前事件循环的所有微任务 （本轮事件循环Tick结束）</span></span><br><span class="line"><span class="comment">// 4. 再去执行下一个宏任务  ==&gt; 这个时候是下一次事件循环了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 2 4 3 666 888 （本轮宏任务执行完）==&gt; log 1 是下一个宏任务</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 宏任务队列 1  // 遇到宏任务了，把这里的回调函数 放到宏任务队列中等待执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// new Promise内部这里的代码，同步执行 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">3</span>) <span class="comment">// 可以跳过</span></span><br><span class="line">  <span class="comment">// resolve()</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里的.then() 这块代码，放到微任务队列中执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 又放到微任务队列中</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">666</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 微任务队列</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">888</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏任务和微任务的关系</span></span><br><span class="line"><span class="comment">// 拔萝卜 萝卜上面有泥巴~~~</span></span><br><span class="line"><span class="comment">// 执行一个宏任务，就相当于拔一个萝卜， 这些泥就相当于是这次循环的所有微任务，</span></span><br><span class="line"><span class="comment">// 我们需要把泥洗干净（清空当前循环的所有微任务队列）</span></span><br><span class="line"><span class="comment">// 之后再去执行下一个宏任务，拔下个萝卜</span></span><br></pre></td></tr></table></figure>

<p><strong>面试题</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 这里的代码是同步执行的 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>()        <span class="comment">// 注意： await 这一行是同步执行的</span></span><br><span class="line">  <span class="comment">// 下面的代码相当于.then()中的代码，会放到微任务队列中执行 </span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>) <span class="comment">// 微-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)  <span class="comment">// 宏-1 </span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>) <span class="comment">// 微-2</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>) <span class="comment">// 微-3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 1. script start</span></span><br><span class="line"><span class="comment">// 2. async1 start</span></span><br><span class="line"><span class="comment">// 3. async2</span></span><br><span class="line"><span class="comment">// 4. Promise</span></span><br><span class="line"><span class="comment">// 5. script end</span></span><br><span class="line"><span class="comment">// 6. async1 end</span></span><br><span class="line"><span class="comment">// 7. promise1</span></span><br><span class="line"><span class="comment">// 8. promise2  ===&gt; 本轮宏任务结束</span></span><br><span class="line"><span class="comment">// 9. setTimeout</span></span><br></pre></td></tr></table></figure>

<h4 id="34-this是如何工作的"><a href="#34-this是如何工作的" class="headerlink" title="34.this是如何工作的"></a>34.this是如何工作的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span> 被自动定义在所有函数的作用域中除了箭头函数，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 <span class="variable constant_">API</span> 设计或者函数变得更加简洁，而且还更容易复用。</span><br><span class="line"><span class="number">1.</span>在非严格模式下</span><br><span class="line">普通函数调用：<span class="variable language_">this</span>指向调用者</span><br><span class="line">构造函数调用：<span class="variable language_">this</span>指向实例</span><br><span class="line">对象的方法调用：<span class="variable language_">this</span>指向对象</span><br><span class="line">事件绑定的回调函数：<span class="variable language_">this</span>指向事件源</span><br><span class="line">定时器：<span class="variable language_">this</span>指向<span class="variable language_">window</span></span><br><span class="line">立即执行函数：<span class="variable language_">this</span>指向<span class="variable language_">window</span></span><br><span class="line"><span class="number">2.</span>在严格模式下</span><br><span class="line">开启严格模式 在script标签或函数里写一个字符串<span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">首先严格模式，不允许未声明就赋值，以前 未声明就赋值，默认是全局变量</span><br><span class="line">严禁删除已经声明的变量 例 <span class="keyword">delete</span> 变量名</span><br><span class="line"><span class="variable language_">this</span> 指向改变</span><br><span class="line">普通函数<span class="variable language_">window</span>调用 ，<span class="variable language_">this</span>指向<span class="literal">undefined</span></span><br><span class="line">以前构造函数不加<span class="keyword">new</span>也可以调用，严格模式，构造函数必须加<span class="keyword">new</span>调用</span><br><span class="line">其余都没变</span><br><span class="line"></span><br><span class="line">但在<span class="variable constant_">JS</span>中并不是所有的对象都可以被删除的</span><br><span class="line"><span class="variable constant_">JS</span>中通过 <span class="keyword">var</span>\<span class="keyword">function</span> 声明因含有<span class="title class_">DontDelete</span>，而不可被删除：</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">x</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但是对象的属性、数组成员却是可以删除的：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">delete</span> o.<span class="property">x</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> o.<span class="property">x</span>; <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="35-js模块化"><a href="#35-js模块化" class="headerlink" title="35.js模块化"></a>35.js模块化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">概念：</span><br><span class="line">    <span class="number">1.</span> 把一个大的程序拆分成<span class="string">`互相依赖`</span>的若干**小文件**</span><br><span class="line">    <span class="number">2.</span> 这些小文件还可以通过**特定的语法**组合到一起</span><br><span class="line">    <span class="number">3.</span> 这个过程称之为**模块化** </span><br><span class="line">      **优点：**   </span><br><span class="line">        <span class="number">1.</span> 更好维护   </span><br><span class="line">        <span class="number">2.</span> 更好的复用性</span><br><span class="line">        主要的两个模块：<span class="number">1.</span>common.<span class="property">js</span>模块   es6 <span class="title class_">Meldule</span></span><br></pre></td></tr></table></figure>

<h4 id="36-说说匿名函数"><a href="#36-说说匿名函数" class="headerlink" title="36.说说匿名函数"></a>36.说说匿名函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">匿名函数： 没有名字的函数，用函数表达式声明的函数就是匿名函数</span><br><span class="line">例： <span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line">调用<span class="title function_">fn</span>()</span><br><span class="line">匿名函数的作用：</span><br><span class="line"><span class="number">1</span>、通过匿名函数可以实现闭包（必须掌握的知识点）</span><br><span class="line"><span class="number">2</span>、模拟块级作用域，减少全局变量。执行完匿名函数，存储在内存中相对应的变量会被销毁，使用块级作用域，会大大降低命名冲突的问题，不必担心搞乱全局作用域了。</span><br><span class="line">真正的匿名函数</span><br><span class="line">  <span class="comment">// 推荐使用</span></span><br><span class="line">    (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;zxx&#x27;</span>)</span><br><span class="line">    &#125;()) <span class="comment">//加小括号调用  这就是立即执行函数，所以说立即执行函数也是匿名函数</span></span><br></pre></td></tr></table></figure>

<h4 id="37-说说立即执行函数"><a href="#37-说说立即执行函数" class="headerlink" title="37.说说立即执行函数"></a>37.说说立即执行函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">声明一个函数，并马上调用这个匿名函数就叫做立即执行函数。在定义好一个函数后，直接执行。</span><br><span class="line">语法：</span><br><span class="line"><span class="number">1.</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line"><span class="number">1</span>、避免了污染全局变量。</span><br><span class="line"><span class="number">2</span>、立即执行函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</span><br><span class="line"><span class="number">3</span>、封装变量。</span><br></pre></td></tr></table></figure>

<h4 id="38-说说函数柯里化"><a href="#38-说说函数柯里化" class="headerlink" title="38.说说函数柯里化"></a>38.说说函数柯里化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">什么是函数柯里化：</span><br><span class="line"><span class="number">1.</span>柯里化就是将函数拆分成两个函数，每个函数都只接受一个参数，返回函数</span><br><span class="line"><span class="number">2.</span>柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary</span><br><span class="line">作用：函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (a) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者采用箭头函数写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">const</span> f = <span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="39-如何判断一个变量是不是数组"><a href="#39-如何判断一个变量是不是数组" class="headerlink" title="39.如何判断一个变量是不是数组"></a>39.如何判断一个变量是不是数组</h4><p><code>1.Array.isArray()</code></p>
<p><code>2.构造函数的coustructor</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">let</span> a2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a2.<span class="property">constructor</span>.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&#x27;Array&#x27;</span>))</span><br><span class="line"><span class="comment">//a2相当于Array的实例，a2.constructor指向Array，再调用Function上的toString()方法，把构造函数Array转化为字符串</span></span><br><span class="line"><span class="comment">//再调用indexOf()方法， function Array()&#123;&#125;,判断Array是不是在这个字符串是第9个</span></span><br><span class="line"><span class="comment">//注意： Array 和Object的__proto__都指向Function的prototype</span></span><br><span class="line"><span class="comment">// Array 和Object 都是构造函数，都是Function创建出来的实例</span></span><br></pre></td></tr></table></figure>

<p><code>3.  instanceof</code></p>
<p><code>4. Object.prototype.toString.call()</code></p>
<p><code>5. **isPrototypeOf()**</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(a3)) </span><br></pre></td></tr></table></figure>

<h4 id="40-原始值类型包装"><a href="#40-原始值类型包装" class="headerlink" title="40.原始值类型包装"></a>40.原始值类型包装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">问题：为什么简单数据类型没有对象的特征，却可以调用这些方法，我最开始以为的是，这种声明字符串的方法，就是利用<span class="title class_">String</span>构造函数实例化str，str是实例了，自然可以调用原型上的方法，然而却不是的，当这种简单数据类型，调用方法时，js内部会做三件事，</span><br><span class="line"><span class="number">1.</span>创建一个<span class="title class_">String</span>的实例</span><br><span class="line"><span class="number">2.</span>调用实例上的特定方法</span><br><span class="line"><span class="number">3.</span>销毁实例</span><br><span class="line"><span class="keyword">let</span> str =<span class="string">&#x27;123&#x27;</span></span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)    以上两句代码js在内部相当于做了一下代码</span><br><span class="line"><span class="number">1.</span> <span class="keyword">const</span> str = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&#x27;123&#x27;</span>) 或 <span class="keyword">new</span> <span class="title class_">String</span>()</span><br><span class="line"><span class="number">2.</span>  str = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="number">3.</span>  str = <span class="literal">null</span></span><br><span class="line">这也就意味着，简单数据类型不能像引用类型一样自由的添加属性</span><br><span class="line"><span class="number">1.</span> <span class="title class_">JavaScript</span>也可以使用<span class="title class_">Object</span>函数显式地将基本类型转换为包装类型：</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>(a) <span class="comment">// String &#123;&quot;abc&quot;&#125;</span></span><br><span class="line"><span class="number">2.</span> 也可以使用valueOf方法将包装类型倒转成基本类型：</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Object</span>(a)</span><br><span class="line"><span class="keyword">var</span> c = b.<span class="title function_">valueOf</span>() <span class="comment">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="41-x3D-x3D-和-x3D-x3D-x3D-的区别以及扩展es6方法"><a href="#41-x3D-x3D-和-x3D-x3D-x3D-的区别以及扩展es6方法" class="headerlink" title="41.&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别以及扩展es6方法"></a>41.&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别以及扩展es6方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">==:会隐式转换数据类型，只比较值，不比较数据类型，返回布尔值</span><br><span class="line">===：不会转换数据类型，值和数据类型都相等才返回<span class="literal">true</span></span><br><span class="line">es6新增了一个<span class="title class_">Object</span>.<span class="title function_">is</span>() 严格判断两个值是否相等，能判断<span class="title class_">NaN</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>,<span class="title class_">NaN</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>,-<span class="number">0</span>)    <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="42-同源策略"><a href="#42-同源策略" class="headerlink" title="42.同源策略"></a>42.同源策略</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同源：两个url的协议 主机(域名) 端口 一致 则同源，否则跨域</span><br><span class="line">同源策略：浏览器提供的一种安全策略，只在浏览器上存在，不允许两个不同的url进行交互</span><br><span class="line">解决跨域：</span><br><span class="line"><span class="number">1</span>，<span class="variable constant_">CORS</span> ：设置响应头：后端的事情</span><br><span class="line"><span class="number">2.</span> 起一个服务器</span><br></pre></td></tr></table></figure>

<h4 id="43-null和undefined的区别"><a href="#43-null和undefined的区别" class="headerlink" title="43.null和undefined的区别"></a>43.null和undefined的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">null</span>:表示一个空对象指针，在获取 <span class="variable constant_">DOM</span> 元素时,如果没有获取到,返回的是 <span class="literal">null</span>,原型链的最顶端也是 <span class="literal">null</span>，<span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">//Object</span></span><br><span class="line"> <span class="literal">null</span>转化为number是<span class="number">0</span></span><br><span class="line"><span class="literal">undefined</span>：</span><br><span class="line"><span class="number">1.</span>一般定义了变量未赋值</span><br><span class="line"><span class="number">2.</span>访问对象中没有这个属性</span><br><span class="line"><span class="number">3.</span>访问函数的形参时，没有传实参</span><br><span class="line"><span class="number">4.</span>函数没有<span class="keyword">return</span>，调用的结果也是<span class="literal">undefined</span>,以及<span class="keyword">return</span> 后面没有值</span><br><span class="line"><span class="literal">undefined</span> 转化为number 是 <span class="title class_">NaN</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> 表示一个变量初始状态值，而 <span class="literal">null</span> 则表示一个变量被认为的设置为空对象，而不是原始状态 ，当需要释放一个对象时，直接赋值为 <span class="literal">null</span> 即可。即表示该对象已经被清空，目前无效状态。 <span class="variable constant_">GC</span> 会择机回收该值并释放内存</span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> 其实属于自己的类型 <span class="title class_">Null</span>，而不属于<span class="title class_">Object</span>类型，<span class="keyword">typeof</span> 之所以会判定为 <span class="title class_">Object</span> 类型，是因为<span class="title class_">JavaScript</span> 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 <span class="number">0</span> 会被 <span class="keyword">typeof</span> 判断为对象类型，而 <span class="literal">null</span> 的二进制位恰好都是 <span class="number">0</span> ，因此，<span class="literal">null</span> 被误判断为 <span class="title class_">Object</span> 类型</span><br></pre></td></tr></table></figure>

<h4 id="44-说一下内存泄漏"><a href="#44-说一下内存泄漏" class="headerlink" title="44.说一下内存泄漏"></a>44.说一下内存泄漏</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存的生命周期：</span><br><span class="line"><span class="number">1.</span>分配所需要的内存</span><br><span class="line"><span class="number">2.</span>在内存中进行读写操作</span><br><span class="line"><span class="number">3.</span>垃圾清除，释放 /回收内存</span><br><span class="line">js中在定义变量，就已经分配好内存，同时也提供了垃圾回收的机制，回收那些不在需要使用的内存，</span><br><span class="line">内存泄漏：程序认为一个变量已经没有在使用了，而垃圾回收机制认为它还在使用，从而导致这段内存无法释放，造成内存泄漏</span><br></pre></td></tr></table></figure>

<p><strong>内存泄漏的几种方式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>闭包  <span class="number">2.</span>垃圾回收机制的引用计数法 <span class="number">3.</span>意外的全局变量 <span class="number">4.</span><span class="variable language_">console</span>.<span class="title function_">log</span>()打印一个局部变量，或者是引用数据类型也会导致内存泄漏，所以我们项目一般上线前会把<span class="variable language_">console</span>.<span class="title function_">log</span>()代码注释掉</span><br><span class="line"><span class="number">5.</span>、<span class="variable constant_">DOM</span> 元素的引用、 <span class="number">6.</span>定时器</span><br></pre></td></tr></table></figure>



<h4 id="45-说一下script标签中的defer-和async属性"><a href="#45-说一下script标签中的defer-和async属性" class="headerlink" title="45.说一下script标签中的defer 和async属性"></a>45.说一下script标签中的defer 和async属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">script无属性：</span><br><span class="line"><span class="number">1.1</span> 个人理解：无属性的话，如果不是放在html的尾部，放在头部的话就一定会阻塞<span class="variable constant_">HTML</span>的解析，遇到无属性的script标签，则会先加载脚本，再执行脚本，执行完之后，再解析<span class="variable constant_">HTML</span>，如果途中又遇到无属性的script标签，则又会停止对<span class="variable constant_">HTML</span>的解析，多个连续的无属性脚本请求加载和执行顺序与出现在文档中的顺序相同，而且一个脚本的加载请求一定是在上一个脚本执行完之后才开始的，</span><br><span class="line"></span><br><span class="line">script标签<span class="keyword">async</span>属性：</span><br><span class="line"><span class="number">2.1</span> 个人理解：script的<span class="keyword">async</span>属性不一定会阻塞<span class="variable constant_">HTML</span>的解析，但是<span class="keyword">async</span>属性可以在加载脚本的同时解析<span class="variable constant_">HTML</span>，但是如果加载脚本完成了，<span class="variable constant_">HTML</span>还没解析完，就会阻塞<span class="variable constant_">HTML</span>的解析，并且立即执行脚本，执行完之后，再对<span class="variable constant_">HTML</span>进行解析，如果加载脚本的过程中，<span class="variable constant_">HTML</span>已经解析完毕了，则就不会出现解析的情况了，当有多个<span class="keyword">async</span>属性的script时，不一定会按照html的出现顺序相同，与脚本的加载成功顺序有关</span><br><span class="line"><span class="number">3.</span>defer脚本  不会阻塞<span class="variable constant_">HTML</span>的解析，即使该脚本请求加载可以和<span class="variable constant_">HTML</span>解析并行，但是脚本的执行会被安排在<span class="variable constant_">HTML</span>解析完成后之后，多个连续的defer脚本一定按照文档中的顺序执行</span><br><span class="line"><span class="number">3.1</span> 个人理解：defer脚本，一定不会阻塞<span class="variable constant_">HTML</span>的解析，当遇到defer的script属性的脚本，先会加载脚本，并解析<span class="variable constant_">HTML</span>，当defer脚本加载完了之后，并不会立马执行脚本，是等<span class="variable constant_">HTML</span>解析完毕后，再执行defer脚本，多个defer脚本，一定是按照出现在<span class="variable constant_">HTML</span>文档中的顺序执行的</span><br><span class="line">相同之处：</span><br><span class="line">script标签的defer和<span class="keyword">async</span>属性都是去异步加载外部的<span class="variable constant_">JS</span>脚本文件，加载的过程中不会阻塞浏览器对<span class="variable constant_">HTML</span>的解析过程（注意：这里说的仅仅是加载的过程）</span><br><span class="line"><span class="comment">//下面2中方法也可以延迟脚本执行</span></span><br><span class="line">动态加载脚本：通过 <span class="title class_">JavaScript</span> 动态创建 script 标签，并设置其 src 属性来实现脚本的异步加载，这种方式需要在脚本加载完成后手动执行脚本。</span><br><span class="line">懒加载模式：在需要时再加载脚本，可以使用 jQuery 等库实现，或者通过自己编写的函数来实现</span><br></pre></td></tr></table></figure>

<img src="../image/image-20230120105153309.png" alt="image-20230219132516276" style="zoom:80%;" />


<p><strong>使用场景</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在什么场景下用什么类型的脚本呢？</span><br><span class="line"></span><br><span class="line">如果脚本是模块化的并且不依赖任何脚本，那么使用<span class="keyword">async</span>脚本</span><br><span class="line">如果脚本依赖另一个脚本或被另一个脚本依赖，则使用defer脚本</span><br><span class="line">如果脚本很小并且被另一个<span class="keyword">async</span>脚本所依赖，那么可以将无属性的脚本放置在<span class="keyword">async</span>脚本之上</span><br><span class="line">因为这样我们可以确保<span class="keyword">async</span>脚本一定在无属性脚本之后执行</span><br><span class="line">一般来说我们的脚本都要放置在文档的底部，因为考虑到无属性脚本和<span class="keyword">async</span>脚本都有可能会阻塞<span class="variable constant_">HTML</span>的解析，当然defer脚本是可以随便放的</span><br></pre></td></tr></table></figure>

<p><strong>为什么会导致阻塞</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">渲染阻塞的原因： 由于 <span class="title class_">JavaScript</span> 是可操纵 <span class="variable constant_">DOM</span> 的,如果在修改这些元素属性同时渲染界面（即 <span class="title class_">JavaScript</span> 线程和 <span class="variable constant_">UI</span> 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果,浏览器设置 <span class="variable constant_">GUI</span> 渲染线程与 <span class="title class_">JavaScript</span> 引擎为互斥的关系。当浏览器在执行 <span class="title class_">JavaScript</span> 程序的时候,<span class="variable constant_">GUI</span> 渲染线程会被保存在一个队列中,直到 <span class="variable constant_">JS</span> 程序执行完成,才会接着执行。如果 <span class="variable constant_">JS</span> 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉</span><br></pre></td></tr></table></figure>

<h4 id="46-说一下-web-worker"><a href="#46-说一下-web-worker" class="headerlink" title="46.说一下 web worker"></a>46.说一下 web worker</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 <span class="variable constant_">HTML</span> 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</span><br><span class="line"><span class="string">&#x27;如何创建 web worker：</span></span><br><span class="line"><span class="string">1.检测浏览器对于 web worker 的支持性</span></span><br><span class="line"><span class="string">2.创建 web worker 文件（js，回传函数等）</span></span><br><span class="line"><span class="string">3.创建 web worker 对象</span></span><br></pre></td></tr></table></figure>

<h4 id="47-说一下什么是可变对象什么是不可变对象"><a href="#47-说一下什么是可变对象什么是不可变对象" class="headerlink" title="47.说一下什么是可变对象什么是不可变对象"></a>47.说一下什么是可变对象什么是不可变对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可变对象:把对象a赋值给对象b，更改对象b的属性值，被引用的对象a也随之改变，这就是可变对象。</span><br><span class="line">不可变对象：<span class="title class_">Object</span>.<span class="property">preventExtensions</span>（不可扩展）、<span class="title class_">Object</span>.<span class="property">seal</span>（密封）、<span class="title class_">Object</span>.<span class="property">freeze</span>（冻结）。参数是对象</span><br></pre></td></tr></table></figure>

<h4 id="48-Set-和-Map有什么区别？"><a href="#48-Set-和-Map有什么区别？" class="headerlink" title="48.Set 和 Map有什么区别？"></a>48.Set 和 Map有什么区别？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="title class_">Map</span>可以通过get方法获取值，而set不能因为它只有值</span><br><span class="line"><span class="number">2</span>、都能通过迭代器进行<span class="keyword">for</span>...<span class="keyword">of</span> 遍历</span><br><span class="line"><span class="number">3.</span>set 是es6 提供的一种新的数据结构，它类似于数组，但是成员的值都是唯一的。</span><br><span class="line"><span class="number">4.</span>map 是es6 提供的一种新的数据结构,它类似于对象，也是键值对的集合，但是键的范围不仅限于字符</span><br><span class="line">串，各种类型的值都可以当做键。也就是说，<span class="title class_">Object</span> 结构提供了“字符串—值”的对应，<span class="title class_">Map</span> 结构提供</span><br><span class="line">了“值—值”的对应，是一种更完善的 <span class="title class_">Hash</span> 结构实现。如果你需要“键值对”的数据结构，<span class="title class_">Map</span> 比 <span class="title class_">Object</span></span><br><span class="line">更合适。</span><br></pre></td></tr></table></figure>

<img src="../image/image-20230305152342255.png" alt="image-20230305152342255" style="zoom:67%;" />

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- **size**： <span class="string">`map.size`</span> 返回<span class="title class_">Map</span>结构的成员总数。</span><br><span class="line">- **<span class="title function_">set</span>(key,value)**：设置键名key对应的键值value，然后返回整个<span class="title class_">Map</span>结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前<span class="title class_">Map</span>对象，所以可以链式调用）</span><br><span class="line">- **<span class="title function_">get</span>(key)**：该方法读取key对应的键值，如果找不到key，返回<span class="literal">undefined</span>。</span><br><span class="line">- **<span class="title function_">has</span>(key)**：该方法返回一个布尔值，表示某个键是否在当前<span class="title class_">Map</span>对象中。</span><br><span class="line">- **<span class="title function_">delete</span>(key)**：该方法删除某个键，返回<span class="literal">true</span>，如果删除失败，返回<span class="literal">false</span>。</span><br><span class="line">- **<span class="title function_">clear</span>()**：map.<span class="title function_">clear</span>()清除所有成员，没有返回值。</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">     [<span class="string">&quot;foo&quot;</span>,<span class="number">1</span>],</span><br><span class="line">     [<span class="string">&quot;bar&quot;</span>,<span class="number">2</span>],</span><br><span class="line">])</span><br></pre></td></tr></table></figure>



<h4 id="49-如何将类数组转化为真数组"><a href="#49-如何将类数组转化为真数组" class="headerlink" title="49.如何将类数组转化为真数组"></a>49.如何将类数组转化为真数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">伪数组和真数组的区别： <span class="number">1.</span> 伪数组可以使用length ，但是不能修改length，可以使用下标取值，但是不能使用数组的其他方法，<span class="number">2.</span>伪数组是一个对象  遍历使用<span class="keyword">for</span> <span class="keyword">in</span>方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过call调用数组的slice方法来实现转换</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过call调用数组的splice方法来实现转换</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">splice</span>.<span class="title function_">call</span>(arrayLike,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过apply调用数组的concat方法来实现转换</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([],arrayLike)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Array.from方法来实现转换</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike)</span><br><span class="line"><span class="comment">//扩展运算符</span></span><br><span class="line"><span class="keyword">let</span> newArr = [...arr]</span><br></pre></td></tr></table></figure>

<h4 id="50-为什么js是单线程"><a href="#50-为什么js是单线程" class="headerlink" title="50.为什么js是单线程"></a>50.为什么js是单线程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。</span><br><span class="line">举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，<span class="title class_">JavaScript</span>就是单线程，这已经成了这门语言的核心特征，将来也不会改变</span><br><span class="line"></span><br><span class="line">为了利用多核<span class="variable constant_">CPU</span>的计算能力，<span class="title class_">HTML5</span>提出<span class="title class_">Web</span> <span class="title class_">Worker</span>标准，允许<span class="title class_">JavaScript</span>脚本创建多个线程，但是子线程完全受主线程控制，且不得操作<span class="variable constant_">DOM</span>。所以，这个新标准并没有改变<span class="title class_">JavaScript</span>单线程的本质。</span><br></pre></td></tr></table></figure>

<h4 id="51-说说promise的all和race"><a href="#51-说说promise的all和race" class="headerlink" title="51.说说promise的all和race"></a>51.说说promise的all和race</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">all</span>()和promise.<span class="title function_">race</span>()接收的都是数组</span><br><span class="line"><span class="number">1.</span>promise.<span class="title function_">all</span>() 是当数组中的每一个异步任务返回结果后，才执行后面的代码</span><br><span class="line">应用场景：当我们需要让用户同时看到多个数据的展示时</span><br><span class="line"><span class="number">2.</span>promise.<span class="title function_">race</span>()是数组中最快的那个异步任务返回结果后，就执行后的代码</span><br></pre></td></tr></table></figure>

<h4 id="52-立即执行函数面试题"><a href="#52-立即执行函数面试题" class="headerlink" title="52.立即执行函数面试题"></a>52.立即执行函数面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>; </span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;   <span class="comment">//到这的时候 b被赋值为了这个立即执行函数</span></span><br><span class="line">  b = <span class="number">20</span>;         <span class="comment">//(b=20)(因为函数表达式特性，标识符无法被修改，所以这里执行失败)</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b);  <span class="comment">//打印函数</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)    <span class="comment">//离谱 我现在还不知道原因</span></span><br></pre></td></tr></table></figure>

<h4 id="53-说说for-in-和for-of区别"><a href="#53-说说for-in-和for-of区别" class="headerlink" title="53.说说for in 和for of区别"></a>53.说说for in 和for of区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k)  <span class="comment">//0 1 2 3 4 5           如果原型上还有的话，也会遍历</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[k]) <span class="comment">//1,3,4,5,6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> arr)&#123;                        <span class="comment">//不能遍历对象，需要配合Object.keys()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value) <span class="comment">//1,3,4,5,6                  //只能获取到数组元素，不能获取索引 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span>遍历的是数组的索引（即键名），而<span class="keyword">for</span> <span class="keyword">of</span>遍历的是数组元素值    <span class="keyword">for</span> <span class="keyword">in</span>会遍历数组所有的可枚举属性，包括原型</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span>总是得到对象的key或数组、字符串的下标</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">of</span>总是得到对象的value或数组、字符串的值 ,遍历的只是数组内的元素，不包括原型属性和索引</span><br><span class="line"><span class="number">1.</span><span class="keyword">for</span> <span class="keyword">of</span> 只能遍历其底层带有lterator接口的数据结构，像set，map string array 等，对于普通对象没有部署原生的<span class="title function_">lterator</span>(迭代器)接口，所以直接使用<span class="keyword">for</span> <span class="keyword">of</span> 会报错的，因此在项目开发中我们一般使用<span class="keyword">for</span> <span class="keyword">in</span> 遍历对象， <span class="keyword">for</span> <span class="keyword">in</span> 遍历数组返回的是数组下标，而不是元素，而且遍历顺序有可能不是按照实际数组的内部顺序的，所以我们通常遍历数组用的是<span class="keyword">for</span> <span class="keyword">of</span></span><br><span class="line"><span class="number">2.</span>普通对象部署迭代器</span><br><span class="line"><span class="number">2.1</span> 对象转<span class="title class_">Map</span> 用<span class="keyword">for</span> <span class="keyword">in</span> 遍历 普通对象，创建一个<span class="title class_">Map</span> 实例，给这个实例添加我们普通对象的键和值</span><br><span class="line"><span class="number">2.2</span> 我记得 [<span class="title class_">Symbol</span>.<span class="property">iterator</span>] 可以部署迭代器</span><br></pre></td></tr></table></figure>

<h4 id="54-为什么推荐把script标签放到body底部"><a href="#54-为什么推荐把script标签放到body底部" class="headerlink" title="54.为什么推荐把script标签放到body底部"></a>54.为什么推荐把script标签放到body底部</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果把script标签放到head标签中的话，会阻塞html的解析，会先下载脚本，运行脚本，导致页面阻塞，另外，如果说脚本里</span><br><span class="line">用到了html dom节点的话，会导致获取不到，报错，整个进程崩溃</span><br><span class="line"><span class="number">2.</span>放在 body 底部</span><br><span class="line"> html 内容第一时间渲染完成，随后等待 js 的加载。</span><br><span class="line"> 浏览器默认设置js线程 和uI渲染线程是互斥的，如果script脚本，放在头部的话，如果js脚本很大的话，下载和解析很长时间，就会导致页  面出现空白</span><br></pre></td></tr></table></figure>

<h4 id="55-说一下原生js怎么获取dom元素"><a href="#55-说一下原生js怎么获取dom元素" class="headerlink" title="55.说一下原生js怎么获取dom元素"></a>55.说一下原生js怎么获取dom元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、根据id获取元素</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id属性的值&quot;</span>)</span><br><span class="line"><span class="number">2</span>、根据标签名字获取元素</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;标签的名字&quot;</span>);</span><br><span class="line"><span class="number">3</span>、根据name属性的值获取元素</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;name属性的值&quot;</span>);</span><br><span class="line"><span class="number">4</span>、根据类样式的名字获取元素</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;类样式的名字&quot;</span>);</span><br><span class="line"><span class="number">5</span>、根据选择器获取元素</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;选择器&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;选择器&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="56-说一下es6新特性"><a href="#56-说一下es6新特性" class="headerlink" title="56.说一下es6新特性"></a>56.说一下es6新特性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">let</span> 和 <span class="keyword">const</span></span><br><span class="line"><span class="number">2.</span><span class="title class_">Promise</span></span><br><span class="line"><span class="number">3.</span><span class="title class_">Class</span></span><br><span class="line"><span class="number">4.</span>箭头函数</span><br><span class="line"><span class="number">5.</span>函数参数默认值</span><br><span class="line"><span class="number">6.</span>模版字符串</span><br><span class="line"><span class="number">7.</span>解构赋值</span><br><span class="line"><span class="number">8.</span>展开语法</span><br><span class="line"><span class="number">9.</span>构造数组，调用函数时，将数组表达式 或 string 在语法层面展开</span><br><span class="line"><span class="number">10.</span>对象属性缩写</span><br><span class="line">键名和键值相同</span><br><span class="line"><span class="number">11.</span>函数省略 <span class="keyword">function</span></span><br><span class="line"><span class="number">12.</span>模块化</span><br><span class="line"><span class="number">13.</span><span class="title class_">Set</span></span><br></pre></td></tr></table></figure>

<h4 id="57-Object-assign"><a href="#57-Object-assign" class="headerlink" title="57.Object.assign()"></a>57.Object.assign()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="title class_">Object</span>的静态方法，用于浅拷贝，和vue2缺陷，对对象，新增的属性没有响应式</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">someObject</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>.<span class="property">someObject</span>, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="58-break-return-continue的区别"><a href="#58-break-return-continue的区别" class="headerlink" title="58.break return continue的区别"></a>58.break return continue的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">return</span> ：直接跳出当前的方法,返回到该调用的方法的语句处,继续执行</span><br><span class="line"><span class="number">2</span>、<span class="keyword">break</span>：在循环体内结束整个循环过程</span><br><span class="line"><span class="number">3</span>、<span class="keyword">continue</span> ：结束本次的循环，直接进行下一次的循环</span><br></pre></td></tr></table></figure>

<h4 id="59-为什么-0-1-0-2-x3D-0-3"><a href="#59-为什么-0-1-0-2-x3D-0-3" class="headerlink" title="59.为什么 0.1+0.2!&#x3D;0.3"></a>59.为什么 0.1+0.2!&#x3D;0.3</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在做算术运算时，<span class="variable constant_">JS</span> 会先把十进制数转换成二进制数后再计算，十进制小数转二进制数的方式是 x <span class="number">2</span> 取整，<span class="number">0.1</span> 和 <span class="number">0.2</span> 的二进制数是个无限循环小数   计算机是通过二进制的方式存储数据的，所以计算机计算<span class="number">0.1</span>+<span class="number">0.2</span>的时候，实际上是计算的两个数的二进制的和。<span class="number">0.1</span>的二进制是<span class="number">0.0001100110011001100</span>...（<span class="number">1100</span>循环），<span class="number">0.2</span>的二进制是：<span class="number">0.00110011001100</span>...（<span class="number">1100</span>循环）  二进制相加，再转化为十进制数就是：<span class="number">0.30000000000000004</span>。</span><br><span class="line">解决办法: <span class="number">1.</span>可以把小数转化为整数再计算</span><br><span class="line">         <span class="number">2.</span>可以使用一些库，如 <span class="title class_">Decimal</span>(day c bo).<span class="property">js</span>、big.<span class="property">js</span> 等 (在进行精度要求较高的计算时，建议使用)</span><br></pre></td></tr></table></figure>

<h4 id="60-数组里面有2w个元素，取第一个元素和最后一个元素的时间相差多少？"><a href="#60-数组里面有2w个元素，取第一个元素和最后一个元素的时间相差多少？" class="headerlink" title="60.数组里面有2w个元素，取第一个元素和最后一个元素的时间相差多少？"></a>60.数组里面有2w个元素，取第一个元素和最后一个元素的时间相差多少？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 <span class="title function_">O</span>(<span class="number">1</span>)</span><br><span class="line">=&gt; 消耗时间几乎一致，差异可以忽略不计</span><br></pre></td></tr></table></figure>

<h4 id="61-ES6-代码转成-ES5-代码的实现思路是什么？"><a href="#61-ES6-代码转成-ES5-代码的实现思路是什么？" class="headerlink" title="61.ES6 代码转成 ES5 代码的实现思路是什么？"></a>61.ES6 代码转成 ES5 代码的实现思路是什么？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将<span class="title class_">ES6</span> 转为<span class="title class_">ES5</span> 主要用到的是<span class="title class_">Babel</span>编译器， 参考<span class="title class_">Babel</span>的实现方式。</span><br><span class="line">那么 <span class="title class_">Babel</span> 是如何把 <span class="title class_">ES6</span> 转成 <span class="title class_">ES5</span> 呢，其大致分为三步：</span><br><span class="line"><span class="number">1.</span>解析：解析代码字符串，生成 <span class="title function_">AST</span>(抽象语法树)；</span><br><span class="line"><span class="number">2.</span>转换：按一定的规则转换、修改 <span class="variable constant_">AST</span>，将<span class="title class_">ES6</span>转换为<span class="title class_">ES5</span>代码；</span><br><span class="line"><span class="number">3.</span>生成：将修改后的 <span class="variable constant_">AST</span> 转换成普通代码。</span><br></pre></td></tr></table></figure>

<h4 id="62-DOM和BOM区别，以及常用方法"><a href="#62-DOM和BOM区别，以及常用方法" class="headerlink" title="62.DOM和BOM区别，以及常用方法"></a>62.DOM和BOM区别，以及常用方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DOM</span>的顶级对象是<span class="variable language_">document</span>实际上是<span class="variable language_">window</span>.<span class="property">document</span>    <span class="variable constant_">BOM</span>的顶级对象是<span class="variable language_">window</span></span><br><span class="line"><span class="variable constant_">DOM</span> 是为了操作文档出现的 <span class="variable constant_">API</span></span><br><span class="line"><span class="variable constant_">BOM</span> 是为了操作浏览器出现的 <span class="variable constant_">API</span></span><br><span class="line"><span class="variable constant_">DOM</span>常用的api ：</span><br><span class="line"><span class="number">1.</span> 获取元素的方法</span><br><span class="line"><span class="number">2.</span>事件 事件对象  事件注册</span><br><span class="line"><span class="number">3.</span>自定义属性</span><br><span class="line"><span class="number">4.</span>节点操作</span><br><span class="line"><span class="variable constant_">BOM</span>常用的api：</span><br><span class="line"><span class="number">1.</span>定时器</span><br><span class="line"><span class="number">2.</span>scroll事件 resize事件</span><br><span class="line"><span class="number">3.</span>offset 元素偏移量</span><br></pre></td></tr></table></figure>

<h4 id="63-说一下es6的新特性"><a href="#63-说一下es6的新特性" class="headerlink" title="63.说一下es6的新特性"></a>63.说一下es6的新特性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">let</span> <span class="keyword">const</span>  <span class="comment">//解决了变量提升，变量污染问题</span></span><br><span class="line"><span class="number">2.</span>箭头函数</span><br><span class="line"><span class="number">3.</span>解构</span><br><span class="line"><span class="number">4.</span>剩余参数  <span class="comment">//必须写在参数的最后一个 ，否则会报错</span></span><br><span class="line"><span class="number">5.</span><span class="title class_">Set</span> <span class="title class_">Map</span></span><br><span class="line"><span class="number">6.</span>模板字符串 <span class="comment">//支持换行 空格、缩进、，使用变量$&#123;&#125; ，解决了es6之前的变量拼接繁琐问题</span></span><br><span class="line"><span class="number">7.</span>promise</span><br><span class="line"><span class="number">8.</span><span class="title class_">Object</span>.<span class="title function_">assign</span>() <span class="title class_">Object</span>.<span class="title function_">keys</span>() <span class="title class_">Object</span>.<span class="title function_">values</span>()</span><br><span class="line"><span class="number">9.</span>允许直接在对象中写变量，这是变量既是属性名也是属性值，一种对象键值的简写</span><br><span class="line"><span class="number">10.</span>函数的扩展，函数可以给参数提供默认值</span><br><span class="line"><span class="number">11.</span><span class="keyword">for</span> <span class="keyword">of</span> 循环</span><br><span class="line"><span class="number">12.</span><span class="keyword">import</span> <span class="keyword">export</span></span><br><span class="line"><span class="number">13.</span><span class="title class_">Set</span>数据结构</span><br><span class="line"><span class="number">14.</span><span class="keyword">class</span>类</span><br><span class="line"><span class="number">15.</span><span class="title class_">Symbol</span></span><br><span class="line"><span class="number">16.</span><span class="title class_">Proxy</span></span><br></pre></td></tr></table></figure>

<h4 id="64-super-继承"><a href="#64-super-继承" class="headerlink" title="64.super 继承"></a>64.super 继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个子类，继承父类</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">   <span class="comment">// 1. super() 必须在子类的this前面调用</span></span><br><span class="line">   <span class="comment">// 2. super() 代表了父类的构造函数</span></span><br><span class="line">   <span class="comment">// 3. super() 里面的this 指向的是谁呢？</span></span><br><span class="line">   <span class="comment">//  ===&gt; 指向的是子类的实例，Son的实例 p这个对象</span></span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">x, y, color</span>) &#123;</span><br><span class="line">     <span class="variable language_">super</span>(x, y) <span class="comment">// ==&gt; super(x, y)  父类的constructor(x, y)</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">color</span> = color</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4. 怎么理解super()要在this前面调用？</span></span><br><span class="line">   <span class="comment">// 我们现在是不是在实现继承，让子类拥有父类的属性和方法</span></span><br><span class="line">   <span class="comment">// 我们需要先继承父类的属性和方法，然后再扩展自己的属性和方法。</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="65-说一下promise是什么以及使用方法"><a href="#65-说一下promise是什么以及使用方法" class="headerlink" title="65.说一下promise是什么以及使用方法"></a>65.说一下promise是什么以及使用方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这题可以多说说自己在项目中是如何运用 promise 的</span></span><br><span class="line"><span class="number">1.</span><span class="title class_">Promise</span>本身是同步的立即执行函数，当执行了resolve或reject时的.<span class="property">then</span>和.<span class="property">catch</span>的回调是异步微任务，解决了异步多层嵌套回调的问题，让代码的可读性更高，更容易维护</span><br><span class="line"><span class="number">2.</span>使用<span class="title class_">Promise</span>构造函数<span class="keyword">new</span>一个实例，<span class="title class_">Promise</span>构造函数接收一个函数作为参数，这个函数有两个参数，分别是两个函数 <span class="string">`resolve`</span>和<span class="string">`reject`</span>，<span class="string">`resolve`</span>将<span class="title class_">Promise</span>的状态由等待变为成功，将异步操作的结果作为参数传递过去；<span class="string">`reject`</span>则将状态由等待转变为失败，在异步操作失败时调用，将异步操作报出的错误作为参数传递过去。实例创建完成后，可以使用<span class="string">`then`</span>方法分别指定成功或失败的回调函数，也可以使用<span class="keyword">catch</span>捕获失败，then和<span class="keyword">catch</span>最终返回的也是一个<span class="title class_">Promise</span>，所以可以链式调用。</span><br><span class="line"><span class="number">3.</span><span class="title class_">Promise</span>有三种状态 <span class="number">1.</span>pending（执行中）为初始状态 <span class="number">2.</span><span class="title class_">Resolved</span>（成功) <span class="number">3.</span> rejected（失败）   <span class="title class_">Resolved</span> 和rejected为结束状态</span><br><span class="line">（结束状态表示promise的生命周期已结束）  resolve 方法的参数是then中回调函数的参数，reject 方法中的参数是<span class="keyword">catch</span>中的参数 <span class="number">4.</span> then 方法和 <span class="keyword">catch</span>方法 只要不报错，返回的都是一个成功状态的promise</span><br><span class="line"><span class="number">4.</span>promise的其他方法</span><br><span class="line"> <span class="number">4.1</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() :返回的<span class="title class_">Promise</span>对象状态为成功的，并且将该value传递给对应的then方法。 </span><br><span class="line"> <span class="number">4.2</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>()：返回一个状态为失败的<span class="title class_">Promise</span>对象，并将给定的失败信息传递给对应的<span class="keyword">catch</span>或.<span class="property">then</span>的第二个参数。</span><br><span class="line"> <span class="number">4.3</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>()：返回一个新的promise对象，该promise对象在参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。 </span><br><span class="line"> <span class="number">4.4</span> <span class="title class_">Promise</span>.<span class="title function_">any</span>()：接收一个<span class="title class_">Promise</span>对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。</span><br><span class="line"> <span class="number">4.5</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>()：当参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应的.<span class="property">then</span> 或.<span class="property">catch</span>，并返回该promise对象。</span><br><span class="line"><span class="number">5.</span> <span class="keyword">async</span> <span class="keyword">await</span> 是promise的语法糖</span><br><span class="line"><span class="keyword">async</span>意为异步，<span class="keyword">await</span>意为等待  为优化then链而开发出来的</span><br><span class="line"><span class="keyword">async</span>函数会返回一个promise ，如果<span class="keyword">async</span>函数内部没有<span class="keyword">return</span> 则promise.<span class="title function_">resolve</span>()的参数就是<span class="literal">undefined</span>，如果有返回值的话，参数就是<span class="keyword">async</span>函数<span class="keyword">return</span>后面的对象，如果不用<span class="keyword">await</span>的话，就用.<span class="property">then</span>获取对应的值，用<span class="keyword">await</span>的话，<span class="keyword">await</span>则是在等待<span class="keyword">async</span>函数的返回值，- 如果它等到的不是一个 <span class="title class_">Promise</span> 对象，那 <span class="keyword">await</span> 表达式的运算结果就是它等到的东西。 如果它等到的是一个 <span class="title class_">Promise</span> 对象，它会阻塞后面的代码，等着 <span class="title class_">Promise</span> 对象 resolve，然后得到 resolve 的值，作为 <span class="keyword">await</span> 表达式的运算结果。</span><br><span class="line"><span class="number">6.</span><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">finally</span>()</span><br><span class="line"><span class="title function_">finally</span>() 方法返回一个 <span class="title class_">Promise</span>。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数	</span><br><span class="line">缺陷：</span><br><span class="line">- 无法取消<span class="title class_">Promise</span>，一旦新建它就会立即执行，无法中途取消。</span><br><span class="line">- 如果不设置回调函数，<span class="title class_">Promise</span>内部抛出的错误，不会反应到外部。</span><br><span class="line">- 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</span><br><span class="line"></span><br><span class="line">promise.<span class="property">then</span>和<span class="keyword">await</span>的区别</span><br><span class="line"><span class="title class_">Async</span>/<span class="title class_">Await</span>与<span class="title class_">Promise</span>最大区别在于：<span class="keyword">await</span> <span class="title function_">b</span>()会暂停所在的<span class="keyword">async</span>函数的执行；而<span class="title class_">Promise</span>.<span class="title function_">then</span>(b)将b函数加入回调链中之后，会继续执行当前函数。对于堆栈来说，这个不同点非常关键。</span><br><span class="line"><span class="comment">//Promise 的使用场景包括：</span></span><br><span class="line"><span class="number">1.</span>处理异步操作：比如 <span class="title class_">Ajax</span> 请求、文件读取等。</span><br><span class="line"><span class="number">2.</span>优化回调函数：将回调函数转换成 <span class="title class_">Promise</span> 链，提高代码可读性。</span><br><span class="line"><span class="number">3.</span>实现并发请求：<span class="title class_">Promise</span>.<span class="title function_">all</span>() 可以让多个请求并行执行。</span><br><span class="line"><span class="number">4.</span>解决回调地狱：将嵌套的回调函数转换成链式调用，提高代码可读性。</span><br></pre></td></tr></table></figure>

<h4 id="66-js实现异步的方法"><a href="#66-js实现异步的方法" class="headerlink" title="66.js实现异步的方法"></a>66.js实现异步的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">回调函数、事件监听、<span class="built_in">setTimeout</span>、<span class="title class_">Promise</span>、生成器<span class="title class_">Generators</span>/<span class="keyword">yield</span>、 <span class="keyword">async</span> /<span class="keyword">await</span> </span><br><span class="line">所有异步任务都是在同步任务执行结束之后，从任务队列中依次取出执行。</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">generator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="67-数组去重的方法"><a href="#67-数组去重的方法" class="headerlink" title="67.数组去重的方法"></a>67.数组去重的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>利用对象，遍历需要去重的数组，如果对象中key没有数组的元素，就添加到对象中，并且新创一个数组，push到新数组中，其实可以不用创建新数组来接收去重后的数组，直接可以用<span class="title class_">Object</span>.<span class="title function_">values</span>(obj) 直接得到去重后的数组</span><br><span class="line"><span class="number">2.</span> 利用<span class="keyword">new</span> <span class="title class_">Set</span>()  ：利用<span class="title class_">Set</span>类型数据无重复项：<span class="keyword">new</span> 一个 <span class="title class_">Set</span>，参数为需要去重的数组，<span class="title class_">Set</span> 会自动删除重复的元素，再将 <span class="title class_">Set</span> 转为数组返回</span><br><span class="line"><span class="number">3.</span>利用 filter + indexOf  原理就是 indexOf 会返回最先找到的数字的索引   <span class="keyword">return</span>  index === arr.<span class="title function_">indexOf</span>(el)</span><br><span class="line"><span class="number">4.</span>reduce +includes去重：这个方法就是利用reduce遍历和传入一个空数组作为去重后的新数组，然后内部判断新数组中是否存在当前遍历的元素，不存在就插入到新数组中</span><br><span class="line"></span><br><span class="line">在数据低于<span class="number">10000</span>条的时候没有明显的差别，高于<span class="number">10000</span>条，第一种和第二种的时间消耗最少，后面三种时间消耗依次增加，由于第一种内存空间消耗比较多，且现在很多项目不再考虑低版本浏览器的兼容性问题，所以建议使用第二种去重方法，简洁方便。</span><br></pre></td></tr></table></figure>

<h4 id="68-说一下js-变量提升"><a href="#68-说一下js-变量提升" class="headerlink" title="68.说一下js 变量提升"></a>68.说一下js 变量提升</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">js执行一段代码，变量提升是指<span class="variable constant_">JS</span>的变量和函数声明会在代码编译期，提升到代码的最前面。 变量提升成立的前提是使用<span class="title class_">Var</span>关键字进行声明的变量，并且变量提升的时候只有声明被提升，赋值并不会被提升，同时函数的声明提升会比变量的提升优先。 变量提升的结果，可以在变量初始化之前访问该变量，返回的是<span class="literal">undefined</span>。在函数声明前可以调用该函数。 加分回答 使用<span class="keyword">let</span>和<span class="keyword">const</span>声明的变量是创建提升，形成暂时性死区，在初始化之前访问<span class="keyword">let</span>和<span class="keyword">const</span>创建的变量会报错</span><br></pre></td></tr></table></figure>

<h4 id="69-map和forEach的区别"><a href="#69-map和forEach的区别" class="headerlink" title="69.map和forEach的区别"></a>69.map和forEach的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>map 不会改变原数组，返回一个新数组，map的处理速度比forEach快，由于可以返回一个新数组，可以链接调用其他数组方法</span><br><span class="line"><span class="number">2.</span>forEach 默认无返回值，返回值是<span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="70-说一下fetch-请求方式？"><a href="#70-说一下fetch-请求方式？" class="headerlink" title="70.说一下fetch 请求方式？"></a>70.说一下fetch 请求方式？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> fetch是一种<span class="variable constant_">HTTP</span>数据请求的方式，是<span class="title class_">XMLHttpRequest</span>的一种替代方案。、头部信息、请求信息、响应信息等均分布到不同的对象,<span class="title class_">Fetch</span>函数就是原生js，没有使用<span class="title class_">XMLHttpRequest</span>对象。<span class="title function_">fetch</span>()方法返回一个<span class="title class_">Promise</span>解析<span class="title class_">Response</span>来自<span class="title class_">Request</span>显示状态（成功与否）的方法。</span><br><span class="line"> <span class="title class_">XMLHttpRequest</span>的问题 -所有的功能全部集中在一个对象上, 容易书写出混乱而且不容易维护的代码 </span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com/movies.json&#x27;</span>)	</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data));</span><br></pre></td></tr></table></figure>

<h4 id="80-说一下js数据类型的隐式转换呢"><a href="#80-说一下js数据类型的隐式转换呢" class="headerlink" title="80.说一下js数据类型的隐式转换呢"></a>80.说一下js数据类型的隐式转换呢</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 当运算符是/ *-都会隐式转化为number数据类型 ，如果 +str  则str也会隐式转换为number， 如果 + 操作符的两侧没有字符串，则也会隐式转化number ，如果两侧有一个字符串，则会执行字符串相连的操作</span><br><span class="line"><span class="number">2.</span> == 会隐式转化数据类型 ，js尽量把操作符两边的值转化为number</span><br><span class="line"><span class="number">3.</span> 对于 &lt; 和 &gt; ,  两种情况： <span class="number">3.1</span> . 第一种:如果操作符的两侧都是字符串，则会比较字母表的顺序  <span class="number">3.2</span>.第二种:其他情况都是转为数字再比较</span><br><span class="line"></span><br><span class="line"><span class="title class_">ToPrimitive</span>方法，这是 <span class="title class_">JavaScript</span> 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@obj</span> 需要转换的对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@type</span> 期望的结果类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">ToPrimitive</span>(obj,type)</span><br><span class="line"><span class="number">1.</span>当type为number 时，</span><br><span class="line">首先会调用 obj.<span class="title function_">valueOf</span>() 如果为基本数据类型，则返回，反之调用 obj.<span class="title function_">toString</span>()</span><br><span class="line"><span class="number">2.</span>当type为string时规则如下：</span><br><span class="line">调用obj的toString方法，如果为原始值，则返回，否则下一步；</span><br><span class="line">调用obj的valueOf方法，后续同上；</span><br><span class="line">可以看出两者的主要区别在于调用toString和valueOf的先后顺序。默认情况下：</span><br><span class="line">如果对象为 <span class="title class_">Date</span> 对象，则type默认为string；</span><br><span class="line">其他情况下，type默认为number。</span><br><span class="line">总结上面的规则，对于 <span class="title class_">Date</span> 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">objToNumber</span> = value =&gt; <span class="title class_">Number</span>(value.<span class="title function_">valueOf</span>().<span class="title function_">toString</span>())</span><br><span class="line"><span class="title function_">objToNumber</span>([]) ===&gt; <span class="number">0</span>    <span class="number">1.</span><span class="title class_">Number</span>( [].<span class="title function_">valueOf</span>().<span class="title function_">toString</span>())</span><br><span class="line"><span class="title function_">objToNumber</span>(&#123;&#125;) ===&gt; <span class="title class_">NaN</span></span><br></pre></td></tr></table></figure>

<h4 id="81-并发与并行的区别？"><a href="#81-并发与并行的区别？" class="headerlink" title="81.并发与并行的区别？"></a>81.并发与并行的区别？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</span><br><span class="line">并行是微观概念，假设 <span class="variable constant_">CPU</span> 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</span><br></pre></td></tr></table></figure>

<h4 id="82-多维数组降维的方法"><a href="#82-多维数组降维的方法" class="headerlink" title="82.多维数组降维的方法"></a>82.多维数组降维的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,[<span class="number">3</span>,<span class="number">4</span>,[<span class="number">5</span>]]]</span><br><span class="line">方法<span class="number">1.</span> 数组字符串化</span><br><span class="line"><span class="number">1.</span> <span class="keyword">const</span> str = arr.<span class="title function_">toString</span>() <span class="comment">// &#x27;1 3 4 5&#x27;</span></span><br><span class="line">   <span class="keyword">const</span> newArr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">方法二. flat方法</span><br><span class="line"><span class="number">2.</span><span class="keyword">const</span> newArr = arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)   参数是扁平多少层数组，当参数是 <span class="title class_">Infinity</span> 时，扁平为一维数组</span><br><span class="line">方法三. 递归</span><br><span class="line"><span class="number">3.</span> <span class="keyword">const</span> newArr = [] </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> ()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> arr)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[k] <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">        <span class="title function_">fn</span>(arr[k])</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      newArr.<span class="title function_">push</span>(arr[k])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(arr)</span><br></pre></td></tr></table></figure>

<h4 id="83-如何合并对个数组，对象？"><a href="#83-如何合并对个数组，对象？" class="headerlink" title="83.如何合并对个数组，对象？"></a>83.如何合并对个数组，对象？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并多个对象</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">&quot;嘻嘻&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="number">1.</span>循环</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> obj1)&#123;</span><br><span class="line">obj[k]=obj1[k]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> obj2)&#123;</span><br><span class="line">obj[k]=obj2[k]</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>扩展运算符</span><br><span class="line"><span class="keyword">const</span> obj = &#123;...obj1 , ...obj2 &#125;</span><br><span class="line"><span class="number">3.</span><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,obj1,obj2)</span><br><span class="line"><span class="comment">//多个数组的合并</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="number">1.</span>扩展运算符</span><br><span class="line"><span class="keyword">const</span> arr = [...arr1,...arr2]</span><br><span class="line"><span class="number">2.</span>数组的concat方法</span><br><span class="line"><span class="keyword">const</span> arr = arr.<span class="title function_">concat</span>(arr1,arr2)</span><br><span class="line"><span class="number">3.</span>循环</span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line">arr1.<span class="title function_">forEach</span>(<span class="function"><span class="params">el</span>=&gt;</span>arr.<span class="title function_">push</span>(el))</span><br><span class="line">arr2.<span class="title function_">forEach</span>(<span class="function"><span class="params">el</span>=&gt;</span>arr.<span class="title function_">push</span>(el)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="84-知道lodash吗？它有哪些常见的API-？"><a href="#84-知道lodash吗？它有哪些常见的API-？" class="headerlink" title="84.知道lodash吗？它有哪些常见的API ？"></a>84.知道lodash吗？它有哪些常见的API ？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Lodash</span>是一个一致性、模块化、高性能的 <span class="title class_">JavaScript</span> 实用工具库。</span><br><span class="line">_.<span class="property">cloneDeep</span> 深度拷贝</span><br><span class="line">_.<span class="property">reject</span> 根据条件去除某个元素。</span><br><span class="line">_.<span class="title function_">drop</span>(array, [n=<span class="number">1</span>] ) 作用：将 array 中的前 n 个元素去掉，然后返回剩余的部分.</span><br></pre></td></tr></table></figure>

<h4 id="85-知道symbol-吗？"><a href="#85-知道symbol-吗？" class="headerlink" title="85.知道symbol 吗？"></a>85.知道symbol 吗？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ES6</span> 引入新的原始数据类型<span class="title class_">Symbol</span>，表示独一无二的值 ,用途，一般给对象添加属性的时候，用<span class="title class_">Symbol</span>返回一个独一无二的属性名</span><br></pre></td></tr></table></figure>

<h4 id="86-请描述一下ES6中的class类"><a href="#86-请描述一下ES6中的class类" class="headerlink" title="86.请描述一下ES6中的class类?"></a>86.请描述一下ES6中的class类?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">es6中的<span class="keyword">class</span>可以把它看成是es5中构造函数的语法糖，它简化了构造函数的写法， 类的共有属性放到</span><br><span class="line">constructor 里面</span><br><span class="line"><span class="number">1.</span> 通过<span class="keyword">class</span> 关键字创建类, 类名我们还是习惯性定义首字母大写</span><br><span class="line"><span class="number">2.</span> 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</span><br><span class="line"><span class="number">3.</span> constructor 函数 只要 <span class="keyword">new</span> 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自</span><br><span class="line">动生成这个函数</span><br><span class="line"><span class="number">4.</span> 多个函数方法之间不需要添加逗号分隔</span><br><span class="line"><span class="number">5.</span> 生成实例 <span class="keyword">new</span> 不能省略</span><br><span class="line"><span class="number">6.</span> 语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加<span class="keyword">function</span></span><br><span class="line"><span class="number">1.</span> 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的</span><br><span class="line"><span class="number">2.</span> 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近</span><br><span class="line">原则)</span><br><span class="line"><span class="number">3.</span> 如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用<span class="variable language_">super</span> 调用 父类的构造函</span><br><span class="line">数,<span class="variable language_">super</span> 必须在子类<span class="variable language_">this</span>之前调用</span><br><span class="line"><span class="number">7.</span> 时刻注意<span class="variable language_">this</span>的指向问题,类里面的共有的属性和方法一定要加<span class="variable language_">this</span>使用.</span><br><span class="line"><span class="number">1.</span> constructor中的<span class="variable language_">this</span>指向的是<span class="keyword">new</span>出来的实例对象</span><br><span class="line"><span class="number">2.</span> 自定义的方法,一般也指向的<span class="keyword">new</span>出来的实例对象</span><br><span class="line"><span class="number">3.</span> 绑定事件之后<span class="variable language_">this</span>指向的就是触发事件的事件源</span><br><span class="line"><span class="number">4.</span> 在 <span class="title class_">ES6</span> 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</span><br></pre></td></tr></table></figure>

<h4 id="87-cookie和session-的区别"><a href="#87-cookie和session-的区别" class="headerlink" title="87.cookie和session 的区别"></a>87.cookie和session 的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、cookie数据存放在客户的浏览器上，session数据放在服务器上。</span><br><span class="line"><span class="number">2</span>、cookie不是很安全，别人可以分析存放在本地的<span class="variable constant_">COOKIE</span>并进行<span class="variable constant_">COOKIE</span>欺骗</span><br><span class="line">考虑到安全应当使用session。</span><br><span class="line"><span class="number">3</span>、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</span><br><span class="line">考虑到减轻服务器性能方面，应当使用<span class="variable constant_">COOKIE</span>。</span><br><span class="line"><span class="number">4</span>、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存<span class="number">20</span>个cookie。</span><br><span class="line"><span class="number">5</span>、所以个人建议：</span><br><span class="line">将登陆信息等重要信息存放为<span class="variable constant_">SESSION</span></span><br><span class="line">其他信息如果需要保留，可以放在<span class="variable constant_">COOKIE</span>中</span><br></pre></td></tr></table></figure>

<h4 id="88-如何获取数组中最后一个元素"><a href="#88-如何获取数组中最后一个元素" class="headerlink" title="88.如何获取数组中最后一个元素"></a>88.如何获取数组中最后一个元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,......<span class="number">9999</span>]</span><br><span class="line"><span class="number">1.</span> arr[arr.<span class="property">length</span>-<span class="number">1</span>]</span><br><span class="line"><span class="number">2.</span> <span class="keyword">const</span> res = arr.<span class="title function_">pop</span>() <span class="comment">//通过pop是删除最后一个元素，且会返回最后一个元素，res就是我们想要的到的数据</span></span><br><span class="line"><span class="comment">//如果只是不仅仅获取数组最后一个数据，而且最后一个数据还有用的话，我们就需要把原数组深拷贝一份</span></span><br><span class="line"><span class="number">3.</span>arr.<span class="title function_">slice</span>(-<span class="number">1</span>) <span class="comment">//代表从数组的最后一个元素截取，当不传第二个方法时，表示一直截取到数组的末尾，返回一个新数组，而这个新数组就包含了我们想要取的数组的最后一个元素了</span></span><br><span class="line"><span class="number">4.</span>arr.<span class="title function_">at</span>(-<span class="number">1</span>) 返回传入得索引值的元素，如果是-<span class="number">1</span>，则会返回最后一个元素</span><br></pre></td></tr></table></figure>

<h4 id="89-说一下echarts使用的基本步骤"><a href="#89-说一下echarts使用的基本步骤" class="headerlink" title="89.说一下echarts使用的基本步骤"></a>89.说一下echarts使用的基本步骤</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 下载并引入echarts 文件</span></span><br><span class="line"><span class="comment">// 2. 为 echarts 准备一个定义了宽高的 DOM</span></span><br><span class="line"><span class="comment">// 3. 基于准备好的DOM， 初始化echarts 实例</span></span><br><span class="line"><span class="comment">// 4. 指定图表的配置项和数据</span></span><br><span class="line"><span class="comment">// 5. 将配置项设置给echarts实例对象 （通过setOption）</span></span><br><span class="line"></span><br><span class="line">具体步骤 </span><br><span class="line"><span class="number">1.</span>&lt;!-- <span class="number">1.</span> 引入echarts --&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/echarts.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="number">2.</span>&lt;!-- <span class="number">2.</span> 准备一个定义了宽高的<span class="variable constant_">DOM</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;echart-box&quot;</span> <span class="attr">id</span>=<span class="string">&quot;echart-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="number">3.</span><span class="comment">// 3. 初始化echarts实例</span></span><br><span class="line"><span class="keyword">const</span> myChart = echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.echart-box&#x27;</span>))</span><br><span class="line"><span class="number">4.</span><span class="comment">// 4. 指定图表的配置项和数据</span></span><br><span class="line"><span class="keyword">const</span> option = &#123;</span><br><span class="line">  <span class="attr">title</span>: &#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;ECharts 入门示例&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">tooltip</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">legend</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;销量&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;衬衫&#x27;</span>, <span class="string">&#x27;羊毛衫&#x27;</span>, <span class="string">&#x27;雪纺衫&#x27;</span>, <span class="string">&#x27;裤子&#x27;</span>, <span class="string">&#x27;高跟鞋&#x27;</span>, <span class="string">&#x27;袜子&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;销量&#x27;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: [<span class="number">5</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">5.</span><span class="comment">// 5. 使用刚指定的配置项和数据显示图表挂载到echarts实例上。</span></span><br><span class="line">myChart.<span class="title function_">setOption</span>(option);</span><br><span class="line"><span class="number">6.</span><span class="comment">//echarts图表的适配</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      myChart.<span class="title function_">resize</span>() &#125;  <span class="comment">//echarts实例上有一个方法能实现适配，resize</span></span><br></pre></td></tr></table></figure>

<h4 id="90-为什么会有Bigint提案"><a href="#90-为什么会有Bigint提案" class="headerlink" title="90.为什么会有Bigint提案"></a>90.为什么会有Bigint提案</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JavaScript</span>中<span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>表示最大安全数字，计算结果是<span class="number">9007199254740991</span>，当进行运算时即在这个数范围内不会出现精度丢失（小数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了<span class="title class_">BigInt</span>来解决此问题。</span><br><span class="line"><span class="title class_">BigInt</span> 可以表示任意大的整数</span><br><span class="line">可以用在一个整数字面量后面加 n 的方式定义一个 <span class="title class_">BigInt</span> ，如：<span class="number">10n</span>，或者调用函数 <span class="title class_">BigInt</span>()（但不包含 <span class="keyword">new</span> 运算符）并传递一个整数值或字符串值。</span><br><span class="line">不能和任何 <span class="title class_">Number</span> 实例混合运算，两者必须转换成同一种类型。</span><br><span class="line">当使用 <span class="title class_">BigInt</span> 时，带小数的运算会被取整。</span><br><span class="line"><span class="keyword">const</span> expected = <span class="number">4n</span> / <span class="number">2n</span>;</span><br><span class="line"><span class="comment">// ↪ 2n</span></span><br><span class="line"><span class="keyword">const</span> rounded = <span class="number">5n</span> / <span class="number">2n</span>;</span><br><span class="line"><span class="comment">// ↪ 2n, not 2.5n</span></span><br></pre></td></tr></table></figure>

<h4 id="91-JavaScript脚本延迟加载的方式有哪些？"><a href="#91-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="91.JavaScript脚本延迟加载的方式有哪些？"></a>91.JavaScript脚本延迟加载的方式有哪些？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> **defer 属性：**给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class="line"><span class="number">2.</span> **<span class="keyword">async</span> 属性：**给 js 脚本添加 <span class="keyword">async</span> 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 <span class="keyword">async</span> 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class="line"><span class="number">3.</span> **动态创建 <span class="variable constant_">DOM</span> 方式：**动态创建 <span class="variable constant_">DOM</span> 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br><span class="line"><span class="number">4.</span>**使用 <span class="built_in">setTimeout</span> 延迟方法：**设置一个定时器来延迟加载js脚本文件</span><br><span class="line"><span class="number">5.</span>**让 <span class="variable constant_">JS</span> 最后加载：**将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br></pre></td></tr></table></figure>

<h4 id="92-什么是尾调用，使用尾调用有什么好处？"><a href="#92-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="92.什么是尾调用，使用尾调用有什么好处？"></a>92.什么是尾调用，使用尾调用有什么好处？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 <span class="title class_">ES6</span> 的尾调用优化只在严格模式下开启，正常模式是无效的</span><br><span class="line"><span class="number">2.</span>尾递归指的是函数在最后一步自己调用自己，好处是，只会创建一个当前函数执行上下文，不会有栈溺出的问题</span><br></pre></td></tr></table></figure>

<h4 id="93-ES6-Module和CommonJS模块的区别"><a href="#93-ES6-Module和CommonJS模块的区别" class="headerlink" title="93.ES6 Module和CommonJS模块的区别"></a>93.ES6 Module和CommonJS模块的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">CommonJs</span></span><br><span class="line"><span class="number">1.</span><span class="variable language_">module</span>.<span class="property">exports</span>导出变量及函数，也可以导出任意类型的值</span><br><span class="line"><span class="number">2.</span><span class="title class_">CommonJs</span>中使用<span class="built_in">require</span>语法可以导入，导入的值是一个对象 如果想要单个的值，可以通过解构对象来获取。</span><br><span class="line"><span class="number">3.</span><span class="title class_">CommonJs</span>支持动态导入，什么意思呢，就是可以在语句中，使用<span class="built_in">require</span>语法</span><br><span class="line"><span class="keyword">let</span> lists = [<span class="string">&quot;./index.js&quot;</span>, <span class="string">&quot;./config.js&quot;</span>]</span><br><span class="line">lists.<span class="title function_">forEach</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> <span class="built_in">require</span>(url)) <span class="comment">// 动态导入</span></span><br><span class="line"><span class="keyword">if</span> (lists.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="built_in">require</span>(lists[<span class="number">0</span>]) <span class="comment">// 动态导入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.</span><span class="title class_">CommonJs</span>导入的值是拷贝的，所以可以修改拷贝值，但这会引起变量污染，一不小心就重名</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    num,</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">       ++ num </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; num, add &#125; = <span class="built_in">require</span>(<span class="string">&quot;./index.js&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">add</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 0</span></span><br><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="title class_">Es</span> <span class="title class_">Module</span> 基本语法</span><br><span class="line"><span class="number">1.</span>es <span class="variable language_">module</span> 的导出分为两种，默认导出，和按需导出， 默认导出是，<span class="keyword">export</span> <span class="keyword">default</span>  使用默认导出的值时，<span class="keyword">import</span> 变量名 <span class="keyword">from</span> <span class="string">&#x27;路径&#x27;</span> ，按需导出，直接在需要导出的变量前面加上 <span class="keyword">export</span>，导入的时候，需要加大括号 <span class="keyword">import</span> &#123;变量名&#125; <span class="keyword">from</span> <span class="string">&#x27;路径&#x27;</span></span><br><span class="line"><span class="number">2.</span>如果导出里面全是单个导出，我们可以 用 <span class="keyword">import</span> * <span class="keyword">as</span> all  <span class="keyword">from</span> <span class="string">&#x27;路径&#x27;</span> 全部导出， 这时，all就是我们导出变量的一个集合</span><br><span class="line"><span class="number">3.</span>混合导入，则该文件内用到混合导入，<span class="keyword">import</span>语句必须先是默认导出，后面再是单个导出，顺序一定要正确否则报错。</span><br><span class="line"><span class="number">4.</span><span class="keyword">export</span>导出的值是值的引用，并且内部有映射关系，这是<span class="keyword">export</span>关键字的作用。而且导入的值，不能进行修改也就是只读状态</span><br><span class="line"><span class="number">5.</span>es <span class="variable language_">module</span> 是静态的  就是<span class="title class_">Es</span> <span class="title class_">Module</span>语句<span class="string">``</span><span class="keyword">import</span>只能声明在该文件的最顶部，不能动态加载语句，<span class="title class_">Es</span> <span class="title class_">Module</span><span class="string">`语句运行在代码编译时</span></span><br><span class="line"><span class="string">共同点： CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</span></span><br></pre></td></tr></table></figure>

<h4 id="94-介绍一下-JS-中-setTimeout-的运行机制？"><a href="#94-介绍一下-JS-中-setTimeout-的运行机制？" class="headerlink" title="94.介绍一下 JS 中 setTimeout 的运行机制？"></a>94.介绍一下 JS 中 setTimeout 的运行机制？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 <span class="title class_">JavaScript</span> 中，<span class="built_in">setTimeout</span>() 方法被用于在指定的时间间隔后执行一个指定的代码块。它接受两个参数：第一个参数是需要执行的代码块，第二个参数是代码块的延迟时间（以毫秒为单位）。<span class="built_in">setTimeout</span>() 方法执行完毕后，代码块将被推入 <span class="title class_">JavaScript</span> 的执行队列中，等待 <span class="title class_">JavaScript</span> 引擎在一段时间后执行。</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>() 方法具有异步的特性，因此即使 <span class="built_in">setTimeout</span>() 方法指定了一个很短的时间，它也不会在调用代码之后立即执行。相反，它会将代码块放在事件队列的末尾，直到事件队列中没有任何待处理的任务，才会执行。因此，当代码块执行时，当前执行的上下文（也称为堆栈）已经被清空。</span><br><span class="line"></span><br><span class="line">如果 <span class="built_in">setTimeout</span>() 方法在代码块执行之前被清除或者代码块执行时间过长，那么代码块将会在 <span class="title class_">JavaScript</span> 引擎空闲时尽快被执行。因此，<span class="built_in">setTimeout</span>() 方法不是一个精确的时间控制器，而是一个粗略的时间控制器。如果需要更精确的时间控制器，可以考虑使用 <span class="title function_">requestAnimationFrame</span>() 或 <span class="title class_">Web</span> <span class="title class_">Workers</span>。</span><br></pre></td></tr></table></figure>

<h4 id="95-JS-如何顺序执行-10-个异步任务？"><a href="#95-JS-如何顺序执行-10-个异步任务？" class="headerlink" title="95.JS 如何顺序执行 10 个异步任务？"></a>95.JS 如何顺序执行 10 个异步任务？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="title class_">Promise</span> 中的.<span class="property">then</span>的链式调用，在上一个异步任务执行完之后再调用<span class="title function_">resolve</span>()，这时下一个.<span class="property">then</span>才会执行</span><br><span class="line"><span class="number">2.</span><span class="keyword">async</span> <span class="keyword">await</span> </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">runAsyncTasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">asyncTask1</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">asyncTask2</span>();</span><br><span class="line">  <span class="comment">// 执行完异步任务1和异步任务2后的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">runAsyncTasks</span>();</span><br><span class="line"><span class="number">3.</span>生成器的方式 <span class="comment">//不知道是啥任务，反正在微任务和宏任务之后(setTimeout的时间是0的情况)</span></span><br><span class="line">生成器就是能返回一个迭代器的函数，它也是一个函数，对比普通的函数，多了一个*，在它的函数体内可以使用<span class="keyword">yield</span>关键字,函数会在每个<span class="keyword">yield</span>后暂停，等待，直到这个生成的对象，调用下一个<span class="title function_">next</span>(),每调用一次next会往下执行一次yieId，然后暂停。</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">yield</span> <span class="title function_">fn1</span>(<span class="string">&#x27;开始&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">yield</span> <span class="title function_">fn2</span>(res1)</span><br><span class="line">    <span class="keyword">const</span> res3 = <span class="keyword">yield</span> <span class="title function_">fn3</span>(res2)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res3, <span class="string">&#x27;全部执行完毕&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task = <span class="title function_">main</span>()</span><br><span class="line">task.<span class="title function_">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn1执行&#x27;</span>, data)</span><br><span class="line">        task.<span class="title function_">next</span>(<span class="string">&#x27;fn1执行完毕&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2执行&#x27;</span>, data)</span><br><span class="line">        task.<span class="title function_">next</span>(<span class="string">&#x27;fn2执行完毕&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn3执行&#x27;</span>, data)</span><br><span class="line">        task.<span class="title function_">next</span>(<span class="string">&#x27;fn3执行完毕&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是最开始同步执行的&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="96-Map-和-WeakMap-的区别"><a href="#96-Map-和-WeakMap-的区别" class="headerlink" title="96.Map 和 WeakMap 的区别"></a>96.Map 和 WeakMap 的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Map</span> 的键可以是任意类型，<span class="title class_">WeakMap</span> 只接受对象作为键（<span class="literal">null</span>除外），不接受其他类型的值作为键</span><br><span class="line"><span class="title class_">Map</span> 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键； <span class="title class_">WeakMap</span> 的键是弱引用，键所指向的对象可以被垃圾回收，此时键是无效的</span><br><span class="line"><span class="title class_">Map</span> 可以被遍历， <span class="title class_">WeakMap</span> 不能被遍历</span><br></pre></td></tr></table></figure>

<h4 id="97-typeof不能判断数组，如何加一个条件达到我们判断的要求"><a href="#97-typeof不能判断数组，如何加一个条件达到我们判断的要求" class="headerlink" title="97.typeof不能判断数组，如何加一个条件达到我们判断的要求"></a>97.typeof不能判断数组，如何加一个条件达到我们判断的要求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>判断是否有数组的方法</span><br></pre></td></tr></table></figure>



<h3 id="二-CSS面试题"><a href="#二-CSS面试题" class="headerlink" title="二.CSS面试题"></a>二.CSS面试题</h3><h4 id="1-清除浮动的方式"><a href="#1-清除浮动的方式" class="headerlink" title="1.清除浮动的方式"></a>1.清除浮动的方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">浮动的作用： <span class="number">1.</span> 设置浮动的图片，可以实现文字环绕图片， <span class="number">2.</span>设置了浮动的块级元素可以排列在同一行， <span class="number">3.</span> 设置了浮动的行内元素可以设置宽高 缺陷：使盒子脱离文档流，如果父级盒子没有设置高度，需要被子盒子撑开，那么这时候父级盒子的高度就塌陷了，同时也会造成父级盒子后面的兄弟盒子布局受到影响。如果浮动元素后面还有其他兄弟元素，其他兄弟元素的布局也会受到影响</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>额外标签法 ：在最后一个浮动标签后，新加一个标签，给其设置clear：both；）（不推荐）</span><br><span class="line"><span class="number">2.</span>父级添加overflow属性（父元素添加<span class="attr">overflow</span>:hidden）（不推荐） <span class="comment">//触发BFC</span></span><br><span class="line"><span class="number">3.</span>使用after伪元素清除浮动（推荐使用）</span><br><span class="line"><span class="number">4.</span>使用before和after双伪元素清除浮动</span><br><span class="line"><span class="number">5.</span>让父元素也浮动</span><br><span class="line">缺点：影响整体页面布局，若父元素也有父元素呢？总不能一直浮动到body吧</span><br><span class="line"><span class="number">6.</span>触发<span class="variable constant_">BFC</span>， 只要样式或方法触发了<span class="variable constant_">BFC</span>就可以防止高度塌陷.</span><br><span class="line"></span><br><span class="line">伪元素清除浮动：不会新增标签，不会有其他影响，是当下清除浮动最流行的方法 -<span class="string">`overflow：hidden`</span>：不会新增标签，但是如果父级元素有定位元素超出父级，超出部分会隐藏，在不涉及父级元素有超出内容的情况，overflow：hidden比较常用，毕竟写法方便简洁 -标签插入法：清除浮动的语法加在新增标签上，由于新增标签会造成不必要的渲染，所以这种方法目前不建议使用</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">BFC</span>的方式都能清除浮动，但是常使用的清除浮动的<span class="variable constant_">BFC</span>方式只有<span class="string">`overflow:hidden`</span>,原因是使用float或者position方式清除浮动，虽然父级盒子内部浮动被清除了，但是父级本身又脱离文档流了，会对父级后面的兄弟盒子的布局造成影响。如果设置父级为<span class="string">`display:flex`</span>，内部的浮动就会失效。所以通常只是用<span class="string">`overflow: hidden`</span>清除浮动</span><br></pre></td></tr></table></figure>

<h4 id="2-说一下什么是重绘和回流-回排"><a href="#2-说一下什么是重绘和回流-回排" class="headerlink" title="2.说一下什么是重绘和回流(回排)"></a>2.说一下什么是重绘和回流(回排)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">重绘： 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 触发：</span><br><span class="line">                                            改变元素的color、background、box-shadow等属性</span><br><span class="line">回流：当<span class="variable constant_">DOM</span>的变化影响了元素的几何信息(<span class="variable constant_">DOM</span>对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排</span><br><span class="line">触发：添加或者删除可见的<span class="variable constant_">DOM</span>元素，元素尺寸改变——边距、填充、边框、宽度和高度</span><br><span class="line"><span class="comment">// 重绘不一定会引起回流，但回流一定会引起重绘</span></span><br><span class="line"><span class="comment">//浏览器是怎么优化回流的</span></span><br><span class="line">由于每次重排都会造成浏览器的计算属性浪费，因此，浏览器会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。</span><br><span class="line">当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的 offsetTop 等方法都会返回最新的数据</span><br><span class="line">因此浏览器不得不清空队列，触发回流重绘来返回正确的值</span><br><span class="line"><span class="comment">//最小发生重绘和回流</span></span><br><span class="line"><span class="number">1.</span>如果要移动盒子的话，尽量使用tranfrom的translet,不要使用定位，因为前者还是占的是移动前的空间，不会触发浏览器的回流</span><br><span class="line"><span class="number">2.</span>如果要频繁操作一个会影响布局的盒子，则把盒子设置定位，脱离文档流，操作完的时候在回归文档流，这样就只会触发两次回流，或者先隐藏 <span class="attr">display</span>:none</span><br><span class="line"><span class="number">3.</span>css样式尽量批量修改样式，避免使用css表达式</span><br></pre></td></tr></table></figure>

<h4 id="3-说说什么是外边距塌陷"><a href="#3-说说什么是外边距塌陷" class="headerlink" title="3.说说什么是外边距塌陷"></a>3.说说什么是外边距塌陷</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">外边距塌陷也称为外边距合并，是指两个在正常流中相邻（兄弟或父子关系）的块级元素的外边距，组合在一起变成单个外边距，不过只有上下外边距才会有塌陷，左右外边距不会出现这种问题</span><br><span class="line">当外边距塌陷时，外边距之间的计算方式是怎样的？</span><br><span class="line"><span class="number">1.</span>两个都是正数，取较大的值</span><br><span class="line"><span class="number">2.</span>两个都是负数，取绝对值较大的值</span><br><span class="line"><span class="number">3.</span>一正一负，取两个值得的和</span><br><span class="line">解决方法：</span><br><span class="line"><span class="number">1.</span>创建<span class="variable constant_">BFC</span></span><br><span class="line"><span class="number">2.</span><span class="attr">display</span>: inline-block</span><br></pre></td></tr></table></figure>

<h4 id="4-如何隐藏页面元素"><a href="#4-如何隐藏页面元素" class="headerlink" title="4.如何隐藏页面元素"></a>4.如何隐藏页面元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="attr">dispaly</span>:none <span class="comment">// 不占有位置</span></span><br><span class="line"><span class="number">2.</span><span class="attr">opacity</span>:<span class="number">0</span>    <span class="comment">//占有位置</span></span><br><span class="line"><span class="number">3.</span><span class="attr">visibility</span>:hideen <span class="comment">//占有位置</span></span><br><span class="line"><span class="number">4.</span><span class="attr">transform</span>:<span class="title function_">scale</span>(<span class="number">0</span>)  <span class="comment">//不占位置</span></span><br><span class="line"><span class="number">5.</span> <span class="attr">width</span>:<span class="number">0</span> / <span class="attr">height</span>:<span class="number">0</span></span><br><span class="line"><span class="number">6.</span><span class="attr">position</span>:absoltute , <span class="attr">left</span>:-99999px /<span class="attr">right</span>:-99999px /<span class="attr">top</span>:-99999px /<span class="attr">bottom</span>:-99999px</span><br><span class="line"><span class="number">7.</span><span class="attr">transform</span>:<span class="title function_">translateX</span>(-9999px) /<span class="title function_">translateY</span>(-9999px)</span><br><span class="line"><span class="number">8.</span>clip-<span class="attr">path</span>:<span class="title function_">circle</span>(<span class="number">0</span>)</span><br><span class="line"><span class="number">9.</span> <span class="attr">height</span>: <span class="number">0</span>; <span class="attr">overflow</span>: hidden; <span class="comment">/* 不占据空间，无法点击 */</span></span><br><span class="line"><span class="number">10.</span> z-<span class="attr">index</span>:-n</span><br></pre></td></tr></table></figure>

<h4 id="5-px、rem、em、vh、vw的区别"><a href="#5-px、rem、em、vh、vw的区别" class="headerlink" title="5.px、rem、em、vh、vw的区别"></a>5.px、rem、em、vh、vw的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">px</span>:绝对长度单位，它的大小取决于屏幕的分辨率，是开发网页中常常使用的单位</span><br><span class="line">rem：相对单位，相对于html字体大小    1rem = 根标签字体大小 / 我们分的份数</span><br><span class="line">em : 相对单位，相对于父级字体大小   1em = 父级字体大小</span><br><span class="line">vh：相对于屏幕高度大小， 1vh=屏幕高度/<span class="number">100</span></span><br><span class="line">vw：相对于屏幕宽度大小， 1vw=屏幕宽度/<span class="number">100</span></span><br></pre></td></tr></table></figure>

<h4 id="6-为什么通常推荐将css-lt-link-gt-放置在head-x2F-head-gt-之间"><a href="#6-为什么通常推荐将css-lt-link-gt-放置在head-x2F-head-gt-之间" class="headerlink" title="6.为什么通常推荐将css &lt; link&gt; 放置在head  &#x2F;head&gt; 之间"></a>6.为什么通常推荐将css &lt; link&gt; 放置在head  &#x2F;head&gt; 之间</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>link标签不会阻塞html解析，如果link标签放在dom之后，会导致浏览器发生回流重绘，这个开销是非常大的，所以我们一般把link标签放在html文档开头（head）中</span><br><span class="line"><span class="number">2.</span>提高用户体验，如果link标签放在dom之后，加载dom出来没有样式</span><br></pre></td></tr></table></figure>

<h4 id="7-常用的meta属性"><a href="#7-常用的meta属性" class="headerlink" title="7.常用的meta属性"></a>7.常用的meta属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/（<span class="number">1</span>）charset，用来描述<span class="variable constant_">HTML</span>文档的编码类型：</span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;  <span class="comment">// 用来告知浏览器如何解码当前页面。</span></span><br><span class="line">/ （<span class="number">2</span>） keywords，页面关键词：</span><br><span class="line">&lt;meta name=<span class="string">&quot;keywords&quot;</span> content=<span class="string">&quot;&quot;</span>&gt;  <span class="comment">//SEO优化，关键字</span></span><br><span class="line"> /（<span class="number">3</span>）description，页面描述：</span><br><span class="line">&lt;meta name=<span class="string">&quot;description&quot;</span> content=<span class="string">&quot;&quot;</span>&gt; <span class="comment">//页面描述</span></span><br><span class="line"> /（<span class="number">4</span>）refresh，页面重定向和刷新：</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;refresh&quot;</span> content=<span class="string">&quot;0;url=&quot;</span> /&gt;</span><br><span class="line"> /（<span class="number">5</span>）viewport，适配移动端，可以控制视口的大小和比例：</span><br><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="8-html5新特性"><a href="#8-html5新特性" class="headerlink" title="8.html5新特性"></a>8.html5新特性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 拖拽释放</span><br><span class="line"><span class="number">2.</span> 自定义data-id</span><br><span class="line"><span class="number">3.</span> 语义化更好的标签（header，nav，footer，aside, article, section）</span><br><span class="line"><span class="number">4.</span> 视频音频标签，添加autoplay自动播放</span><br><span class="line"><span class="number">5.</span> 新增画布canvas</span><br><span class="line"><span class="number">6.</span> 地理api</span><br><span class="line"><span class="number">7.</span> 新增本地离线缓存<span class="variable language_">localStorage</span>，<span class="variable language_">sessionStorage</span></span><br><span class="line"><span class="number">8.</span> 表单控件 calendar , date , time , email , url , search , tel , file , number</span><br><span class="line"><span class="number">9.</span> 新的技术 webworker, websocket , <span class="title class_">Geolocation</span></span><br></pre></td></tr></table></figure>

<h4 id="9-css3新特性"><a href="#9-css3新特性" class="headerlink" title="9.css3新特性"></a>9.css3新特性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- 边框圆角</span><br><span class="line">- box-sizing</span><br><span class="line">- rgba颜色</span><br><span class="line">- 渐变</span><br><span class="line">- 过渡</span><br><span class="line">- 动画</span><br><span class="line">- 2D转换</span><br><span class="line">- 3D转换</span><br><span class="line">- flex布局</span><br><span class="line">- 字体图标等</span><br><span class="line">选择器:nth-<span class="keyword">of</span>-<span class="title function_">type</span>()</span><br><span class="line">阴影 文字阴影: text-<span class="attr">shadow</span>: 2px 2px 2px #<span class="number">000</span>;(水平阴影，垂直阴影，模糊距离，阴影颜色) 盒子阴影: box-<span class="attr">shadow</span>: 10px 10px 5px #<span class="number">999</span></span><br><span class="line">边框 border-<span class="attr">image</span>: <span class="title function_">url</span>(border.<span class="property">png</span>);</span><br><span class="line">背景</span><br><span class="line">文字</span><br><span class="line">渐变</span><br><span class="line"><span class="title class_">Filter</span>（滤镜）</span><br><span class="line">弹性布局、栅格布局、多列布局</span><br><span class="line">媒体查询</span><br></pre></td></tr></table></figure>

<h4 id="10-如何实现一个盒子水平垂直居中"><a href="#10-如何实现一个盒子水平垂直居中" class="headerlink" title="10.如何实现一个盒子水平垂直居中"></a>10.如何实现一个盒子水平垂直居中</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.position</span>:absolute, left:<span class="number">50%</span>,top:<span class="number">50%</span>, left:-盒子宽度一半px top:-盒子高度一半px</span><br><span class="line"><span class="number">2</span>.position:absolute, left:<span class="number">50%</span>,top:<span class="number">50%</span>, transform: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line"><span class="number">3</span><span class="selector-class">.position</span>:absolute, top:<span class="number">0</span>,left:<span class="number">0</span>,right:<span class="number">0</span>,buttom:<span class="number">0</span> ,margin:auto</span><br><span class="line"><span class="number">4</span>.display:flex       justify-content: center;  <span class="attribute">align-items</span>:center</span><br><span class="line"><span class="number">5</span>.display:grid       align-self: center;   justify-self: center;</span><br><span class="line"><span class="number">6</span><span class="selector-class">.position</span>:absolute, left:<span class="number">50%</span>,top:<span class="number">50%</span>, transform:<span class="built_in">translateX</span>(-盒子宽度的一半px)</span><br><span class="line">京东的移动端顶部京东logo，使用的是`display:flex`这种模式</span><br></pre></td></tr></table></figure>

<h4 id="11-说一下css盒模型"><a href="#11-说一下css盒模型" class="headerlink" title="11.说一下css盒模型"></a>11.说一下css盒模型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">盒模型：每个盒子都是由 内容 + padding + margin + border组成的</span><br><span class="line"><span class="number">1.</span><span class="variable constant_">IE</span> 盒模型：属性 width，height 包含 content、border 和 padding，指的是 content + padding + border </span><br><span class="line"><span class="number">2.</span><span class="variable constant_">W3C</span> 标准盒模型：属性 width ，height 只包含内容 content，不包含 border 和 padding </span><br><span class="line">注意 每个盒模型 都有margin 只是width不包含margin</span><br></pre></td></tr></table></figure>

<h4 id="12-为什么要初始化CSS样式"><a href="#12-为什么要初始化CSS样式" class="headerlink" title="12. 为什么要初始化CSS样式"></a>12. 为什么要初始化CSS样式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对<span class="variable constant_">CSS</span>初始化往往会出现浏览器之间的页面显示差异。</span><br></pre></td></tr></table></figure>

<h4 id="13-display-none与visibility：hidden的区别-？"><a href="#13-display-none与visibility：hidden的区别-？" class="headerlink" title="13. display:none与visibility：hidden的区别 ？"></a>13. display:none与visibility：hidden的区别 ？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">display：none 会让元素完全从渲染树中消失，渲染时不会占据任何空间（回流+重绘）,不可继承属性，子元素子所以隐藏了，是因为直接被移除了</span><br><span class="line">visibility：hidden 不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。（重绘），可继承属性，子元素之所以隐藏了，是因为继承了这个属性</span><br><span class="line"><span class="attr">opacity</span>:<span class="number">0</span> --- 会被子元素继承，但是不能设置子元素 <span class="attr">opacity</span>:<span class="number">0</span> 来先重新显示。</span><br><span class="line">三、事件绑定。</span><br><span class="line"><span class="attr">display</span>:none 的元素都已经不存在了，因此无法触发他绑定的事件。</span><br><span class="line"><span class="attr">visibility</span>:hidden 不会触发他上面绑定的事件。</span><br><span class="line"><span class="attr">opacity</span>:<span class="number">0</span> 元素上面绑定的事件时可以触发的。</span><br><span class="line">四、过度动画。</span><br><span class="line">transition 对于 display 是无效的。</span><br><span class="line">transition 对于 visibility 是无效的。</span><br><span class="line">transition 对于 opacity 是有效的</span><br></pre></td></tr></table></figure>

<h4 id="14-说说flex-0-1-auto-的意思"><a href="#14-说说flex-0-1-auto-的意思" class="headerlink" title="14.说说flex 0 1 auto 的意思"></a>14.说说flex 0 1 auto 的意思</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">即为：</span><br><span class="line">flex-grow：放大比例，默认值为 <span class="number">0</span> 即为不放大 ,放大容器的剩余空间</span><br><span class="line">flex-shirk：缩小比例，默认值为 <span class="number">1</span> ，当容器空间不够时，子盒子自动缩小为容器的宽度</span><br><span class="line">flex-basis：项目主轴占据的空间大小，当主轴为行时，影响的是width 主轴是列时，影响的是height，为auto是时，不影响盒子的宽度或高度，当为数字或<span class="number">0</span>%时，盒子不具有宽度或高度，当不为<span class="number">0</span>的百分比时，根据容器的width或height算子盒子的宽高</span><br><span class="line">flex：数字 即设置 flex 的默认 <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>%</span><br></pre></td></tr></table></figure>

<h4 id="15-CSS中可继承与不可继承属性有哪些"><a href="#15-CSS中可继承与不可继承属性有哪些" class="headerlink" title="15.CSS中可继承与不可继承属性有哪些"></a>15.CSS中可继承与不可继承属性有哪些</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">一、无继承性的属性</span><br><span class="line"><span class="number">1</span><span class="selector-class">.display</span></span><br><span class="line"><span class="number">2</span>.文本属性：</span><br><span class="line"><span class="attribute">vertical-align</span>：垂直文本对齐</span><br><span class="line"><span class="attribute">text-decoration</span>：规定添加到文本的装饰</span><br><span class="line"><span class="attribute">text-shadow</span>：文本阴影效果</span><br><span class="line"><span class="attribute">white-space</span>：空白符的处理</span><br><span class="line"><span class="attribute">unicode-bidi</span>：设置文本的方向</span><br><span class="line"><span class="number">3</span>.盒子模型的属性：<span class="attribute">width</span>、<span class="attribute">height</span>、<span class="attribute">margin</span>、<span class="attribute">border</span>、<span class="attribute">padding</span></span><br><span class="line"><span class="number">4</span>.背景属性：<span class="attribute">background</span>、<span class="attribute">background-color</span>、<span class="attribute">background-image</span>、<span class="attribute">background-repeat</span>、<span class="attribute">background-position</span>、<span class="attribute">background-attachment</span></span><br><span class="line"><span class="number">5</span>.定位属性：<span class="attribute">float</span>、<span class="attribute">clear</span>、<span class="attribute">position</span>、<span class="attribute">top</span>、<span class="attribute">right</span>、<span class="attribute">bottom</span>、<span class="attribute">left</span>、<span class="attribute">min-width</span>、<span class="attribute">min-height</span>、<span class="attribute">max-width</span>、<span class="attribute">max-height</span>、<span class="attribute">overflow</span>、<span class="attribute">clip</span>、<span class="attribute">z-index</span></span><br><span class="line">二、有继承性的属性</span><br><span class="line"><span class="number">1</span>.字体系列属性</span><br><span class="line"><span class="attribute">font-family</span>：字体系列</span><br><span class="line"><span class="attribute">font-weight</span>：字体的粗细</span><br><span class="line"><span class="attribute">font-size</span>：字体的大小</span><br><span class="line"><span class="attribute">font-style</span>：字体的风格</span><br><span class="line"><span class="number">2</span>.文本系列属性</span><br><span class="line"><span class="attribute">text-indent</span>：文本缩进</span><br><span class="line"><span class="attribute">text-align</span>：文本水平对齐</span><br><span class="line"><span class="attribute">line-height</span>：行高</span><br><span class="line"><span class="attribute">word-spacing</span>：单词之间的间距</span><br><span class="line"><span class="attribute">letter-spacing</span>：中文或者字母之间的间距</span><br><span class="line"><span class="attribute">text-transform</span>：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</span><br><span class="line"><span class="attribute">color</span>：文本颜色</span><br><span class="line"><span class="number">3</span>.元素可见性</span><br><span class="line"><span class="attribute">visibility</span>：控制元素显示隐藏</span><br></pre></td></tr></table></figure>

<h4 id="16-display的属性值及其作用"><a href="#16-display的属性值及其作用" class="headerlink" title="16. display的属性值及其作用"></a>16. display的属性值及其作用</h4><table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>元素不显示，并且会从文档流中移除。</td>
</tr>
<tr>
<td>block</td>
<td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。可切换显示元素</td>
</tr>
<tr>
<td>inline</td>
<td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td>
</tr>
<tr>
<td>inline-block</td>
<td>默认宽度为内容宽度，可以设置宽高，同行显示。</td>
</tr>
<tr>
<td>flex</td>
<td>将改盒子设置为弹性盒子</td>
</tr>
<tr>
<td>gird</td>
<td>网格布局</td>
</tr>
<tr>
<td>table</td>
<td>此元素会作为块级表格来显示。</td>
</tr>
<tr>
<td>list-item</td>
<td>像块类型元素一样显示，并添加样式列表标记。 像li自带的那个列表标记</td>
</tr>
</tbody></table>
<h4 id="17-link和-import的区别"><a href="#17-link和-import的区别" class="headerlink" title="17.link和@import的区别"></a>17.link和@import的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">两者都是外部引用<span class="variable constant_">CSS</span>的方式，它们的区别如下：</span><br><span class="line">       <span class="number">1.</span>link是<span class="variable constant_">XHTML</span>标签，除了加载<span class="variable constant_">CSS</span>外，还可以定义<span class="variable constant_">RSS</span>等其他事务；@<span class="keyword">import</span>属于<span class="variable constant_">CSS</span>范畴，只能加载<span class="variable constant_">CSS</span>。</span><br><span class="line">       <span class="number">2.</span>link引用<span class="variable constant_">CSS</span>时，在页面载入时同时加载；@<span class="keyword">import</span>需要页面网页完全载入以后加载。</span><br><span class="line">       <span class="number">3.</span>link是<span class="variable constant_">XHTML</span>标签，无兼容问题；@<span class="keyword">import</span>是在<span class="title class_">CSS2</span><span class="number">.1</span>提出的，低版本的浏览器不支持。</span><br><span class="line">       <span class="number">4.</span>link支持使用<span class="title class_">Javascript</span>控制<span class="variable constant_">DOM</span>去改变样式；而@<span class="keyword">import</span>不支持。</span><br></pre></td></tr></table></figure>

<h4 id="18-transition和animation的区别"><a href="#18-transition和animation的区别" class="headerlink" title="18.transition和animation的区别"></a>18.transition和animation的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="string">&#x27;transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画</span></span><br><span class="line"><span class="string">2.&#x27;</span>animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画</span><br></pre></td></tr></table></figure>

<h4 id="19-伪元素和伪类的区别和作用？"><a href="#19-伪元素和伪类的区别和作用？" class="headerlink" title="19.伪元素和伪类的区别和作用？"></a>19.伪元素和伪类的区别和作用？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪类和伪元素分别用单冒号:和双冒号::来表示。</span></span><br><span class="line"><span class="number">1.</span>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素</span><br><span class="line"><span class="number">2.</span>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素</span><br><span class="line">总结： 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。</span><br></pre></td></tr></table></figure>

<h4 id="20-margin-和-padding-的使用场景"><a href="#20-margin-和-padding-的使用场景" class="headerlink" title="20.margin 和 padding 的使用场景"></a>20.margin 和 padding 的使用场景</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</span><br><span class="line">需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</span><br></pre></td></tr></table></figure>

<h4 id="21-对line-height-的理解"><a href="#21-对line-height-的理解" class="headerlink" title="21.对line-height 的理解"></a>21.对line-height 的理解</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；</span><br><span class="line">        <span class="number">1.</span>如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</span><br><span class="line">        <span class="number">2.</span>一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</span><br><span class="line">        <span class="number">3.</span>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</span><br><span class="line">        <span class="number">4.</span>line-height 和 height 都能撑开一个高度；</span><br></pre></td></tr></table></figure>

<h4 id="22-CSS-优化和提高性能的方法有哪些？"><a href="#22-CSS-优化和提高性能的方法有哪些？" class="headerlink" title="22.CSS 优化和提高性能的方法有哪些？"></a>22.CSS 优化和提高性能的方法有哪些？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>加载性能：</span><br><span class="line">（<span class="number">1</span>）css压缩：将写好的css进行打包压缩，可以减小文件体积。</span><br><span class="line">（<span class="number">2</span>）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 <span class="attr">margin</span>:top <span class="number">0</span> bottom <span class="number">0</span>；但margin-<span class="attr">bottom</span>:bottom;margin-<span class="attr">left</span>:left;执行效率会更高。</span><br><span class="line">（<span class="number">3</span>）减少使用@<span class="keyword">import</span>，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。引起回流，浪费性能</span><br><span class="line"><span class="number">2.</span>选择器性能：</span><br><span class="line">（<span class="number">1</span>）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。<span class="variable constant_">CSS</span>选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</span><br><span class="line">（<span class="number">2</span>）如果规则拥有<span class="variable constant_">ID</span>选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</span><br><span class="line">（<span class="number">3</span>）避免使用通配规则，如*&#123;&#125;计算次数惊人，只对需要用到的元素进行选择。</span><br><span class="line">（<span class="number">4</span>）尽量少的去对标签进行选择，而是用<span class="keyword">class</span>。</span><br><span class="line">（<span class="number">5</span>）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</span><br><span class="line">（<span class="number">6</span>）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</span><br><span class="line"><span class="number">3.</span>渲染性能：</span><br><span class="line">（<span class="number">1</span>）慎重使用高性能属性：浮动、定位。</span><br><span class="line">（<span class="number">2</span>）尽量减少页面重排、重绘。</span><br><span class="line">（<span class="number">3</span>）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</span><br><span class="line">（<span class="number">4</span>）属性值为<span class="number">0</span>时，不加单位。</span><br><span class="line">（<span class="number">5</span>）属性值为浮动小数<span class="number">0.</span>**，可以省略小数点之前的<span class="number">0</span>。</span><br><span class="line">（<span class="number">6</span>）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</span><br><span class="line">（<span class="number">7</span>）不使用@<span class="keyword">import</span>前缀，它会影响css的加载速度。</span><br><span class="line">（<span class="number">8</span>）选择器优化嵌套，尽量避免层级过深。</span><br></pre></td></tr></table></figure>

<h4 id="23-单行文本，多行文本溢出隐藏"><a href="#23-单行文本，多行文本溢出隐藏" class="headerlink" title="23.单行文本，多行文本溢出隐藏"></a>23.单行文本，多行文本溢出隐藏</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.单行文本</span><br><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br><span class="line"><span class="number">2</span>.多行文本</span><br><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-line-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure>

<h4 id="24-z-index在什么时候不生效"><a href="#24-z-index在什么时候不生效" class="headerlink" title="24.z-index在什么时候不生效"></a>24.z-index在什么时候不生效</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通常 <span class="attribute">z-index</span> 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。<span class="attribute">z-index</span>值越大就越是在上层。<span class="attribute">z-index</span>元素的<span class="attribute">position</span>属性需要是relative，absolute或是fixed。</span><br><span class="line">        <span class="number">1</span>. <span class="attribute">z-index</span>属性在下列情况下会失效：</span><br><span class="line">父元素<span class="attribute">position</span>为relative时，子元素的<span class="attribute">z-index</span>失效。解决：父元素<span class="attribute">position</span>改为absolute或static；</span><br><span class="line">元素没有设置<span class="attribute">position</span>属性为非static属性。解决：设置该元素的<span class="attribute">position</span>属性为relative，absolute或是fixed中的一种；</span><br><span class="line">元素在设置<span class="attribute">z-index</span>的同时还设置了<span class="attribute">float</span>浮动。解决：<span class="attribute">float</span>去除，改为<span class="attribute">display</span>：inline-block；</span><br></pre></td></tr></table></figure>

<h4 id="25-position-属性的值有哪些及其区别"><a href="#25-position-属性的值有哪些及其区别" class="headerlink" title="25.position 属性的值有哪些及其区别"></a>25.position 属性的值有哪些及其区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//position属性取值：static(默认)、relative、absolute、fixed、inherit。</span></span><br><span class="line"><span class="comment">//float属性取值：none(默认)、left、right、inherit。</span></span><br><span class="line"><span class="comment">//display属性取值：none、inline、inline-block、block、table相关属性值、inherit。</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>固定定位 fixed： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。<span class="title class_">Fixed</span> 定 位使元素的位置与文档流无关，因此不占据空间。 <span class="title class_">Fixed</span> 定位的元素和其他元素重叠。（脱离文档流）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>相对定位 relative： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>绝对定位 absolute： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。（脱离文档流）</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>粘性定位 sticky： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（<span class="variable constant_">BFC</span>）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>默认定位 <span class="title class_">Static</span>： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 <span class="attr">inherit</span>: 规定应该从父元素继承 position 属性的值</span><br></pre></td></tr></table></figure>

<h4 id="26-flex布局"><a href="#26-flex布局" class="headerlink" title="26.flex布局"></a>26.flex布局</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Flex</span> 是 <span class="title class_">Flexible</span> <span class="title class_">Box</span> 的缩写，意为<span class="string">&quot;弹性布局&quot;</span>,用来为盒状模型提供最大的灵活性。指定容器 <span class="attr">display</span>: flex 即可。 简单的分为容器属性和元素属性。</span><br><span class="line"><span class="number">1.</span>容器的属性：</span><br><span class="line">flex-direction：决定主轴的方向（即子 item 的排列方法）flex-<span class="attr">direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line"></span><br><span class="line">flex-wrap：决定换行规则 flex-<span class="attr">wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line"></span><br><span class="line">flex-flow： .<span class="property">box</span> &#123; flex-<span class="attr">flow</span>: || ; &#125;</span><br><span class="line"></span><br><span class="line">justify-content：对其方式，水平主轴对齐方式</span><br><span class="line"></span><br><span class="line">align-items：对齐方式，竖直轴线方向</span><br><span class="line"></span><br><span class="line">align-content</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>项目的属性（元素的属性）：</span><br><span class="line"></span><br><span class="line">order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">flex-grow 属性：flex-grow属性定义项目的放大比例，默认为<span class="number">0</span>，即如果存在剩余空间，也不放大。</span><br><span class="line"></span><br><span class="line">flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 <span class="number">0</span>，则为不缩小</span><br><span class="line"></span><br><span class="line">flex-basis 属性：flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br><span class="line"></span><br><span class="line">flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 <span class="number">0</span> <span class="number">1</span> auto。</span><br><span class="line"></span><br><span class="line">align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖</span><br><span class="line"></span><br><span class="line">align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局</span><br></pre></td></tr></table></figure>

<h4 id="27-CSS-预处理器-Sass、Less、Stylus-的区别"><a href="#27-CSS-预处理器-Sass、Less、Stylus-的区别" class="headerlink" title="27.CSS 预处理器 Sass、Less、Stylus 的区别"></a>27.CSS 预处理器 Sass、Less、Stylus 的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">什么是<span class="variable constant_">CSS</span>预处理器?</span><br><span class="line"><span class="variable constant_">CSS</span>预处理器是一种语言用来为<span class="variable constant_">CSS</span>增加一些变成的特性，无需考虑浏览器兼容问题，例如你可以在<span class="variable constant_">CSS</span>中使用变量，简单的程序逻辑、函数等在编程语言中的一些基本技巧，可以让<span class="variable constant_">CSS</span>更加简洁，适应性更强，代码更直观等诸多好处</span><br><span class="line">基本语法区别</span><br><span class="line"><span class="title class_">Sass</span>是以.<span class="property">sass</span>为扩展名，<span class="title class_">Less</span>是以.<span class="property">less</span>为扩展名，<span class="title class_">Stylus</span>是以.<span class="property">styl</span>为扩展名</span><br><span class="line">变量的区别</span><br><span class="line"><span class="title class_">Sass</span> 变量必须是以$开头的，然后变量和值之间使用冒号（：）隔开，和css属性是一样的。 <span class="title class_">Less</span> 变量是以@开头的，其余sass都是一样的。 <span class="title class_">Stylus</span> 对变量是没有任何设定的，可以是以$开头或者任意字符，而且变量之间可以冒号，空格隔开，但是在stylus中不能用@开头</span><br><span class="line">stylus 和 sass 语法很像，严格保持缩进来规范css的， 没有分号；没有&#123;&#125;</span><br><span class="line"> <span class="number">1.</span> scss 是 sass <span class="number">3</span>新增的， <span class="variable constant_">CSS</span>的超集</span><br><span class="line"> <span class="number">2.</span> scss 和 less 都支持嵌套的语法, 都可以定义变量，混入等操作</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=<span class="string">&quot;scss&quot;</span>&gt;</span><br><span class="line"><span class="comment">// 定义一个外部的变量</span></span><br><span class="line"><span class="attr">$color</span>: skyblue;</span><br><span class="line"><span class="attr">$width</span>:300px; <span class="comment">// 变量 1</span></span><br><span class="line">.<span class="property">box</span>&#123;</span><br><span class="line">  <span class="attr">$width</span>:100px; <span class="comment">// 变量2</span></span><br><span class="line">  <span class="attr">width</span>:400px;</span><br><span class="line">  <span class="attr">height</span>: 400px;</span><br><span class="line">  <span class="attr">padding</span>: 20px;</span><br><span class="line">  background-<span class="attr">color</span>: $color;</span><br><span class="line">  .<span class="property">son1</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: $width; <span class="comment">// ==&gt; 用的是最近的那个变量</span></span><br><span class="line">    <span class="attr">height</span>: $width;</span><br><span class="line">    <span class="attr">margin</span>: 20px;</span><br><span class="line">    background-<span class="attr">color</span>: orange;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义的变量有作用域，不能在外部使用</span></span><br><span class="line"><span class="comment">// .box2&#123;</span></span><br><span class="line"><span class="comment">//   width:$width;</span></span><br><span class="line"><span class="comment">//   height: 200px;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scss 可以混入，相当于是定义一个函数</span></span><br><span class="line"><span class="comment">// ==&gt; 把一些公共的代码抽离出来，还可以传参数</span></span><br><span class="line"><span class="comment">// @mixin  +  @inclue</span></span><br><span class="line"><span class="comment">// 1. 不带参数</span></span><br><span class="line">@mixin orangeTheme&#123;</span><br><span class="line">  background-<span class="attr">color</span>: orange;</span><br><span class="line">  <span class="attr">color</span>:orange;</span><br><span class="line">  border-<span class="attr">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 带参数</span></span><br><span class="line">@mixin <span class="title function_">theme</span>(<span class="params">$color:skyblue</span>)&#123;</span><br><span class="line">  background-<span class="attr">color</span>: $color;</span><br><span class="line">  <span class="attr">color</span>:$color;</span><br><span class="line">  border-<span class="attr">color</span>: $color;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">box2</span> &#123;</span><br><span class="line">  <span class="attr">width</span>:300px;</span><br><span class="line">  <span class="attr">height</span>: 300px;</span><br><span class="line">  <span class="attr">margin</span>: 20px;</span><br><span class="line">  @include <span class="title function_">theme</span>(purple)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<h4 id="28-说一下什么是伪类和伪元素"><a href="#28-说一下什么是伪类和伪元素" class="headerlink" title="28.说一下什么是伪类和伪元素"></a>28.说一下什么是伪类和伪元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义</span><br><span class="line">伪类---- 点击操作 ----是一个以冒号作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类。</span><br><span class="line">伪元素 ---- after、before ----用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过::before来在一个元素前添加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际不在文档树中。</span><br><span class="line"><span class="number">2.</span>区别 – 他们是否创造了新的元素</span><br><span class="line">伪类是通过在元素选择器上加入伪类改变元素状态。</span><br><span class="line">伪元素通过对元素的操作进行对元素的改变</span><br></pre></td></tr></table></figure>

<h4 id="29-说一下flex-0-1-auto"><a href="#29-说一下flex-0-1-auto" class="headerlink" title="29.说一下flex: 0 1 auto"></a>29.说一下flex: 0 1 auto</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flex-<span class="attr">grow</span>: flex-grow属性定义项目的放大比例，默认为<span class="number">0</span>，即如果存在剩余空间，也不放大。</span><br><span class="line">flex-<span class="attr">shrink</span>:flex-shrink属性定义了项目的缩小比例，默认为<span class="number">1</span>，即如果空间不足，该项目将缩小。</span><br><span class="line">flex-<span class="attr">basis</span>: flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。，优先级比width或height高</span><br><span class="line"></span><br><span class="line"><span class="attr">flex</span>:<span class="number">1</span> ;  ==&gt;</span><br><span class="line">flex-<span class="attr">grow</span>:<span class="number">1</span>;</span><br><span class="line">flex-<span class="attr">shirnk</span>:<span class="number">1</span>;</span><br><span class="line">flex-<span class="attr">basis</span>:<span class="number">0</span>%;</span><br></pre></td></tr></table></figure>

<h4 id="30-如何实现三栏布局"><a href="#30-如何实现三栏布局" class="headerlink" title="30.如何实现三栏布局"></a>30.如何实现三栏布局</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>folat 浮动</span><br><span class="line"><span class="number">2.</span>定位</span><br><span class="line"><span class="number">3.</span>flex</span><br><span class="line"><span class="number">4.</span>table</span><br><span class="line"><span class="number">5.</span>grid</span><br></pre></td></tr></table></figure>

<h4 id="31-transition有哪些属性"><a href="#31-transition有哪些属性" class="headerlink" title="31.transition有哪些属性"></a>31.transition有哪些属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>第一个属性 是要做动画的元素的属性，可以是宽，高，背景色 透明度，一般我用的是all</span><br><span class="line"><span class="number">2.</span>动画的持续事件 ，单位s</span><br><span class="line"><span class="number">3.</span>还记得有两个属性，不常用，记得还有个属性是以几秒开始动画</span><br></pre></td></tr></table></figure>

<h4 id="32-animation和transition区别"><a href="#32-animation和transition区别" class="headerlink" title="32.animation和transition区别"></a>32.<code>animation</code>和transition区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>animation是不需要手动触发，比如hover伪类选择器，自动设置属性触发</span><br><span class="line"><span class="number">2.</span>transition是需要手动触发的</span><br></pre></td></tr></table></figure>

<h4 id="33-transform的属性及应用"><a href="#33-transform的属性及应用" class="headerlink" title="33.transform的属性及应用"></a>33.transform的属性及应用</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="attribute">transform</span> :<span class="built_in">translate</span>()  移动，推荐使用，移动元素用定位的话，会引起回流，重绘，消耗性能 而translate属性不会改变元素原始位置</span><br><span class="line"><span class="number">2</span>.transform:<span class="built_in">rotate</span>()    控制元素旋转</span><br><span class="line"><span class="number">3</span>.transform:<span class="built_in">scale</span>()      控制元素缩放</span><br></pre></td></tr></table></figure>

<h4 id="34-常见的布局方法有哪些"><a href="#34-常见的布局方法有哪些" class="headerlink" title="34.常见的布局方法有哪些"></a>34.常见的布局方法有哪些</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">页面布局常用的方法有浮动、定位、flex、grid网格布局、栅格系统布局</span><br><span class="line"><span class="number">1.</span>浮动：</span><br><span class="line">优点：兼容性好。</span><br><span class="line">缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。</span><br><span class="line"><span class="number">2.</span>绝对定位</span><br><span class="line">优点：快捷。</span><br><span class="line">缺点：导致子元素也脱离了标准文档流，可实用性差。</span><br><span class="line"><span class="number">3.</span>flex 布局（<span class="title class_">CSS3</span>中出现的）</span><br><span class="line">优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。</span><br><span class="line"><span class="number">4.</span>网格布局（grid）</span><br><span class="line"><span class="title class_">CSS3</span>中引入的布局，很好用。代码量简化了很多。</span><br><span class="line">利用网格布局实现的一个左右300px中间自适应的布局</span><br><span class="line"><span class="number">5.</span>table表格布局 </span><br><span class="line">缺陷：当一个表格发生改变，整个table表格都将重新渲染，引起回流，消耗性能</span><br><span class="line"><span class="number">6.</span>百分比布局 也叫流式布局</span><br><span class="line"><span class="number">7.</span>rem布局</span><br></pre></td></tr></table></figure>

<h4 id="35-CSS-中的-1-像素问题是什么？有哪些解决方案？"><a href="#35-CSS-中的-1-像素问题是什么？有哪些解决方案？" class="headerlink" title="35.CSS 中的 1 像素问题是什么？有哪些解决方案？"></a>35.CSS 中的 1 像素问题是什么？有哪些解决方案？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>像素问题是指在移动设备等高像素密度屏幕上，使用<span class="variable constant_">CSS</span>设置的<span class="number">1</span>像素边框或者线条会变得比实际要粗。因为在这些屏幕上，<span class="number">1</span>个逻辑像素由多个物理像素呈现，导致边框或线条看起来比预期的更加宽厚。</span><br><span class="line">解决方案：</span><br><span class="line"><span class="number">1.</span>使用scale进行缩放：通过将<span class="number">1</span>像素边框或者线条放大一定比例，然后再缩小回原大小，以此来保证其显示的细致度</span><br><span class="line"><span class="attr">border</span>: 1px solid black;</span><br><span class="line"><span class="attr">transform</span>: <span class="title function_">scale</span>(<span class="number">0.5</span>); <span class="comment">/* 将1像素边框缩小一半 */</span></span><br><span class="line">transform-<span class="attr">origin</span>: <span class="number">0</span> <span class="number">0</span>; <span class="comment">/* 将缩放基点设置为左上角 */</span></span><br><span class="line"><span class="number">2.</span>使用视口单位（viewport units）：<span class="title class_">CSS3</span>引入了视口单位（vw、vh、vmin和vmax），它们是相对于视口大小而非固定像素值的单位。我们可以将像素宽度转换成视口单位宽度</span><br><span class="line"><span class="attr">border</span>: 1px solid black;</span><br><span class="line">border-<span class="attr">width</span>: <span class="number">0.</span>01rem; <span class="comment">/* 将1像素边框的宽度转换成0.01rem */</span></span><br><span class="line"><span class="number">3.</span>使用 <span class="title class_">CSS3</span> 的 box-shadow，可以用 box-shadow 属性来模拟边框</span><br><span class="line">.<span class="property">border</span> &#123;</span><br><span class="line">  box-<span class="attr">shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> 1px #<span class="number">000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.</span>使用 viewport，在 head 中添加如下代码可以解决 1px 问题</span><br><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;</span><br></pre></td></tr></table></figure>



<h3 id="三-vue2"><a href="#三-vue2" class="headerlink" title="三.vue2"></a>三.vue2</h3><h4 id="1-什么是虚拟DOM"><a href="#1-什么是虚拟DOM" class="headerlink" title="1.什么是虚拟DOM"></a>1.什么是虚拟DOM</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">面试题 ？什么是虚拟dom  vitural dom </span><br><span class="line">        <span class="comment">// =&gt; 虚拟dom 就是 =&gt; 用来保存节点信息, 描述真实dom的JavaScript对象</span></span><br><span class="line">优点：无需手动操作 <span class="variable constant_">DOM</span>： 我们不再需要手动去操作 <span class="variable constant_">DOM</span>，只需要写好 <span class="title class_">View</span>-<span class="title class_">Model</span> 的代码逻辑，框架会根据虚拟 <span class="variable constant_">DOM</span> 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</span><br><span class="line">缺点：无法进行极致优化： 虽然虚拟 <span class="variable constant_">DOM</span> + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 <span class="variable constant_">DOM</span> 无法进行针对性的极致优化。首次渲染大量<span class="variable constant_">DOM</span>时，由于多了一层虚拟<span class="variable constant_">DOM</span>的计算，会比innerHTML插入慢。</span><br></pre></td></tr></table></figure>

<h4 id="2-vue就地复用策略"><a href="#2-vue就地复用策略" class="headerlink" title="2.vue就地复用策略"></a>2.vue就地复用策略</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">就地复用：vue会尽可能的同层级同位置， 对比虚拟dom，复用旧的dom结构，进行差异化更新</span><br><span class="line">好处：可以复用旧的dom结构，提高渲染效率</span><br><span class="line">设置了key，相当于给这个li标签加了一个标记，</span><br><span class="line">新旧虚拟dom对比的时候，就会按着key的值 对比原来的那个标签</span><br><span class="line"><span class="comment">//就是相当于，当我们以数组的index作为key，然后比如我们在数组的开头加了一个元素，再去渲染页面时，首先根据标识一样的去对比，</span></span><br><span class="line"><span class="comment">//如果内容结构一样就复用，不一样就生成，提高页面渲染的效率</span></span><br></pre></td></tr></table></figure>

<h4 id="3-请解释什么是单页面应用-single-page-app-以及如何使其对搜索引擎友好"><a href="#3-请解释什么是单页面应用-single-page-app-以及如何使其对搜索引擎友好" class="headerlink" title="3.请解释什么是单页面应用(single page app),以及如何使其对搜索引擎友好"></a>3.请解释什么是单页面应用(single page app),以及如何使其对搜索引擎友好</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">什么是单页面应用：</span><br><span class="line">指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源</span><br><span class="line"><span class="variable constant_">MPA</span>多页面应用 （<span class="title class_">MultiPage</span> <span class="title class_">Application</span>），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新</span><br><span class="line">解决单页面页面首次加载速度慢</span><br><span class="line"><span class="number">1.</span>路由懒加载，最开始不需要展示的页面，就利用懒加载</span><br><span class="line"><span class="number">2.</span>浏览器缓存 利用浏览器缓存来存储静态资源</span><br><span class="line"><span class="number">3.</span>打包js css 文件，减少代码体积</span><br><span class="line"><span class="number">4.</span>使用<span class="variable constant_">CDN</span>内容分发网络 将静态资源部署到 <span class="variable constant_">CDN</span> 上，可以使用户从最近的服务器获取资源，从而加速首屏加载速度。</span><br><span class="line"><span class="number">5.</span>使用服务端渲染和预渲染</span><br></pre></td></tr></table></figure>

<p><strong>如何使其对搜索引擎友好</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>预渲染</span><br><span class="line"><span class="number">2.</span><span class="title function_">SSR</span>(服务端渲染)<span class="comment">//指的是我们页面的渲染操作不是在浏览器了，而是服务端，服务端直接返回给我们html</span></span><br></pre></td></tr></table></figure>

<h4 id="4-组件中的data为什么是一个函数？"><a href="#4-组件中的data为什么是一个函数？" class="headerlink" title="4.组件中的data为什么是一个函数？"></a>4.组件中的data为什么是一个函数？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</span><br><span class="line"><span class="number">2.</span>因为，在<span class="keyword">new</span> <span class="title class_">Vue</span>的时候传入我们的配置项$options,之后执行<span class="variable language_">this</span>.<span class="title function_">_init</span>()把配置项传进去，然后_init在内部做了很多操作，我们重点看那个<span class="variable language_">this</span>.<span class="title function_">_initState</span>()  initState函数按顺序初始化$options的数据，顺序为 prop&gt;methods&gt;data&gt;computed&gt;watch,在我们初始化data时，会调用<span class="variable language_">this</span>.<span class="property">_initData</span>,在这个initData中 将vm.<span class="property">$options</span>.<span class="property">data</span> 赋值给vm.<span class="property">_data</span>，如果说我们data是一个对象，则所有的vue实例都能修改data对象里面的属性，因为他们引用的对象指向同一个地址</span><br></pre></td></tr></table></figure>

<h4 id="5-为什么v-for和v-if不建议用在一起"><a href="#5-为什么v-for和v-if不建议用在一起" class="headerlink" title="5.为什么v-for和v-if不建议用在一起"></a>5.为什么v-for和v-if不建议用在一起</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.当 v-<span class="keyword">for</span> 和 v-<span class="keyword">if</span> 处于同一个节点时，v-<span class="keyword">for</span> 的优先级比 v-<span class="keyword">if</span> 更高</span><br><span class="line">这意味着 v-<span class="keyword">if</span> 将分别重复运行于每个 v-<span class="keyword">for</span> 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费（<span class="title class_">Vue2</span>.<span class="property">x</span>）</span><br><span class="line"><span class="number">2.</span>这种场景建议使用 computed 计算属性，先对数据进行过滤</span><br></pre></td></tr></table></figure>

<h4 id="6-vue中key的作用"><a href="#6-vue中key的作用" class="headerlink" title="6.vue中key的作用"></a>6.vue中key的作用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key的作用</span><br><span class="line"><span class="number">1.</span>是为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟<span class="variable constant_">DOM</span></span><br><span class="line">如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</span><br><span class="line">key也不能是元素的index，因为假设我们给数组前插入一个新元素，它的下标是<span class="number">0</span>，那么和原来的第一个元素重复了，整个数组的key都发生了改变，这样就跟没有key的情况一样了</span><br><span class="line"><span class="number">2.</span>第一种情况是 v-<span class="keyword">if</span> 中使用 key。由于 <span class="title class_">Vue</span> 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-<span class="keyword">if</span> 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</span><br><span class="line">但是只是vue2有这个缺点，vue3没有</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-说说MVVM模型"><a href="#7-说说MVVM模型" class="headerlink" title="7.说说MVVM模型"></a>7.说说MVVM模型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">MVVM</span>模型 ：一种软件设计模式   是<span class="title class_">Model</span> 和<span class="title class_">View</span> 和<span class="title class_">ViewMolde</span>的简写</span><br><span class="line"> <span class="comment">// M:Model 代表数据模型，数据和业务逻辑都在 Model 层中定义。（对应data中的数据和业务逻辑）</span></span><br><span class="line"><span class="comment">// V:View 代表UI视图,也就是用户界面，负责数据的展示。 （对应着template模板，负责数据的展示）</span></span><br><span class="line"><span class="comment">// VM:viewModel 也叫做视图数据连接层, 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作, （对应着我们的vue实例)</span></span><br><span class="line"><span class="variable constant_">MVC</span> 模型是model 数据模型 view 视图 controller 控制器 ，原生js操作dom的一种方式</span><br><span class="line">问题： 展示 js 中的变量，需要 innerText textContent innerHTML  <span class="number">1.</span> xss 攻击  <span class="number">2.</span>字符串需要编译之后才能生成 dom 性能差</span><br><span class="line">    <span class="comment">// 什么模式? MVC —— 模型视图控制器 —— 彼此割裂</span></span><br><span class="line">     <span class="comment">// 什么叫做模式？ —— 一种解决问题的套路</span></span><br><span class="line"><span class="variable constant_">MVVM</span>（<span class="title class_">Model</span>-<span class="title class_">View</span>-<span class="title class_">ViewModel</span>）是一种用于构建用户界面的软件架构模式，它将应用程序分成三个部分：模型(model)、视图(view)和视图模型(viewModel)。视图模型通常负责维护模型状态，并同步视图以反映模型的变化。</span><br><span class="line">在<span class="variable constant_">MVVM</span>中，发布订阅者模式通常被用来实现视图模型和视图之间的通信，例如当数据发生变化时通知视图进行更新。<span class="title class_">Vue</span>.<span class="property">js</span>就是基于这种观察者模式设计的</span><br></pre></td></tr></table></figure>

<h4 id="8-说一下什么是vue生命周期函数"><a href="#8-说一下什么是vue生命周期函数" class="headerlink" title="8.说一下什么是vue生命周期函数"></a>8.说一下什么是vue生命周期函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先 vue生命周期函数是vue框架提供的内置函数 ，在不同的阶段自动执行</span><br><span class="line"><span class="number">1.</span>数据初始化阶段 <span class="number">2.</span> 挂载dom阶段 <span class="number">3.</span>数据更新阶段 <span class="number">4.</span>组件销毁阶段</span><br><span class="line"><span class="number">1.</span> beforeCreate：data数据初始化之前，组件还没有数据</span><br><span class="line"><span class="number">2.</span> <span class="attr">created</span>: data数据初始化之后，可以获取到组件的数据</span><br><span class="line"><span class="number">3.</span> beforeMount：<span class="variable constant_">DOM</span>挂载到页面之前，<span class="variable constant_">DOM</span>还未挂载</span><br><span class="line"><span class="number">4.</span> mounted：<span class="variable constant_">DOM</span>挂载之后，可以操作<span class="variable constant_">DOM</span>了</span><br><span class="line"><span class="number">5.</span> <span class="attr">beforeUpdate</span>: 数据更新，<span class="variable constant_">DOM</span>更新前  <span class="comment">//组件更新前 ---&gt;数据是新的，页面是旧的 虚拟dom还没有对比重新渲染~~</span></span><br><span class="line"><span class="number">6.</span> <span class="attr">updated</span>: 数据更新，<span class="variable constant_">DOM</span>更新后</span><br><span class="line"><span class="number">7.</span> <span class="attr">beforeDestroy</span>: 组件销毁前   <span class="comment">// 组件销毁前 ——组件实例依然还保留全部的功能 // 全局的定时器，不会自动销毁，需要手动关闭~~</span></span><br><span class="line"><span class="number">8.</span> <span class="attr">destroyed</span>: 组件销毁后</span><br></pre></td></tr></table></figure>

<h4 id="9-说说什么是单页面应用程序-优缺点"><a href="#9-说说什么是单页面应用程序-优缺点" class="headerlink" title="9.说说什么是单页面应用程序 优缺点"></a>9.说说什么是单页面应用程序 优缺点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">单页面应用程序：指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</span><br><span class="line">多页面应用程序：<span class="variable constant_">MPA</span>多页面应用 （<span class="title class_">MultiPage</span> <span class="title class_">Application</span>），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新</span><br><span class="line">优点：</span><br><span class="line"><span class="number">1.</span> 传统的多页面应用程序，每次请求服务器返回的都是一整个完整的页面</span><br><span class="line"><span class="number">2.</span> 单页面应用程序只有第一次会加载完整的页面</span><br><span class="line"><span class="number">3.</span> 以后每次请求仅仅获取必要的数据，减少了请求体积，加快页面响应速度，降低了对服务器的压力</span><br><span class="line"><span class="number">4.</span> <span class="variable constant_">SPA</span>更好的用户体验，运行更加流畅</span><br><span class="line">缺点:</span><br><span class="line"><span class="number">1.</span>不利于 <span class="variable constant_">SEO</span> 搜索引擎优化 谷歌浏览器在解决这个问题 <span class="attr">ssr</span>:服务端渲染 server side rendering</span><br></pre></td></tr></table></figure>

<h4 id="10-说说为什么vue是异步更新DOM"><a href="#10-说说为什么vue是异步更新DOM" class="headerlink" title="10.说说为什么vue是异步更新DOM"></a>10.说说为什么vue是异步更新DOM</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>提高性能，将多次修改dom，存起来，一次性更新</span><br><span class="line">原理:因为虚拟<span class="variable constant_">DOM</span>只需要一次就可以将整个组件的<span class="variable constant_">DOM</span>更新到最新，当dom更新了后，vue侦听器侦听到了，会先判断任务队列中有没有渲染操作的函数，保证不重复，然后只需要将渲染操作推迟到本轮事件循环的最后或者下一轮事件循环。</span><br><span class="line"><span class="number">2.</span>(vue更新dom后是异步的调用了render函数和diff算法,这时无论后面有多少修改dom的操作，vue也只会在本轮事件循环执行完之前或下一次事件循环之前，更新dom，所以我们同步或异步的操作dom，都会存起来一次性更新)</span><br><span class="line">也就是说，只需要在本轮事件循环的最后，等前面更新状态的语句都执行完之后，执行一次渲染操作，它就可以无视前面各种更新状态的语法，无论前面写了多少条更新状态的语句，只在最后渲染一次就可以了，<span class="title class_">Vue</span>的更新操作默认会将执行渲染操作的函数添加到微任务队列中</span><br><span class="line"><span class="string">``</span>在钩子函数<span class="title function_">created</span>()里面想要获取操作<span class="title class_">Dom</span>，<span class="string">`把操作DOM的方法放在$nextTick中`</span></span><br><span class="line">但为什么vue是异步更新dom，<span class="variable language_">this</span>.$nextTick()为什么一定比它慢?</span><br><span class="line">    不一定的,看修改的顺序，如果在<span class="variable language_">this</span>.$nextTick()下面修改dom了，<span class="variable language_">this</span>.$nextTick()就获取不到</span><br></pre></td></tr></table></figure>

<p><strong>$nextTick原理</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>nextTick 在内部做了一个优雅降级的操作，首先判断当前环境和浏览器支不不支持<span class="title class_">Promise</span>，判断<span class="title class_">Promise</span> 是不是<span class="literal">undefined</span> ，调用isNative方法，isNative方法，是把<span class="title class_">Promise</span>传进去，判断<span class="title class_">Promise</span>是不是一个函数，以及用正则判断<span class="title class_">Promise</span>被toString字符串化，是不是包含native code 初始的时候返回<span class="literal">true</span>则使用promise,返回<span class="literal">false</span>则判断<span class="title class_">MutationObserver</span> 以及setImmediate最后<span class="built_in">setTimeout</span>兜底</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">isNative</span>(<span class="params">Ctor</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Ctor</span>.<span class="title function_">toString</span>())</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="title class_">Ctor</span> === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="regexp">/native code/</span>.<span class="title function_">test</span>(<span class="title class_">Ctor</span>.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="11-说一下vue2生命周期"><a href="#11-说一下vue2生命周期" class="headerlink" title="11.说一下vue2生命周期"></a>11.说一下vue2生命周期</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">钩子函数用来描述一个组件从引入到退出的全过程中的某个过程，整个过程称为生命周期。 钩子函数按照组件生命周期的过程分为，挂载阶段=&gt;更新阶段=&gt;销毁阶段</span><br><span class="line"><span class="number">1.</span> beforeCreate：data数据初始化之前，组件还没有数据</span><br><span class="line"><span class="number">2.</span> <span class="attr">created</span>: data数据初始化之后，可以获取到组件的数据</span><br><span class="line"><span class="number">3.</span> beforeMount：<span class="variable constant_">DOM</span>挂载到页面之前，<span class="variable constant_">DOM</span>还未挂载</span><br><span class="line"><span class="number">4.</span> mounted：<span class="variable constant_">DOM</span>挂载之后，可以操作<span class="variable constant_">DOM</span>了</span><br><span class="line"><span class="number">5.</span> <span class="attr">beforeUpdate</span>: 数据更新，<span class="variable constant_">DOM</span>更新前  <span class="comment">//组件更新前 ---&gt;数据是新的，页面是旧的 虚拟dom还没有对比重新渲染~~</span></span><br><span class="line"><span class="number">6.</span> <span class="attr">updated</span>: 数据更新，<span class="variable constant_">DOM</span>更新后</span><br><span class="line"><span class="number">7.</span> <span class="attr">beforeDestroy</span>: 组件销毁前   <span class="comment">// 组件销毁前 ——组件实例依然还保留全部的功能 // 全局的定时器，不会自动销毁，需要手动关闭~~</span></span><br><span class="line"><span class="number">8.</span> <span class="attr">destroyed</span>: 组件销毁后</span><br></pre></td></tr></table></figure>

<h4 id="12-说一下jquery和vue的区别"><a href="#12-说一下jquery和vue的区别" class="headerlink" title="12.说一下jquery和vue的区别"></a>12.说一下jquery和vue的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jquery</span>:命令式   ：jQuery是命令式的操作<span class="variable constant_">DOM</span>，命令式的局部更新视图   </span><br><span class="line">vue：声明式     ：我们不再需要关注怎么操作<span class="variable constant_">DOM</span>，因为框架会帮我们自动去做，我们只关注状态就好了。  易维护</span><br></pre></td></tr></table></figure>

<h4 id="13-说一下Vuex中的mutation函数为什么必须是异步的"><a href="#13-说一下Vuex中的mutation函数为什么必须是异步的" class="headerlink" title="13.说一下Vuex中的mutation函数为什么必须是异步的"></a>13.说一下Vuex中的mutation函数为什么必须是异步的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为什么mutation必须是同步的</span></span><br><span class="line"><span class="comment">// 在Vue.js和其他一些前端JavaScript框架中，为什么mutation必须是同步的呢?</span></span><br><span class="line"><span class="comment">// 这是因为Vue.js采用了一种基于数据驱动的设计模式，其中状态(state)存储在Vuex存储store)中。为了使Vuex存储在任何时候都保持一致性，必须保证状态的更改是可预测的</span></span><br><span class="line"><span class="comment">// 因此，Vuex要求mutation是同步的，这样才能保证状态的变更在任何时候都是可预测的。异步操作可能会导致状态的更改不可预测，并导致问题。</span></span><br><span class="line"><span class="comment">// 同时，异步操作通常会导致更多的复杂性，并且Vuex中的操作必须是可追踪的，以便调试和跟踪状态的变化。同步操作可以更容易地进行跟踪和调试，因此强制同步是有意义的。</span></span><br><span class="line"><span class="comment">//如果是异步的话，vue调试工具不知道这个异步函数是什么时候调用的，导致了数据的不可预测，并导致问题</span></span><br></pre></td></tr></table></figure>

<h4 id="14-设计模式有哪些"><a href="#14-设计模式有哪些" class="headerlink" title="14.设计模式有哪些"></a>14.设计模式有哪些</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>策略模式</span><br><span class="line">定义 : 要实现某一个功能，有多种方案可以选择。我们定义策略，把它们一个个封装起来，并且使它们可以相互转换。</span><br><span class="line">使用场景：</span><br><span class="line">当你负责的模块，基本满足以下情况时</span><br><span class="line">各判断条件下的策略相互独立且可复用</span><br><span class="line">策略内部逻辑相对复杂</span><br><span class="line">策略需要灵活组合</span><br><span class="line"><span class="number">2.</span>发布 - 订阅模式</span><br><span class="line">发布-订阅是一种消息范式，消息的发布者，不会将消息直接发送给特定的订阅者，而是通过消息通道广播出去，然后呢，订阅者通过订阅获取到想要的消息</span><br><span class="line">使用场景：</span><br><span class="line">各模块相互独立</span><br><span class="line">存在一对多的依赖关系</span><br><span class="line">依赖模块不稳定、依赖关系不稳定</span><br><span class="line">各模块由不同的人员、团队开发</span><br><span class="line"><span class="number">3.</span>装饰器模式</span><br><span class="line"> 是为了给一个函数赋能，增强它的某种能力，它能动态的添加对象的行为，也不影响原来的功能</span><br><span class="line"><span class="number">4.</span>适配器模式</span><br><span class="line">个人理解，为了解决我们不兼容的问题，把一个类的接口换成我们想要的接口。</span><br><span class="line"><span class="number">5.</span>代理模式</span><br><span class="line">代理模式是为其它对象提供一种代理以控制这个对象的访问，具体执行的功能还是这个对象本身</span><br></pre></td></tr></table></figure>

<h4 id="15-MVVM是怎么实现的"><a href="#15-MVVM是怎么实现的" class="headerlink" title="15.MVVM是怎么实现的"></a>15.MVVM是怎么实现的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">MVVM</span>的实现分为三步：数据劫持、模板编译和双向绑定</span><br><span class="line"><span class="number">1.</span>数据劫持  <span class="title class_">Object</span>.<span class="property">defineProperty</span>方法，这也是vue2死活不支持ie8的原因之一</span><br><span class="line">做数据劫持时主要用到的就是get和set两个属性，通过该方法被劫持的对象属性，只要在外界获取或者修改属性值都会触发get或set方法，这样我们就可以在get或set中对属性做一些额外对操作了</span><br><span class="line"><span class="number">2.</span>模板编译</span><br><span class="line">在vue中是通过一些指令或者小胡子语法来实现数据绑定的，而浏览器并不认识这些指令或者小胡子语法，因此在页面加载后需要将这些语法转换成真正的数据呈现给用户 遍历#app下所有的节点，然后根据节点的类型做相应的操作</span><br><span class="line"><span class="number">3.</span>双向绑定</span><br><span class="line">双向绑定 vue主要是利用数据劫持加发布订阅模式来实现数据的双向绑定的</span><br><span class="line"></span><br><span class="line">首先我们需要定义一个<span class="title class_">Dep</span>类，用于对属性进行依赖收集和通知用到属性到地方进行同步更新</span><br><span class="line">然后再定义一个<span class="title class_">Watcher</span>类，用于对属性进行监听，并实现属性值的同步更新</span><br><span class="line">在模板编译的时候，通过watcher来监听属性</span><br><span class="line">在数据劫持的get函数中进行依赖收集</span><br><span class="line">在数据劫持的set函数中通知各个watcher进行数据更新</span><br></pre></td></tr></table></figure>

<h4 id="16-vue中组件通信方式"><a href="#16-vue中组件通信方式" class="headerlink" title="16.vue中组件通信方式"></a>16.vue中组件通信方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 父组件绑定属性传值 子组件props接收 子组件<span class="variable language_">this</span>.$emit(<span class="string">&#x27;事件&#x27;</span>)提交事件 父组件@事件      父子级传值</span><br><span class="line"><span class="number">2.</span>ref $refs 给子组件绑定ref属性，$refs可以获取子组件的属性和方法   父子级传值</span><br><span class="line"><span class="number">3.</span>父组件中 <span class="variable language_">this</span>.<span class="property">$children</span>[<span class="number">0</span>].<span class="property">msg</span>获取子组件中的msg， 子组件中 <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="property">msg2</span> 获取父组件中的msg2   父子级传值</span><br><span class="line"><span class="number">4.</span><span class="title class_">Vuex</span>  vue插件，创建一个store实例，state定义数据，mutation修改操作，action 异步任务，getter计算属性 </span><br><span class="line"><span class="number">5.</span>provide / inject 通过provide：&#123;<span class="attr">msg</span>:<span class="string">&#x27;我是父组件的数据&#x27;</span>&#125; 与data同级 子组件中 ：<span class="attr">inject</span>:[<span class="string">&#x27;msg&#x27;</span>]与data同级，用的时候在data中<span class="attr">data</span>:&#123;<span class="keyword">return</span>&#123;<span class="attr">msg2</span>:<span class="variable language_">this</span>.<span class="property">msg</span>&#125;&#125; 不论子组件嵌套有多深, 只要调用了inject 那么就可以注入provide中的数据，而不局限于只能从当前父组件的props属性中回去数据</span><br><span class="line"><span class="number">6.</span>eventBus </span><br><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">EventBus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line"><span class="number">7.</span><span class="variable language_">localStorage</span> / <span class="variable language_">sessionStorage</span></span><br><span class="line"><span class="number">8.</span>$attrs 用途:用来接受父组件传过来数据 <span class="comment">//特征:父传子,没有被子组件props接收的属性放到$attrs里面 / </span></span><br><span class="line">$listeners <span class="comment">//用途:用来接受父组件监听的事件方法 //特征:父组件通v-on监听事件,子组件通过$listeners接收事件方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="17-diff算法"><a href="#17-diff算法" class="headerlink" title="17.diff算法"></a>17.diff算法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// diff算法  ==&gt; 比较新旧虚拟dom的差异</span></span><br><span class="line"><span class="comment">// 策略1  ==&gt; 同级根元素的对比</span></span><br><span class="line"><span class="comment">// 1. 如果根元素变化了，那么不考虑复用，整个dom树删除重建</span></span><br><span class="line"><span class="comment">// 2. 如果根元素不变，看根元素的属性是否变化来更新属性，并递归的往下对比差异。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略2  ==&gt; 兄弟元素比较</span></span><br><span class="line"><span class="comment">// 1. 对比同级兄弟元素，默认按照下标进行对比复用  （不加key或者说key为index的时候）</span></span><br><span class="line"><span class="comment">// 2. 如果设置了key，key是唯一的标识，会按照相同的key的元素进行复用</span></span><br></pre></td></tr></table></figure>

<h4 id="18-Vue-use原理"><a href="#18-Vue-use原理" class="headerlink" title="18.Vue.use原理"></a>18.Vue.use原理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.use 本身是一个函数，用来安装插件~~</span></span><br><span class="line"><span class="comment">// Vue.use内部做了哪些操作？</span></span><br><span class="line"><span class="comment">// 1. 判断插件是否注册安装过</span></span><br><span class="line">安装过直接<span class="keyword">return</span> <span class="variable language_">this</span> 退出，方便下次链式调用</span><br><span class="line"><span class="comment">// 2. 如果这个要安装的插件本身有install方法，执行它</span></span><br><span class="line"><span class="comment">//    同时把Vue构造函数作为第一个参数，以及use中的其他参数传入</span></span><br><span class="line"><span class="comment">// 3. 如果没有install方法，并且插件本身就是一个函数，就去调用执行它</span></span><br><span class="line"><span class="comment">//    同时把Vue构造函数作为第一个参数，以及use中的其他参数传入</span></span><br><span class="line"><span class="comment">// 4. 记录这个插件已经注册过 添加到数组</span></span><br></pre></td></tr></table></figure>

<h4 id="19-为什么刷新页面vuex数据会丢失"><a href="#19-为什么刷新页面vuex数据会丢失" class="headerlink" title="19.为什么刷新页面vuex数据会丢失"></a>19.为什么刷新页面vuex数据会丢失</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>页面刷新的时候异步请求后台数据，然后动态更新vuex中的数据，其中会有一种情况就是，网络延迟、数据量大的问题。 此时还没等vuex获取到后台返回的数据，页面就已经加载完成了，这样就会造成数据丢失</span><br><span class="line"><span class="number">2.</span>因为store里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化。</span><br><span class="line">解决办法：<span class="number">1.</span>使用本地存储 持久化数据</span><br><span class="line">         <span class="number">2.</span>使用插件 vuex-persist</span><br><span class="line">  使用步骤：</span><br><span class="line">  <span class="number">1.</span>npm install --save vuex-persist or yarn add vuex-persist</span><br><span class="line">  <span class="number">2.</span><span class="keyword">import</span> <span class="title class_">VuexPersistence</span> <span class="keyword">from</span> <span class="string">&#x27;vuex-persist&#x27;</span>  引入</span><br><span class="line">  <span class="number">3.</span><span class="keyword">const</span> vuexLocal = <span class="keyword">new</span> <span class="title class_">VuexPersistence</span>(&#123;  <span class="comment">//  先创建一个对象并进行配置             </span></span><br><span class="line">    <span class="attr">storage</span>: <span class="variable language_">window</span>.<span class="property">localStorage</span>         </span><br><span class="line">&#125;)</span><br><span class="line">  <span class="number">4.</span><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;       <span class="comment">//引入vuex插件</span></span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [vuexLocal.<span class="property">plugin</span>]</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<h4 id="20-vuex是干嘛的，属性怎么使用"><a href="#20-vuex是干嘛的，属性怎么使用" class="headerlink" title="20.vuex是干嘛的，属性怎么使用"></a>20.vuex是干嘛的，属性怎么使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vuex</span>是集中管理项目公共数据的</span><br><span class="line"><span class="title class_">Vuex</span> 有state、mutations 、getters、actions、<span class="variable language_">module</span>属性。 state 属性用来存储公共管理的数据。 mutations 属性定义改变state中数据的方法， 注意：不要在mutation中的方法中写异步方法ajax，那样数据就不可跟踪了 。 getters 属性可以认为是定义 store 的计算属性。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 action属性类似于 mutation，不同在于：<span class="title class_">Action</span> 提交的是 mutation，而不是直接变更状态。<span class="title class_">Action</span> 可以包含任意异步操作。 moudle属性是将store分割成模块 ,可以通过map函数一次性获取多个属性或方法</span><br></pre></td></tr></table></figure>

<h4 id="21-vue2实现响应式的原理和缺陷"><a href="#21-vue2实现响应式的原理和缺陷" class="headerlink" title="21.vue2实现响应式的原理和缺陷"></a>21.vue2实现响应式的原理和缺陷</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>响应式指的是：数据驱动视图，我们修改数据视图随之响应更新 核心<span class="variable constant_">API</span>：<span class="title class_">Object</span>.<span class="property">defineProperty</span></span><br><span class="line"><span class="number">1.</span>在我们执行<span class="keyword">new</span> <span class="title class_">Vue</span>创建实例时，会调用如下构造函数，在该函数内部调用<span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line"><span class="number">2.</span>initMixin函数里面定义了原型方法_init，_init调用了<span class="title function_">initState</span>(vm)等方法，_init里做了很多初始化工作，我们重点关注initState</span><br><span class="line"><span class="number">3.</span>initState函数按顺序初始化$options的数据，顺序为 prop&gt;methods&gt;data&gt;computed&gt;watch</span><br><span class="line"><span class="number">4.</span>initData 将vm.<span class="property">$options</span>.<span class="property">data</span> 赋值给vm.<span class="property">_data</span> </span><br><span class="line"><span class="number">5.</span><span class="title function_">proxy</span>() 把 data 里的每一个属性都代理到当前实例上，就可以通过 <span class="variable language_">this</span>.<span class="property">xx</span> 访问了</span><br><span class="line"><span class="number">6.</span>然后再调用 observe 监听整个 data，该方法用于创建监听器实例 ob = <span class="keyword">new</span> <span class="title class_">Observer</span>(value)</span><br><span class="line"><span class="number">7.</span>遍历对象所有属性，递归调用defineReactive 转为响应式对象，也是动态添加 getter 和 setter，实现双向绑定</span><br><span class="line"><span class="number">8.</span>在get中会收集属性的依赖，以及其属性值的依赖</span><br><span class="line"><span class="number">9.</span>当数据发生改变，会触发set函数，set通知视图更新</span><br></pre></td></tr></table></figure>

<h4 id="22-说一说-vue-的-keep-alive-？"><a href="#22-说一说-vue-的-keep-alive-？" class="headerlink" title="22.说一说 vue 的 keep-alive ？"></a>22.说一说 vue 的 keep-alive ？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">keep-alive&gt;作用：缓存组件，提升性能，避免重复加载一些不需要经常变动且内容较多的组件</span><br><span class="line">keep-alive属性 <span class="attr">abstract</span>: <span class="literal">true</span>, <span class="comment">// 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span></span><br><span class="line"> 当首次渲染的时候，会判断有没有这个属性，才会挂载到父组件上</span><br><span class="line">keep-alive 包裹动态组件时，会缓存不活动的组件实例</span><br><span class="line"> &lt;keep-alive&gt;的使用方法：使用<span class="string">`&lt;keep-alive&gt;`</span>标签对需要缓存的组件进行包裹， </span><br><span class="line"><span class="comment">//被keep-alive包含的组件不会被再次初始化，也就意味着不会重走生命周期函数</span></span><br><span class="line">但是有时候是希望我们缓存的组件可以能够再次进行渲染，这时<span class="title class_">Vue</span>为我们解决了这个问题</span><br><span class="line">被包含在 keep-alive 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated：</span><br><span class="line">activated 当 keep-alive 包含的组件再次渲染的时候触发</span><br><span class="line">deactivated 当 keep-alive 包含的组件销毁的时候触发</span><br><span class="line">keep-alive可以接收<span class="number">3</span>个属性做为参数进行匹配对应的组件进行缓存:</span><br><span class="line"><span class="number">1.</span>include包含的组件(可以为字符串，数组，以及正则表达式,只有匹配的组件会被缓存)</span><br><span class="line"><span class="number">2.</span>exclude排除的组件(以为字符串，数组，以及正则表达式,任何匹配的组件都不会被缓存)</span><br><span class="line"><span class="number">3.</span>max缓存组件的最大值(类型为字符或者数字,可以控制缓存组件的个数)</span><br><span class="line">注：当使用正则表达式或者数组时，一定要使用v-bind</span><br><span class="line"><span class="comment">//防坑指南</span></span><br><span class="line"><span class="number">1.</span>keep-alive 先匹配被包含组件的 name 字段，如果 name 不可用，则匹配当前组件 components 配置中的注册名称。</span><br><span class="line"><span class="number">2.</span>keep-alive 不会在函数式组件中正常工作，因为它们没有缓存实例。</span><br><span class="line"><span class="number">3.</span>当匹配条件同时在 include 与 exclude 存在时，以 exclude 优先级最高(当前vue <span class="number">2.4</span><span class="number">.2</span> version)。比如：包含于排除同时匹配到了组件A，那组件A不会被缓存。</span><br><span class="line"><span class="number">4.</span>包含在 keep-alive 中，但符合 exclude ，不会调用activated和 deactivated。</span><br></pre></td></tr></table></figure>

<h4 id="23-说一说vue-router-实现懒加载的方法？"><a href="#23-说一说vue-router-实现懒加载的方法？" class="headerlink" title="23.说一说vue-router 实现懒加载的方法？"></a>23.说一说vue-router 实现懒加载的方法？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue-router 实现懒加载的方法有两种： <span class="title class_">ES6</span>的impot方式: <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/About.vue&#x27;</span>), <span class="variable constant_">VUE</span>中的异步组件进行懒加载方式: <span class="attr">component</span>: <span class="function"><span class="params">resolve</span>=&gt;</span>(<span class="built_in">require</span>([<span class="string">&#x27;../views/About&#x27;</span>],resolve)) 加分回答 vue-router 实现懒加载的作用：性能优化，不用到该路由，不加载该组件。</span><br></pre></td></tr></table></figure>

<h4 id="24-说一说computed和watch的区别？"><a href="#24-说一说computed和watch的区别？" class="headerlink" title="24.说一说computed和watch的区别？"></a>24.说一说computed和watch的区别？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；必须要有返回值 ,不支持异步，当<span class="title class_">Computed</span>中有异步操作时，无法监听数据的变化，如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法</span><br><span class="line"><span class="number">2.</span> watch： 更多的是观察的作用,有两个属性，深度监听需要加<span class="attr">deep</span>:<span class="literal">true</span>，immediate：<span class="literal">true</span>,组件加载立即触发回调函数,监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值,支持异步，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； </span><br><span class="line"><span class="number">3.</span>加分回答 computed应用场景：需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； watch应用场景：需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 <span class="variable constant_">API</span> )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</span><br></pre></td></tr></table></figure>

<h4 id="25-vue中刷新页面的方式有哪些"><a href="#25-vue中刷新页面的方式有哪些" class="headerlink" title="25.vue中刷新页面的方式有哪些"></a>25.vue中刷新页面的方式有哪些</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>原生js location.<span class="title function_">reload</span>()  需要刷新的时候加这么一句代码，即可刷新</span><br><span class="line"><span class="number">2.</span>借助vue中的路由跳转方式， 在需要刷新的地方 写入 <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(<span class="number">0</span>)  因为是刷新当前页面，所以参数是<span class="number">0</span></span><br><span class="line"><span class="comment">//以上两种都是强制刷新，页面会出现短暂的空白</span></span><br><span class="line"><span class="number">3.</span><span class="title function_">provide</span>(po wai de)/inject组合方式  <span class="comment">//是普通刷新</span></span><br><span class="line">在父组件中定义一个布尔值变量，在定义一个刷新函数 ，刷新函数需要做的是，把布尔值取反，在确定取反之后(加个<span class="keyword">await</span> <span class="title function_">nextTick</span>()保证先取法)，再一次取反，通过v-<span class="keyword">if</span> 控制子组件的显示隐藏，当需要刷新的时候，子组件调用父组件中的刷新函数</span><br></pre></td></tr></table></figure>

<h4 id="26-说一下登录流程"><a href="#26-说一下登录流程" class="headerlink" title="26.说一下登录流程"></a>26.说一下登录流程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 我们在登录页点击登录的时候,前端会带着用户输入的用户名和密码，去调用后端的登录接口</span><br><span class="line"><span class="number">2.</span>后端收到请求会去验证用户名和密码，如果验证失败会返回错误信息，前端提示相应的错误信息，如果验证成功，后端就会给前端返回一个token</span><br><span class="line"><span class="number">3.</span>前端拿到token后，将token存储到 vuex和<span class="variable language_">localStorage</span>中，并跳转到相应的页面，并提示登录成功</span><br><span class="line"><span class="number">4.</span>前端每一次跳转到需要具备登录状态的页面时，都需要判断当前token是否存在，不存在则跳转到登录页，存在则正常跳转，通常把这个逻辑封装在路由守卫， router.<span class="title function_">beforEach</span>((to,<span class="keyword">from</span>,next)) 路由前置守卫，另外在向后端发送其他请求时，需要在请求头中带上token，项目中我们一般把这一块的逻辑封装在请求拦截器中，后端判断请求头中有没有token，有则验证该token，验证成功就会正常的给我们返回数据，如果验证失败，比如token过期了，那么就会返回相应的错误码，前端拿到错误信息，清除token并回退至登录页</span><br></pre></td></tr></table></figure>

<h4 id="27-vue实例最后挂载到哪个标签上的"><a href="#27-vue实例最后挂载到哪个标签上的" class="headerlink" title="27.vue实例最后挂载到哪个标签上的"></a>27.vue实例最后挂载到哪个标签上的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue实例最后会挂载在body标签里面，所以我们在vue中是获取不了body 标签的，如果要使用body标</span><br><span class="line">签的话需要用原生的方式获取</span><br></pre></td></tr></table></figure>

<h4 id="28-token是什么？（加密）"><a href="#28-token是什么？（加密）" class="headerlink" title="28.token是什么？（加密）"></a>28.token是什么？（加密）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> token也可以称做令牌，一般由 uid+time+<span class="title function_">sign</span>(签名)+[固定参数] 组成</span><br><span class="line"><span class="attr">uid</span>: 用户唯一身份标识</span><br><span class="line"><span class="attr">time</span>: 当前时间的时间戳</span><br><span class="line"><span class="attr">sign</span>: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</span><br><span class="line">固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</span><br><span class="line"><span class="number">2.</span> token在客户端一般存放于<span class="variable language_">localStorage</span>，cookie，或<span class="variable language_">sessionStorage</span>中。在服务器一般存于数据</span><br><span class="line">库中</span><br><span class="line"><span class="number">3.</span> token 的认证流程</span><br><span class="line">用户登录，成功后服务器返回<span class="title class_">Token</span>给客户端。</span><br><span class="line">客户端收到数据后保存在客户端</span><br><span class="line">客户端再次访问服务器，将token放入headers中 或者每次的请求 参数中</span><br><span class="line">服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</span><br><span class="line"><span class="number">4.</span> token可以抵抗<span class="variable constant_">CSRF</span>，cookie+session不行</span><br><span class="line"><span class="number">5.</span> session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会</span><br><span class="line">面对负载均衡问题。负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享</span><br><span class="line">session</span><br><span class="line"><span class="number">6.</span> 客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将</span><br><span class="line">token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这</span><br><span class="line">个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载</span><br><span class="line">均衡多服务器的问题了。这个方法叫做<span class="title function_">JWT</span>(<span class="title class_">Json</span> <span class="title class_">Web</span> <span class="title class_">Token</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="29-说一下双向数据绑定"><a href="#29-说一下双向数据绑定" class="headerlink" title="29.说一下双向数据绑定"></a>29.说一下双向数据绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue中  v-model 是一个语法糖</span></span><br><span class="line">      作用：=&gt; 将data中的数据和表单元素做一个双向绑定</span><br><span class="line">      原理：针对不同的表单元素（或者说表单元素type的不同属性值），vue底层会让</span><br><span class="line">        v-model实现不同的属性绑定和事件监听 </span><br><span class="line"> <span class="number">1.</span> type=<span class="string">&quot;text&quot;</span></span><br><span class="line">      </span><br><span class="line">      <span class="number">1.1</span> :value + @input </span><br><span class="line"></span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;msg&quot;</span>&gt;等价于</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> :value=<span class="string">&quot;msg&quot;</span> @input=<span class="string">&quot;handleInput&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">      <span class="number">1.2</span> :value + @change   ==&gt; v-model.<span class="property">lazy</span> 相当于是触发回车或者失去焦点的时候触发 =&gt; @change</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">laze</span>=<span class="string">&quot;msg&quot;</span>&gt;等价于</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> :value=<span class="string">&quot;msg&quot;</span> @change=<span class="string">&quot;handleInput&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">      <span class="number">2.</span> type=<span class="string">&quot;checkbox&quot;</span>   ==&gt; :checked + @change </span><br><span class="line"></span><br><span class="line">        &lt;input type=<span class="string">&quot;checkbox&quot;</span> v-model=<span class="string">&quot;flag&quot;</span>&gt;等价于</span><br><span class="line">        &lt;input type=<span class="string">&quot;checkbox&quot;</span> :checked=<span class="string">&quot;flag&quot;</span> @change=<span class="string">&quot;handleInput&quot;</span>&gt;</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;!-- &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;  而v-mdel一句指令就搞定了 --&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; :value=&quot;msg&quot; @input=&quot;hanldInput&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- msg2可以使用， e找不到--&gt;</span><br><span class="line">    &lt;!-- 模板中使用事件对象 如果监听的是dom元素事件 $event =&gt; 事件对象  --&gt;</span><br><span class="line">    &lt;!-- &lt;input type=&quot;text&quot; :value=&quot;msg2&quot; @input=&quot;msg2 = $event.target.value&quot;&gt; --&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="30-vue自定义指令"><a href="#30-vue自定义指令" class="headerlink" title="30.vue自定义指令"></a>30.vue自定义指令</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;mymodel&#x27;</span>, &#123;</span><br><span class="line">        <span class="comment">//只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span></span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el, binding, vnode, oldVnode</span>) &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中),需要父节点dom时使用这个钩子</span></span><br><span class="line">        <span class="title function_">inserted</span>(<span class="params">el, binding, vnode, oldVnode</span>) &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</span></span><br><span class="line">        <span class="title function_">update</span>(<span class="params">el, binding, vnode, oldVnode</span>) &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//指令所在组件的 VNode **及其子 VNode** 全部更新后调用。</span></span><br><span class="line">        <span class="title function_">componentUpdated</span>(<span class="params">el, binding, vnode, oldVnode</span>) &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        只调用一次，指令与元素解绑时调用。</span><br><span class="line">        <span class="title function_">unbind</span>(<span class="params">el, binding, vnode, oldVnode</span>) &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="31-vue中的computed和data里面的数据以及props可以同名吗"><a href="#31-vue中的computed和data里面的数据以及props可以同名吗" class="headerlink" title="31.vue中的computed和data里面的数据以及props可以同名吗"></a>31.vue中的computed和data里面的数据以及props可以同名吗</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不可以，因为computed和data以及props里面的数据最终会挂载到vue实例上，会被覆盖</span><br></pre></td></tr></table></figure>

<h4 id="32-vue中数组的哪些方法可以触发视图的更新，哪些不可以，有什么解决办法"><a href="#32-vue中数组的哪些方法可以触发视图的更新，哪些不可以，有什么解决办法" class="headerlink" title="32.vue中数组的哪些方法可以触发视图的更新，哪些不可以，有什么解决办法"></a>32.vue中数组的哪些方法可以触发视图的更新，哪些不可以，有什么解决办法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">可以触发视图更新的有</span><br><span class="line"><span class="number">1.</span>push <span class="number">2.</span>pop <span class="number">3.</span>shift <span class="number">4.</span>unshift <span class="number">5.</span>splice <span class="number">6.</span>sort <span class="number">7.</span>reverse <span class="number">8.</span>filter <span class="number">9.</span>slice <span class="number">10.</span>concat</span><br><span class="line">哪些不可以</span><br><span class="line"><span class="number">1.</span>利用索引直接设置一个数组项 <span class="number">2.</span>直接修改数组的长度</span><br><span class="line">vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</span><br><span class="line">解决办法 </span><br><span class="line">可以用 <span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">arr</span>,index,newValue)</span><br><span class="line">对象的情况 ，vue中的<span class="title class_">Object</span>.<span class="property">defineProperty</span>无法检测对象属性的添加或移除，无法监听到，</span><br><span class="line">解决办法:全局的<span class="title class_">Vue</span>.<span class="property">set</span>方法 （哪个对象，哪个属性，值）  <span class="comment">// 等效于   vm.$set(vm.obj, &#x27;b&#x27;, 66)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="33-说一下路由的传参方式"><a href="#33-说一下路由的传参方式" class="headerlink" title="33.说一下路由的传参方式"></a>33.说一下路由的传参方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router  路由的全局最大的一个实例，唯一的</span></span><br><span class="line"><span class="comment">// routes  路由规则列表 </span></span><br><span class="line"><span class="comment">// route   一条路由规则</span></span><br><span class="line"><span class="comment">// 传参的模式 </span></span><br><span class="line"> <span class="number">1.</span> 查询参数</span><br><span class="line">  &lt;router-link to=<span class="string">&quot;/article?desc=美食&amp;city=重庆&quot;</span>&gt;</span><br><span class="line"><span class="comment">// 2. 动态路由的方式传参  ==&gt; 需要配置路由规则 </span></span><br><span class="line"><span class="comment">// &#123;path:&#x27;/user/:id&#x27;, component:User&#125;      在配置规则里面</span></span><br><span class="line"><span class="comment">// &lt;router-link to=&quot;/user/007&quot;&gt;            </span></span><br><span class="line"></span><br><span class="line"> <span class="number">2.</span> 接收</span><br><span class="line"><span class="comment">// query参数接收</span></span><br><span class="line"><span class="comment">// this.$route.query.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态路由接收</span></span><br><span class="line"><span class="comment">// this.$route.params.key</span></span><br></pre></td></tr></table></figure>

<h4 id="34-说一下router模式"><a href="#34-说一下router模式" class="headerlink" title="34.说一下router模式"></a>34.说一下router模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="comment">// 路由模式 两种</span></span><br><span class="line">    <span class="comment">// 1. hash模式 ==&gt; # </span></span><br><span class="line">    <span class="comment">// 2. history模式  ===&gt; /不带#号 </span></span><br><span class="line">    <span class="comment">//  （如果改成了history模式，以后上下后端需要配置一些东西） </span></span><br><span class="line">    <span class="comment">// 后端如果不会，把vue文档丢给他，来，我教你~~~ </span></span><br><span class="line"></span><br><span class="line">    <span class="attr">mode</span>:<span class="string">&#x27;history&#x27;</span>,  <span class="comment">//设置路由模式 ，默认是hash</span></span><br></pre></td></tr></table></figure>

<h4 id="路由的按需加载"><a href="#路由的按需加载" class="headerlink" title="路由的按需加载"></a>路由的按需加载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">随着项目功能模块的增加，引入的文件数量剧增。如果不做任何处理，那么首屏加载会相当的缓慢，这个时候就可以用路由的懒加载，原理就是，当访问到某个页面的时候才加载对应的路由</span><br><span class="line">webpack&lt; <span class="number">2.4</span> 时</span><br><span class="line">&#123; </span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>, </span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>:<span class="function"><span class="params">resolve</span>=&gt;</span><span class="built_in">require</span>([<span class="string">&#x27;@/components/home&#x27;</span>],resolve)</span><br><span class="line">&#125; </span><br><span class="line">webpack&gt; <span class="number">2.4</span> 时</span><br><span class="line">&#123; </span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>, </span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;home&#x27;</span>, </span><br><span class="line">    <span class="attr">components</span>:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;@/components/home&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="35-说一下vue动态组件"><a href="#35-说一下vue动态组件" class="headerlink" title="35.说一下vue动态组件"></a>35.说一下vue动态组件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    &lt;!--</span><br><span class="line">      动态组件的使用 ( component 组件 + is 属性 )</span><br><span class="line">      (<span class="number">1</span>) 设置挂载点&lt;component&gt;, (在哪显示)</span><br><span class="line">      (<span class="number">2</span>) 使用is属性来设置要显示哪个组件 (显示哪一个组件)</span><br><span class="line">    --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span>  <span class="comment">///jsShow 是个变量 ，是组件名</span></span><br><span class="line">    &lt;!-- <span class="number">1.</span>动态组件：可以改变的组件</span><br><span class="line">        <span class="number">2.</span>解决问题：多个组件在同一位置，切换显示的需求 --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="36-自定义指令"><a href="#36-自定义指令" class="headerlink" title="36.自定义指令"></a>36.自定义指令</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 局部注册，自定义命令</span></span><br><span class="line">  <span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">focus</span>: &#123;  <span class="comment">//定义的时候不加v ，用的时候v-focus</span></span><br><span class="line">      <span class="comment">//inserted===&gt;当指令所在的元素节点，被插入挂载到页面上的时候，触发这个函数,只会触发一次</span></span><br><span class="line">      <span class="title function_">inserted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">        <span class="comment">//自己定义一些想要实现的逻辑</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(el)</span><br><span class="line">        el.<span class="title function_">focus</span>()</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">          </span><br><span class="line">   <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="comment">// (el , &#123;value&#125;) =&gt;对象的解构</span></span><br><span class="line">    el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// v-color=&quot;xxx&quot; ==&gt; binding.value </span></span><br><span class="line">  <span class="comment">// update指令的值改变时触发, binding.value的值修改触发   局部注册指令的时候也可以用</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="37-说一下vue中的插槽"><a href="#37-说一下vue中的插槽" class="headerlink" title="37.说一下vue中的插槽"></a>37.说一下vue中的插槽</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>插槽分为默认插槽  插槽名字默认是<span class="keyword">default</span> 如果只需要一个地方插入内容则</span><br><span class="line"><span class="number">2.</span>具名插槽   带有name属性的slot， 可以实现内容的定向分发  在slot标签上写上name属性，来决定放哪块内容 v-slot可以简写为#</span><br><span class="line"><span class="number">3.</span>作用域插槽</span><br><span class="line"><span class="comment">// 作用域插槽：插槽可以携带参数，并且这些参数有访问的限制</span></span><br><span class="line"><span class="comment">// 子组件插槽转过来的值，只能在对应的template模板中使用</span></span><br><span class="line"><span class="comment">// 1. 给slot标签添加属性的方式，传参</span></span><br><span class="line"><span class="comment">//  &lt;slot name=&quot;footer&quot; abc=&quot;abc&quot; msg=&quot;123&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="comment">// 2. 所有被被添加的属性，都放到了一个对象中 slotProps 中</span></span><br><span class="line"><span class="comment">//  &#123;abc:&#x27;abc&#x27;, msg:&#x27;123&#x27;&#125;</span></span><br><span class="line"> slot插槽，作用：提前占位，将来写在父组件标签中间的那部分内容，就会替换这个标签 --&gt;</span><br><span class="line">      &lt;!-- slot标签中也可以写默认的内容，只会在父组件使用时，没有提供内容的时候被渲染</span><br><span class="line">原理：实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，虚拟dom存放在<span class="string">`vm.$slot`</span>中，默认插槽为<span class="string">`vm.$slot.default`</span>，具名插槽为<span class="string">`vm.$slot.xxx`</span>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<span class="string">`$slot`</span>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</span><br></pre></td></tr></table></figure>

<h4 id="38-说一下路由守卫"><a href="#38-说一下路由守卫" class="headerlink" title="38.说一下路由守卫"></a>38.说一下路由守卫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一 全局守卫</span></span><br><span class="line">        <span class="comment">// 1. 全局前置守卫 router.beforeEach((to,from,next)=&gt;&#123;&#125;)</span></span><br><span class="line">        <span class="comment">// 2. 全局解析守卫 router.beforeResolve()</span></span><br><span class="line">        <span class="comment">// 3. 全局后置守卫 router.afterEach((to,from) =&gt;&#123;&#125;)    ==&gt;它唯一没有next函数</span></span><br><span class="line"> <span class="comment">// 二 路由独享守卫 router.beforeEnter </span></span><br><span class="line">        <span class="comment">// 在配置路由的时候定义的守卫，只在进入当前路由之前触发 拦住</span></span><br><span class="line"><span class="comment">// 三 组件内守卫  ==&gt; .vue文件中，配置的守卫，只对组件生效</span></span><br><span class="line">        <span class="comment">// 1. router.beforeRouteEnter</span></span><br><span class="line">        <span class="comment">// 2. router.beforeRouteUpdate </span></span><br><span class="line">        <span class="comment">// 3. router.beforeRouteLeave</span></span><br><span class="line">/  说明</span><br><span class="line"> <span class="comment">// 导航守卫 </span></span><br><span class="line">        <span class="comment">// 全局守卫 3个  beforeEach / beforeResolve/ afterEach</span></span><br><span class="line">        <span class="comment">// 路由独享守卫 1个  路由配置的时候定义的守卫  beforeEnter</span></span><br><span class="line">        <span class="comment">// 组件内的时候 3个 beforeRouteEnter   ==&gt; 没有this   next(vm =&gt; &#123;vm.msg&#125;)</span></span><br><span class="line">        <span class="comment">//                beforeRouteUpdate  ==&gt; 动态路由切换，复用组件，如果想要重新请求数据</span></span><br><span class="line">        <span class="comment">//                beforeRouteLeave   ==&gt; 在离开当前组件之前，询问一下，是否要离开呢</span></span><br></pre></td></tr></table></figure>

<h4 id="39-Vue-的父子组件生命周期钩子函数执行顺序"><a href="#39-Vue-的父子组件生命周期钩子函数执行顺序" class="headerlink" title="39.Vue 的父子组件生命周期钩子函数执行顺序"></a>39.Vue 的父子组件生命周期钩子函数执行顺序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加载渲染过程</span><br><span class="line">父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</span><br><span class="line">更新过程</span><br><span class="line">父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</span><br><span class="line">销毁过程</span><br><span class="line">父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</span><br></pre></td></tr></table></figure>

<h4 id="40-当new-Vue发生了什么"><a href="#40-当new-Vue发生了什么" class="headerlink" title="40.当new Vue发生了什么"></a>40.当new Vue发生了什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="title class_">Vue</span>构造函数传入配置项options ,在<span class="title class_">Vue</span>构造函数里调用<span class="variable language_">this</span>.<span class="title function_">_init</span>(options) ,<span class="variable language_">this</span>.<span class="property">_init</span>在里面调用了<span class="title function_">initState</span>(vm)方法，初始化了我们配置项的一些东西，data props，methods，computed，watch，当判断配置项有data时， 执行<span class="title function_">initData</span>(vm)方法，在initData方法中</span><br><span class="line">判断data是否是一个函数，如果是一个函数，就去调用这个函数，函数的返回值是一个对象，给vm.<span class="property">_data</span> 如果data不是一个函数，直接取data对象 取这个对象的所有属性 <span class="title class_">Object</span>.<span class="title function_">keys</span>(data) 循环为每个属性调用 <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)方法，proxy在内部将每个属性代理到了vm实例上，并设置get 和set方法 定义一个dep类，在get里收集依赖，数据发生改变，wacher通知视图更新</span><br></pre></td></tr></table></figure>

<h4 id="41-vue-loader是什么？使用它的用途有哪些？"><a href="#41-vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="41.vue-loader是什么？使用它的用途有哪些？"></a>41.vue-loader是什么？使用它的用途有哪些？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>-loader 会解析文件，提取出每个语言块 是vue文件的一个加载器，把template/script/style转换成js模块。</span><br></pre></td></tr></table></figure>

<h4 id="42-常见的vue事件修饰符"><a href="#42-常见的vue事件修饰符" class="headerlink" title="42.常见的vue事件修饰符"></a>42.常见的vue事件修饰符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">stop</span>:阻止冒泡</span><br><span class="line">.<span class="property">prevent</span>:阻止默认行为</span><br><span class="line">.<span class="property">self</span>:仅绑定元素自身触发</span><br><span class="line">.<span class="property">once</span>: <span class="number">2.1</span><span class="number">.4</span> 新增,只触发一次</span><br><span class="line">.<span class="property">passive</span>: <span class="number">2.3</span><span class="number">.0</span> 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.<span class="property">prevent</span> 一起使用</span><br><span class="line">.<span class="property">sync</span> 修饰符   自动更新父组件属性的 v-on 监听器</span><br><span class="line">.<span class="property">native</span>  让我们在子组件上定义的事件不在默认为是子组件提交的事件</span><br></pre></td></tr></table></figure>

<h4 id="43-ajax请求代码应该写在组件的methods中还是vuex的actions中"><a href="#43-ajax请求代码应该写在组件的methods中还是vuex的actions中" class="headerlink" title="43.ajax请求代码应该写在组件的methods中还是vuex的actions中"></a>43.ajax请求代码应该写在组件的methods中还是vuex的actions中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</span><br><span class="line">如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。</span><br></pre></td></tr></table></figure>

<h4 id="44-Vuex的严格模式是什么-有什么作用-怎么开启？"><a href="#44-Vuex的严格模式是什么-有什么作用-怎么开启？" class="headerlink" title="44.Vuex的严格模式是什么,有什么作用,怎么开启？"></a>44.Vuex的严格模式是什么,有什么作用,怎么开启？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到</span><br><span class="line"><span class="comment">//开启方式</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">strict</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="45-mutation和action有什么区别"><a href="#45-mutation和action有什么区别" class="headerlink" title="45.mutation和action有什么区别"></a>45.mutation和action有什么区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态</span><br><span class="line">action 可以包含任意异步操作。mutation只能是同步操作</span><br><span class="line"><span class="number">2.</span> 提交方式不同</span><br><span class="line">action 是用<span class="variable language_">this</span>.<span class="property">store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;ACTION_NAME&#x27;</span>,data)来提交。</span><br><span class="line">mutation是用<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;SET_NUMBER&#x27;</span>,<span class="number">10</span>)来提交</span><br><span class="line"><span class="number">3.</span> 接收参数不同</span><br><span class="line">接收参数不同，mutation第一个参数是state，而action第一个参数是context，</span><br></pre></td></tr></table></figure>

<h4 id="46-在v-model上怎么用Vuex中state的值？"><a href="#46-在v-model上怎么用Vuex中state的值？" class="headerlink" title="46.在v-model上怎么用Vuex中state的值？"></a>46.在v-model上怎么用Vuex中state的值？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">需要通过computed计算属性来转换。</span><br><span class="line">&lt;input v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line"><span class="comment">// ...当然我们也可以引入map辅助函数</span></span><br><span class="line">    <span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;message&#x27;</span>])  <span class="comment">//如何是模块里面的话，则需要加上模块名 ...mapState(&#x27;user&#x27;[&#x27;message&#x27;])</span></span><br><span class="line">    <span class="attr">message</span>: &#123;</span><br><span class="line">        get () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">message</span></span><br><span class="line">        &#125;,</span><br><span class="line">        set (value) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;updateMessage&#x27;</span>, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="47-Vue里面router-link在电脑上有用，在安卓上没反应怎么解决"><a href="#47-Vue里面router-link在电脑上有用，在安卓上没反应怎么解决" class="headerlink" title="47.Vue里面router-link在电脑上有用，在安卓上没反应怎么解决"></a>47.Vue里面router-link在电脑上有用，在安卓上没反应怎么解决</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>路由在<span class="title class_">Android</span>机上有问题，babel问题，安装babel polypill插件解决</span><br></pre></td></tr></table></figure>

<h4 id="48-Vue2中注册在router-link上事件无效解决方法"><a href="#48-Vue2中注册在router-link上事件无效解决方法" class="headerlink" title="48.Vue2中注册在router-link上事件无效解决方法"></a>48.Vue2中注册在router-link上事件无效解决方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用@click.<span class="property">native</span>。原因：router-link会阻止click事件，.<span class="property">native</span>指直接监听一个原生事件</span><br></pre></td></tr></table></figure>

<h4 id="49-vue中如何统一监听组件报错"><a href="#49-vue中如何统一监听组件报错" class="headerlink" title="49.vue中如何统一监听组件报错"></a>49.vue中如何统一监听组件报错</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="variable language_">window</span>.<span class="property">onerror</span></span><br><span class="line">可以监听当前页面所有的js报错，jquery时代经常使用，全局只绑定一次即可，不要放在多次渲染的组件中，这样容易多次绑定</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">msg,source,line</span>)&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="50-过滤器是什么，怎么实现"><a href="#50-过滤器是什么，怎么实现" class="headerlink" title="50.过滤器是什么，怎么实现"></a>50.过滤器是什么，怎么实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">根据过滤器的名称，过滤器是用来过滤数据的,- 需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。</span><br><span class="line">- 比如后端返回一个 **年月日的日期字符串**，前端需要展示为 **多少天前** 的数据格式，此时就可以用<span class="string">`fliters`</span>过滤器来处理数据。</span><br><span class="line">过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在**插值表达式** <span class="string">`**&#123;&#123; &#125;&#125;**`</span> 和 <span class="string">`**v-bind**`</span> **表达式** 中，然后放在操作符“ <span class="string">`**|**`</span> ”后面进行指示。</span><br><span class="line">&lt;li&gt;商品价格：&#123;&#123;item.<span class="property">price</span> | filterPrice&#125;&#125;&lt;/li&gt;</span><br><span class="line"> <span class="attr">filters</span>: &#123;</span><br><span class="line">    filterPrice (price) &#123;</span><br><span class="line">      <span class="keyword">return</span> price ? (<span class="string">&#x27;￥&#x27;</span> + price) : <span class="string">&#x27;--&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="51-说一下常见的事件修饰符"><a href="#51-说一下常见的事件修饰符" class="headerlink" title="51.说一下常见的事件修饰符"></a>51.说一下常见的事件修饰符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> .<span class="property">stop</span>：等同于 <span class="title class_">JavaScript</span> 中的 event.<span class="title function_">stopPropagation</span>() ，防止事件冒泡；</span><br><span class="line"><span class="number">2.</span> .<span class="property">prevent</span> ：等同于 <span class="title class_">JavaScript</span> 中的 event.<span class="title function_">preventDefault</span>() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</span><br><span class="line"><span class="number">3.</span> .<span class="property">capture</span> ：与事件冒泡的方向相反，事件捕获由外到内；</span><br><span class="line"><span class="number">4.</span> .<span class="property">self</span> ：只会触发自己范围内的事件，不包含子元素；</span><br><span class="line"><span class="number">5.</span> .<span class="property">once</span> ：只会触发一次。</span><br><span class="line"><span class="number">6.</span>.<span class="property">native</span> 个人理解就是，native最大的作用就是把组件上的事件不再认为是自定义的事件，而是原生的事件，原理是事件冒泡</span><br><span class="line"><span class="number">7.</span>.<span class="property">sync</span> 当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定</span><br></pre></td></tr></table></figure>

<h4 id="52-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决"><a href="#52-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决" class="headerlink" title="52.Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决"></a>52.Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">，obj.<span class="property">b</span> 已经成功添加，但是视图并未刷新。这是因为在<span class="title class_">Vue</span>实例创建时，obj.<span class="property">b</span>并未声明，因此就没有被<span class="title class_">Vue</span>转换为响应式的属性，自然就不会触发视图的更新,当然这并不是<span class="title class_">Object</span>.<span class="property">defineProperty</span>的缺陷，而是vue限制了，由玉溪说了是性能原因，性能代价和获得的用户体验收益不成正比，我下来也确实试了一下，</span><br><span class="line">解决方法：</span><br><span class="line">addObjB () (</span><br><span class="line">   <span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">obj</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;obj.b&#x27;</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">obj</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="53-Vue-模板是如何编译的？经历了哪些过程？"><a href="#53-Vue-模板是如何编译的？经历了哪些过程？" class="headerlink" title="53.Vue 模板是如何编译的？经历了哪些过程？"></a>53.Vue 模板是如何编译的？经历了哪些过程？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span> 模板在运行时会被编译成渲染函数，最终生成 <span class="title class_">Virtual</span> <span class="variable constant_">DOM</span>，进行页面渲染。</span><br><span class="line"><span class="title class_">Vue</span> 模板编译的过程主要分为以下三个步骤：</span><br><span class="line"><span class="number">1.</span>解析模板：<span class="title class_">Vue</span> 会使用正则表达式解析模板字符串，解析出其中的指令、标签、属性等内容。</span><br><span class="line"><span class="number">2.</span>生成 <span class="variable constant_">AST</span>（抽象语法树）：将解析后的模板字符串转化为抽象语法树，抽象语法树是一个以 <span class="title class_">JavaScript</span> 对象表示的树形结构，它将模板中的各个节点和属性用 <span class="title class_">JavaScript</span> 对象的形式表示出来，方便后续对模板进行分析和处理。</span><br><span class="line"><span class="number">3.</span>生成渲染函数：将 <span class="variable constant_">AST</span> 转化为渲染函数，渲染函数是一个纯 <span class="title class_">JavaScript</span> 函数，用于将模板转化为 <span class="title class_">Virtual</span> <span class="variable constant_">DOM</span>。</span><br><span class="line">在模板的编译过程中，还会涉及到动态指令、插槽、组件等特殊情况的处理，不同的编译器实现可能存在一些差异，但大体的编译流程是相似的。</span><br><span class="line">通过模板的编译，我们可以将模板转化为可被 <span class="title class_">JavaScript</span> 运行的函数，从而更高效地渲染页面，提高应用的性能。</span><br></pre></td></tr></table></figure>



<h3 id="四-vue3面试题"><a href="#四-vue3面试题" class="headerlink" title="四.vue3面试题"></a>四.vue3面试题</h3><h4 id="1-你了解vue3吗"><a href="#1-你了解vue3吗" class="headerlink" title="1.你了解vue3吗"></a>1.你了解vue3吗</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="title class_">Vue3</span> 于 <span class="number">2020</span> 年 <span class="number">9</span> 月发布</span><br><span class="line"><span class="number">2.</span>它性能更好，体积更小，支持 <span class="title class_">Typescript</span>，并保持了向后兼容</span><br><span class="line"><span class="number">3.</span>它带来了 <span class="title class_">Composition</span> <span class="variable constant_">API</span>、依赖注入、<span class="title class_">Teleport</span>、<span class="title class_">Suspense</span>、v-model 等新特性</span><br><span class="line"><span class="number">4.</span>一般采用 <span class="title class_">Vite</span> 开发构建 <span class="title class_">Vue3</span> 项目</span><br></pre></td></tr></table></figure>

<h4 id="2-你了解vite吗"><a href="#2-你了解vite吗" class="headerlink" title="2.你了解vite吗"></a>2.你了解vite吗</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="title class_">Vite</span> 是 <span class="title class_">Vue3</span> 推荐的构建工具，但不止用于 <span class="title class_">Vue3</span></span><br><span class="line"><span class="number">2.</span><span class="title class_">Vite</span> 冷启动速度快，热更新也很快，并且配置简单</span><br><span class="line"><span class="number">3.</span><span class="title class_">Vite</span> 在开发环境下浏览器原生 esm，因此开发体验更好</span><br><span class="line"><span class="number">4.</span>但是，<span class="title class_">Vite</span> 依然存在白屏问题，生产环境性能提升有限，无法使用 cjs 库等问题</span><br></pre></td></tr></table></figure>

<h4 id="3-vue中如何阻止重复请求"><a href="#3-vue中如何阻止重复请求" class="headerlink" title="3.vue中如何阻止重复请求"></a>3.vue中如何阻止重复请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">//通过定时器做防抖处理</span></span><br><span class="line">效果:当用户连续点击多次同一个按钮,最后一次点击之后,过小段时间后才发起一次请求</span><br><span class="line">原理:每次调用方法后都产生一个定时器,定时器结束以后再发请求,如果重复调用方法,就取消当前的定时器,创建新的定时器,等结束后再发请求,工作当中可以用第三方封装的工具函数例如lodash的debounce方法来简化防抖的代码</span><br><span class="line"> <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="comment">// 调用lodash的防抖方法debounce,实现连续点击按钮多次,0.3秒后调用1次接口</span></span><br><span class="line">        <span class="attr">onClick</span>: _.<span class="title function_">debounce</span>(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">sendPost</span>(&#123;<span class="attr">username</span>:<span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求的结果&#x27;</span>, res.<span class="property">data</span>)</span><br><span class="line">        &#125;, <span class="number">300</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="number">2.</span> <span class="comment">//通过axios请求拦截器取消重复请求</span></span><br><span class="line">通过axios请求拦截器,在每次请求前把请求信息和请求的取消方法放到一个map对象当中,并且判断map对象当中是否已经存在该请求信息的请求,如果存在取消上传请求</span><br></pre></td></tr></table></figure>

<h4 id="4-为什么vue3的v-model丢失了向上封装的可能性"><a href="#4-为什么vue3的v-model丢失了向上封装的可能性" class="headerlink" title="4.为什么vue3的v-model丢失了向上封装的可能性"></a>4.为什么vue3的v-model丢失了向上封装的可能性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>保证数据的可跟踪性，方便调试</span><br></pre></td></tr></table></figure>

<h4 id="5-vue3的新特性"><a href="#5-vue3的新特性" class="headerlink" title="5.vue3的新特性"></a>5.vue3的新特性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>setup 是 <span class="title class_">Vue3</span>.<span class="property">x</span> 新增的一个选项， 他是组件内使用 <span class="title class_">Composition</span> <span class="variable constant_">API</span>的入口。它是最先执行的，位于onbeforCreacte之前</span><br><span class="line"><span class="number">2.</span>组合式api的写法，任何api都需要引入再使用</span><br><span class="line"><span class="number">3.</span>之前我们vue2的响应式变量，需要写在data中，vue3中响应式变量，需要用ref 或reactive声明</span><br><span class="line"><span class="number">4.</span><span class="title class_">Teleport</span>传送门 是一种能够将我们的组件的html结构移动到指定位置的技术，<span class="title class_">Suspense</span>组件 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验</span><br><span class="line"><span class="number">5.</span>vue2中只能有一个根节点，虽然vue3中写法上可以不需要根节点，但其实是用<span class="title class_">Fragment</span>已经设置好了根节点</span><br></pre></td></tr></table></figure>

<h4 id="6-vue2中组件的setup-中，为什么this指针是undefined"><a href="#6-vue2中组件的setup-中，为什么this指针是undefined" class="headerlink" title="6.vue2中组件的setup()中，为什么this指针是undefined"></a>6.vue2中组件的setup()中，为什么this指针是undefined</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为执行setup的时候 <span class="title class_">Vue2</span>的 beforeCreate还没执行 还没有初始化实例</span><br></pre></td></tr></table></figure>

<h4 id="7-vue中的和HTML中的有什么区别"><a href="#7-vue中的和HTML中的有什么区别" class="headerlink" title="7.vue中的和HTML中的有什么区别"></a>7.vue中的<route-link>和HTML中的<a>有什么区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="title class_">Router</span>-link会转化成a标签，但是里面的path属性会转化成路由地址 + 锚链接 ，另外router-link是 vue-router提供的组件</span><br><span class="line"><span class="number">2.</span><span class="variable constant_">HTML</span> 中的 &lt;a&gt; 标签是常规的超链接元素，它可以用于跳转到普通的 <span class="variable constant_">HTML</span> 页面、下载文件或者发送邮箱等。与信使网页不同,使用&lt;a&gt;标签进行页面内路由切换，需要刷新整个页面才能显示新的内容,用户体验上欠缺了许多.</span><br></pre></td></tr></table></figure>

<h4 id="8-vue中，为什么computed定义的方法不能带参数-而methods定义的方法又可以带"><a href="#8-vue中，为什么computed定义的方法不能带参数-而methods定义的方法又可以带" class="headerlink" title="8.vue中，为什么computed定义的方法不能带参数?而methods定义的方法又可以带"></a>8.vue中，为什么computed定义的方法不能带参数?而methods定义的方法又可以带</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>计算属性 有缓存功能，他定义为属性，也就是说 他没有小括号的调用方式，是框架内部实现了 该函数的调用 没有传参数的空间</span><br><span class="line"><span class="number">2.</span>而方法，相当于 一个函数，可以在标签上 使用 调用方式来传值 比如 @click=<span class="string">&quot;test(123)&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="五-html面试题"><a href="#五-html面试题" class="headerlink" title="五.html面试题"></a>五.html面试题</h3><h4 id="1-说说src和herf的区别"><a href="#1-说说src和herf的区别" class="headerlink" title="1.说说src和herf的区别"></a>1.说说src和herf的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">都是用来引用外部的资源</span><br><span class="line"><span class="number">1.</span>src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</span><br><span class="line"><span class="number">2.</span>href： 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</span><br></pre></td></tr></table></figure>

<h4 id="2-对HTML语义化的理解"><a href="#2-对HTML语义化的理解" class="headerlink" title="2.对HTML语义化的理解"></a>2.对HTML语义化的理解</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。</span><br><span class="line">优点：</span><br><span class="line"><span class="number">1.</span>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于<span class="variable constant_">SEO</span>。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</span><br><span class="line"><span class="number">2.</span>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</span><br><span class="line">语义化标签、利于页面内容结构化、利于无<span class="variable constant_">CSS</span>页面可读、利于<span class="variable constant_">SEO</span>、利于代码可读</span><br><span class="line"></span><br><span class="line">在没<span class="variable constant_">CSS</span>样式的情况下，页面整体也会呈现很好的结构效果</span><br><span class="line">代码结构清晰，易于阅读，利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</span><br><span class="line">有利于搜索引擎优化（<span class="variable constant_">SEO</span>），搜索引擎爬虫会根据不同的标签来赋予不同的权重</span><br></pre></td></tr></table></figure>

<h4 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3.DOCTYPE(⽂档类型) 的作⽤"></a>3.DOCTYPE(⽂档类型) 的作⽤</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DOCTYPE</span>是<span class="title class_">HTML5</span>中一种标准通用标记语言的文档类型声明</span><br><span class="line">它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 <span class="variable constant_">CSS</span> 代码甚⾄ <span class="title class_">JavaScript</span> 脚本的解析。它必须声明在<span class="variable constant_">HTML</span>⽂档的第⼀⾏。</span><br></pre></td></tr></table></figure>

<h4 id="4-img的srcset属性的作⽤？"><a href="#4-img的srcset属性的作⽤？" class="headerlink" title="4.img的srcset属性的作⽤？"></a>4.img的srcset属性的作⽤？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</span><br><span class="line">&lt;img src=<span class="string">&quot;image-128.png&quot;</span> srcset=<span class="string">&quot;image-256.png 2x&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#5-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="5. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>5. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="string">&#x27;行内元素有：a b span img input select strong；</span></span><br><span class="line"><span class="string">2.&#x27;</span>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；</span><br><span class="line"><span class="number">3.</span><span class="string">&#x27;空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</span></span><br><span class="line"><span class="string">//常见的有：&lt;br&gt;、&lt;hr&gt;、&lt;img&gt;、&lt;input&gt;、&lt;link&gt;、&lt;meta&gt;；</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h4 id="6-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#6-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="6.title与h1的区别、b与strong的区别、i与em的区别？"></a>6.title与h1的区别、b与strong的区别、i与em的区别？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="string">&#x27;strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</span></span><br><span class="line"><span class="string">2.//title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</span></span><br><span class="line"><span class="string">3.&#x27;</span>i内容展示为斜体，em表示强调的文本</span><br></pre></td></tr></table></figure>

<h4 id="7-head-标签有什么作用，其中什么标签必不可少？"><a href="#7-head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="7.head 标签有什么作用，其中什么标签必不可少？"></a>7.head 标签有什么作用，其中什么标签必不可少？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。</span></span><br><span class="line"><span class="string">文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</span></span><br><span class="line"><span class="string">下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;。</span></span><br><span class="line"><span class="string">//其中 &lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。</span></span><br></pre></td></tr></table></figure>

<h4 id="8-说一下css选择器及优先级"><a href="#8-说一下css选择器及优先级" class="headerlink" title="8.说一下css选择器及优先级"></a>8.说一下css选择器及优先级</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择器</span></span><br><span class="line"><span class="number">1.</span>id选择器(#myid)</span><br><span class="line"><span class="number">2.</span>类选择器(.<span class="property">myclass</span>)</span><br><span class="line"><span class="number">3.</span>属性选择器(a[rel=<span class="string">&quot;external&quot;</span>])</span><br><span class="line"><span class="number">4.</span>伪类选择器(<span class="attr">a</span>:hover, <span class="attr">li</span>:nth-child)</span><br><span class="line"><span class="number">5.</span>标签选择器(div, h1,p)</span><br><span class="line"><span class="number">6.</span>相邻选择器（h1 + p）</span><br><span class="line"><span class="number">7.</span>子选择器(ul &gt; li)</span><br><span class="line"><span class="number">8.</span>后代选择器(li a)</span><br><span class="line"><span class="number">9.</span>通配符选择器(*)</span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级：</span></span><br><span class="line"><span class="number">1.</span>!important</span><br><span class="line"><span class="number">2.</span>内联样式（<span class="number">1000</span>）</span><br><span class="line"><span class="number">3.</span><span class="variable constant_">ID</span>选择器（<span class="number">0100</span>）</span><br><span class="line"><span class="number">4.</span>类选择器/属性选择器/伪类选择器（<span class="number">0010</span>）</span><br><span class="line"><span class="number">5.</span>元素选择器/伪元素选择器（<span class="number">0001</span>）</span><br><span class="line"><span class="number">6.</span>关系选择器/通配符选择器（<span class="number">0000</span>）</span><br><span class="line">带!important 标记的样式属性优先级最高； 样式表的来源相同时： !important &gt; 行内样式&gt;<span class="variable constant_">ID</span>选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</span><br><span class="line">         </span><br><span class="line">   使用!important要谨慎 - 一定要优先考虑使用样式规则的优先级来解决问题而不是 <span class="string">`!important`</span> - 只有在需要覆盖全站或外部 <span class="variable constant_">CSS</span> 的特定页面中使用 <span class="string">`!important`</span> - 永远不要在你的插件中使用 <span class="string">`!important`</span> - 永远不要在全站范围的 <span class="variable constant_">CSS</span> 代码中使用 <span class="string">`!important`</span> 优先级的比较指的是相同的样式属性，不同样式属性优先级比较失效 </span><br><span class="line">          div &#123; </span><br><span class="line">    max-<span class="attr">width</span>: 400px !important;  <span class="comment">//失效</span></span><br><span class="line">     <span class="attr">height</span>: 200px;</span><br><span class="line">     background-<span class="attr">color</span>: tomato;</span><br><span class="line">      <span class="attr">width</span>: 200px; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-说一下层叠上下文"><a href="#8-说一下层叠上下文" class="headerlink" title="8.说一下层叠上下文"></a>8.说一下层叠上下文</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>html中的根元素html本身就具有层叠上下文，称为根层叠上下文</span><br><span class="line"><span class="number">2.</span>普通元素的position属性非<span class="keyword">static</span>，并设置z-index属性，产生层叠上下文</span><br><span class="line"><span class="number">3.</span>css3的新属性也产生层叠上下文</span><br><span class="line">层叠顺序：同一层叠上下文内：z-index &gt; <span class="number">0</span> → z-<span class="attr">index</span>:<span class="number">0</span>,z-<span class="attr">index</span>:auto→inline/inline-block盒子→float浮动盒子→block块级盒子→z-index&lt;<span class="number">0</span> 这样排列的</span><br></pre></td></tr></table></figure>



<h3 id="六-浏览器相关面试题"><a href="#六-浏览器相关面试题" class="headerlink" title="六.浏览器相关面试题"></a>六.浏览器相关面试题</h3><h4 id="1-说一下HTTP状态码"><a href="#1-说一下HTTP状态码" class="headerlink" title="1.说一下HTTP状态码"></a>1.说一下HTTP状态码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 1xx：指示信息类，表示请求已接受，继续处理（临时响应）</span><br><span class="line"><span class="number">2.</span> 2xx：指示成功类，表示请求已成功接受</span><br><span class="line"><span class="number">3.</span> 3xx：指示重定向，表示要完成请求必须进行更近一步的操作</span><br><span class="line"><span class="number">4.</span> 4xx：指示客户端错误，请求有语法错误或请求无法实现</span><br><span class="line"><span class="number">5.</span> 5xx：指示服务器错误，服务器未能实现合法的请求</span><br><span class="line">常见状态码</span><br><span class="line">【<span class="number">403</span>】表示【服务器拒绝执行客户端的请求】</span><br><span class="line">【<span class="number">404</span>】表示【服务器找不到客户端所请求的资源（网页）】</span><br><span class="line">【<span class="number">304</span>】表示【所请求的资源并未修改（命中协商缓存）</span><br><span class="line"><span class="number">500</span>（ <span class="title class_">Internal</span> <span class="title class_">Server</span> <span class="title class_">Error</span>）：服务器遇到了一个未曾预料的状况，导致了它无法完成对请</span><br><span class="line">求的处理</span><br><span class="line"><span class="number">200</span>（ <span class="variable constant_">OK</span>）：请求已成功，请求所希望的响应头或数据体将随此响应返回。</span><br><span class="line"><span class="number">400</span>（ <span class="title class_">Bad</span> <span class="title class_">Request</span>）：请求格式错误。</span><br><span class="line"><span class="number">1</span>) 语义有误，当前请求无法被服务器理解。除非进行 修改，否则客户端不应该重</span><br><span class="line">复提交这个请求；</span><br><span class="line"><span class="number">100</span> =&gt; 正在初始化（一般是看不到的）</span><br><span class="line"><span class="number">101</span> =&gt; 正在切换协议（websocket 浏览器提供的）</span><br><span class="line"><span class="number">202</span> =&gt; 表示接受</span><br><span class="line"><span class="number">301</span> =&gt; 永久重定向/永久转移</span><br><span class="line"><span class="number">302</span> =&gt; 临时重定向/临时转移（一般用来做服务器负载均衡）</span><br><span class="line"><span class="number">304</span> =&gt; 本次获取的内容是读取缓存中的数据，会每次去服务器校验</span><br><span class="line"><span class="number">401</span> =&gt; 未认证，没有登录网站</span><br><span class="line"><span class="number">403</span> =&gt; 禁止访问，没有权限</span><br><span class="line"><span class="number">502</span> =&gt; 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</span><br><span class="line"><span class="number">503</span> =&gt; 服务器超负荷（假设一台服务器只能承受 <span class="number">10000</span> 人，当第 <span class="number">10001</span> 人访问的时候，</span><br><span class="line">如果服务器没有做负载均衡，那么这个人的网络状态码就是 <span class="number">503</span>）</span><br><span class="line"><span class="number">505</span> =&gt; 服务器不支持请求的 <span class="variable constant_">HTTP</span> 协议的版本，无法完成处理。</span><br></pre></td></tr></table></figure>

<h4 id="2-介绍下304过程"><a href="#2-介绍下304过程" class="headerlink" title="2.介绍下304过程"></a>2.介绍下304过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【304】表示【所请求的资源并未修改（命中协商缓存）</span></span><br><span class="line">缓存过期后向服务器发起请求验证缓存是否有效，有效的话则返回<span class="number">304</span>。<span class="number">304</span>多出现在对于静态资源的请求上面。对于静态资源来说：</span><br><span class="line">当浏览器第一次发起请求时（请求头中没有<span class="title class_">If</span>-<span class="title class_">Modified</span>-<span class="title class_">Since</span>），server会在响应中告诉浏览器这个资源最后修改的时间（响应头中的<span class="title class_">Last</span>-<span class="title class_">Modified</span>）。当你再次请求这个资源时，浏览器会询问server这个资源有没有被修改（请求头中<span class="title class_">If</span>-<span class="title class_">Modified</span>-<span class="title class_">Since</span>）。</span><br><span class="line">如果资源没有被修改，server返回<span class="number">304</span>状态码，浏览器使用本地的缓存文件。</span><br></pre></td></tr></table></figure>

<h4 id="3-说一下浏览器强缓存和协商缓存"><a href="#3-说一下浏览器强缓存和协商缓存" class="headerlink" title="3.说一下浏览器强缓存和协商缓存"></a>3.说一下浏览器强缓存和协商缓存</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 <span class="variable constant_">HTTP</span> 头的缓存标识，决定是否缓存结果</span><br><span class="line">浏览器缓存的特点：</span><br><span class="line"><span class="comment">//强缓存：不会向服务器发送请求，直接从缓存中读取资源</span></span><br><span class="line">浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</span><br><span class="line">浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</span><br><span class="line">根据是否需要向服务器重新发起<span class="variable constant_">HTTP</span>请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</span><br><span class="line"><span class="comment">//协商缓存也叫对比缓存</span></span><br><span class="line">协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。如果没有标识，则会对比前后修改的时间，一致则命中协商缓存</span><br><span class="line">协商缓存主要有以下两种情况：</span><br><span class="line">协商缓存生效，返回<span class="number">304</span></span><br><span class="line">协商缓存失效，返回<span class="number">200</span>和请求结果结果</span><br><span class="line"><span class="comment">//两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求</span></span><br></pre></td></tr></table></figure>

<p><strong>浏览器缓存过程</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>浏览器第一次加载资源，服务器返回<span class="number">200</span>，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；</span><br><span class="line"><span class="number">2.</span>下一次加载资源时，先比较当前时间和上一次返回<span class="number">200</span>时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持<span class="title class_">HTTP1</span><span class="number">.1</span>，则用expires判断是否过期）返回<span class="number">200</span>；如果时间过期，则向服务器发送header带有<span class="title class_">If</span>-<span class="title class_">None</span>-<span class="title class_">Match</span>和<span class="title class_">If</span>-<span class="title class_">Modified</span>-<span class="title class_">Since</span>的请求</span><br><span class="line"><span class="number">3.</span>服务器收到请求后，优先根据<span class="title class_">Etag</span>的值判断被请求的文件有没有做修改，<span class="title class_">Etag</span>值一致则没有修改，命中协商缓存，返回<span class="number">304</span>；如果不一致则有改动，直接返回新的资源文件带上新的<span class="title class_">Etag</span>值并返回<span class="number">200</span>；；</span><br><span class="line"><span class="number">4.</span>如果服务器收到的请求没有<span class="title class_">Etag</span>值，则将<span class="title class_">If</span>-<span class="title class_">Modified</span>-<span class="title class_">Since</span>和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回<span class="number">304</span>；不一致则返回新的last-modified和文件并返回<span class="number">200</span>；；</span><br></pre></td></tr></table></figure>

<img src="../image/image-20230204205020605.png" alt="image-20230204205020605" style="zoom:80%;" />

<p><code>详情在浏览器收藏栏</code></p>
<p><strong>刷新对缓存的影响</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）正常操作</span><br><span class="line">定义： 地址栏输入 url ，跳转链接，前进后退等。</span><br><span class="line">对缓存的影响： 强制缓存有效，协商缓存有效。</span><br><span class="line">（<span class="number">2</span>）手动刷新</span><br><span class="line">定义：  <span class="variable constant_">F5</span> ，点击刷新按钮，右击菜单刷新。</span><br><span class="line">对缓存的影响： 强制缓存失效，协商缓存有效。</span><br><span class="line">（<span class="number">3</span>）强制刷新</span><br><span class="line">定义： ctrl + <span class="variable constant_">F5</span> 。</span><br><span class="line">对缓存的影响： 强制缓存失效，协商缓存失效。</span><br></pre></td></tr></table></figure>

<h4 id="4-HTTP1、HTTP2、HTTP3-的区别"><a href="#4-HTTP1、HTTP2、HTTP3-的区别" class="headerlink" title="4.HTTP1、HTTP2、HTTP3 的区别"></a>4.HTTP1、HTTP2、HTTP3 的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="title class_">HTTP1</span><span class="number">.0</span>：</span><br><span class="line">浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个<span class="variable constant_">TCP</span>连接</span><br><span class="line">服务器完成请求处理后立即断开<span class="variable constant_">TCP</span>连接。</span><br><span class="line">简单来讲，每次与服务器交互，都需要新开一个连接</span><br><span class="line"><span class="title class_">HTTP1</span><span class="number">.1</span>：</span><br><span class="line">引入了持久连接，即<span class="variable constant_">TCP</span>连接默认不关闭，在同一个<span class="variable constant_">TCP</span>连接里面，客户端可以同时发送多个请求</span><br><span class="line">虽然允许复用<span class="variable constant_">TCP</span>连接，但是同一个<span class="variable constant_">TCP</span>连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</span><br><span class="line">新增了一些请求方法，新增了一些请求头和响应头</span><br><span class="line"><span class="comment">//缺陷：TCP的慢启动、多条TCP连接竞争带宽和队头阻塞</span></span><br><span class="line"><span class="number">2.</span><span class="title class_">HTTP2</span><span class="number">.0</span>：</span><br><span class="line">采用二进制格式而非文本格式</span><br><span class="line">多路复用，只需一个连接即可实现并行</span><br><span class="line">使用报头压缩，降低开销服务器推送</span><br><span class="line"><span class="comment">//缺陷：TCP的队头阻塞  TCP建立连接的延时</span></span><br><span class="line"><span class="number">3.</span><span class="title class_">HTTP3</span><span class="number">.0</span>：</span><br><span class="line">是 <span class="variable constant_">HTTP</span>/<span class="number">3</span> 中的底层支撑协议，该协议基于 <span class="variable constant_">UDP</span>，又取了 <span class="variable constant_">TCP</span> 中的精华，实现了即快又可靠的协议。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-get和post的区别"><a href="#5-get和post的区别" class="headerlink" title="5.get和post的区别"></a>5.get和post的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>针对数据操作的类型不同.<span class="property">GET</span>一般对数据进行查询(但并不代表get只能用于获取数据，只是这是我们的一种约定，只要后端支持，post也能用于获取数据)，<span class="variable constant_">POST</span>主要对数据进行增删改！简单说，<span class="variable constant_">GET</span>是只读，<span class="variable constant_">POST</span>是写。</span><br><span class="line"><span class="number">2.</span>参数大小不同. <span class="variable constant_">GET</span>请求在<span class="variable constant_">URL</span>中传送的参数是有长度的限制，最大是<span class="number">2000</span>多个字符，(我记得谷歌的最大是<span class="number">8000</span>多个字符)而<span class="variable constant_">POST</span>没有限制</span><br><span class="line"><span class="number">3.</span>安全性不同. <span class="variable constant_">GET</span>参数通过<span class="variable constant_">URL</span>传递，会暴露，不安全；<span class="variable constant_">POST</span>放在请求体中，相对更安全</span><br><span class="line"><span class="number">4.</span>浏览器回退表现不同 <span class="variable constant_">GET</span>在浏览器回退时是无害的，而<span class="variable constant_">POST</span>会再次提交请求</span><br><span class="line"><span class="number">5.</span>浏览器对请求地址的处理不同 <span class="variable constant_">GET</span>请求地址会被浏览器主动缓存(符合http缓存，不会改变服务器端的资源)，而<span class="variable constant_">POST</span>不会，除非手动设置</span><br><span class="line"><span class="number">6.</span>浏览器对响应的处理不同<span class="variable constant_">GET</span>请求参数会被完整的保留在浏览器历史记录里，而<span class="variable constant_">POST</span>中的参数不会被保留</span><br></pre></td></tr></table></figure>

<h4 id="6-说一下WebSocket协议"><a href="#6-说一下WebSocket协议" class="headerlink" title="6.说一下WebSocket协议"></a>6.说一下WebSocket协议</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>实现原理： 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。</span><br><span class="line"><span class="title class_">Websocket</span> 协议与 <span class="variable constant_">HTTP</span> 协议没有关系，它是一个建立在 <span class="variable constant_">TCP</span> 协议上的全新协议，为了兼容 <span class="variable constant_">HTTP</span> 握手规范，在握手阶段依然使用 <span class="variable constant_">HTTP</span> 协议，握手完成之后，数据通过 <span class="variable constant_">TCP</span> 通道进行传输。</span><br><span class="line"><span class="title class_">Websoket</span> 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。</span><br><span class="line"><span class="number">2.</span>优点： 双向通信。客户端和服务端双方 都可以主动发起通讯。 没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。 数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。 传输效率高。因为只需要一次连接，所以数据传输效率高。</span><br><span class="line"><span class="number">3.</span>缺点： 长连接需要后端处理业务的代码更稳定，推送消息相对复杂； 兼容性，<span class="title class_">WebSocket</span> 只支持 <span class="title class_">IE10</span> 及其以上版本。 服务器长期维护长连接需要一定的成本，各个浏览器支持程度不一； 【需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小】</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在index.html中直接写WebSocket，设置服务端的端口号为 9999</span></span><br><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:9999&#x27;</span>);</span><br><span class="line"><span class="comment">// 在客户端与服务端建立连接后触发</span></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Connection open.&quot;</span>); </span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在服务端给客户端发来消息的时候触发</span></span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);       <span class="comment">// 打印的是MessageEvent对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);  <span class="comment">// 打印的是收到的消息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在客户端与服务端建立关闭后触发</span></span><br><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h4 id="7-说一下DNS协议"><a href="#7-说一下DNS协议" class="headerlink" title="7.说一下DNS协议"></a>7.说一下DNS协议</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DNS</span>也叫域名系统，当我们输入url，一般输入的是英文，但浏览器识别数字的那种ip地址，则<span class="variable constant_">DNS</span>负责把域名和 <span class="variable constant_">IP</span> 地址做一一映射关系。这套域名映射为 <span class="variable constant_">IP</span> 的系统就叫做“域名系统”，简称 <span class="variable constant_">DNS</span></span><br></pre></td></tr></table></figure>

<p><strong>什么是分布式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个世界上没有一台 <span class="variable constant_">DNS</span> 服务器拥有因特网上所有主机的映射，每台 <span class="variable constant_">DNS</span> 只负责部分映射</span><br></pre></td></tr></table></figure>

<p><strong>什么是层次</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DNS</span> 服务器有 <span class="number">3</span> 种类型：根 <span class="variable constant_">DNS</span> 服务器、顶级域（<span class="title class_">Top</span>-<span class="title class_">Level</span> <span class="title class_">Domain</span>, <span class="variable constant_">TLD</span>）<span class="variable constant_">DNS</span> 服务器和权威 <span class="variable constant_">DNS</span> 服务器。它们的层次结构如下图所示：</span><br></pre></td></tr></table></figure>

<img src="../image//image-20230205102417092.png" alt="image-20230205102417092" style="zoom:80%;" />

<p><strong>DNS服务器介绍</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>根 <span class="variable constant_">DNS</span> 服务器</span><br><span class="line">首先我们要明确根域名是什么，比如 www.<span class="property">baidu</span>.<span class="property">com</span>，有些同学可能会误以为 com 就是根域名，其实 com 是顶级域名，www.<span class="property">baidu</span>.<span class="property">com</span> 的完整写法是 www.<span class="property">baidu</span>.<span class="property">com</span>.，最后的这个 . 就是根域名。</span><br><span class="line">根 <span class="variable constant_">DNS</span> 服务器的作用是什么呢？就是管理它的下一级，也就是顶级域 <span class="variable constant_">DNS</span> 服务器。通过询问根 <span class="variable constant_">DNS</span> 服务器，我们可以知道一个主机名对应的顶级域 <span class="variable constant_">DNS</span> 服务器的 <span class="variable constant_">IP</span> 是多少，从而继续向顶级域 <span class="variable constant_">DNS</span> 服务器发起查询请求。</span><br><span class="line"><span class="number">2.</span>顶级域 <span class="variable constant_">DNS</span> 服务器</span><br><span class="line">除了前面提到的 com 是顶级域名，常见的顶级域名还有 cn、org、edu 等。顶级域 <span class="variable constant_">DNS</span> 服务器，也就是 <span class="variable constant_">TLD</span>，提供了它的下一级，也就是权威 <span class="variable constant_">DNS</span> 服务器的 <span class="variable constant_">IP</span> 地址。</span><br><span class="line"><span class="number">3.</span>权威 <span class="variable constant_">DNS</span> 服务器</span><br><span class="line">权威 <span class="variable constant_">DNS</span> 服务器可以返回主机 - <span class="variable constant_">IP</span> 的最终映射。</span><br><span class="line"><span class="number">4.</span>本地<span class="variable constant_">DNS</span>服务器</span><br><span class="line">严格来说，本地 <span class="variable constant_">DNS</span> 服务器并不属于 <span class="variable constant_">DNS</span> 的层次结构，但它对 <span class="variable constant_">DNS</span> 层次结构是至关重要的 每个 <span class="variable constant_">ISP</span> 都有一台本地 <span class="variable constant_">DNS</span> 服务器，比如一个居民区的 <span class="variable constant_">ISP</span>、一个大学的 <span class="variable constant_">ISP</span>、一个机构的 <span class="variable constant_">ISP</span>，都有一台或多台本地 <span class="variable constant_">DNS</span> 服务器。当主机发出 <span class="variable constant_">DNS</span> 请求时，该请求被发往本地 <span class="variable constant_">DNS</span> 服务器，本地 <span class="variable constant_">DNS</span> 服务器起着代理的作用，并负责将该请求转发到 <span class="variable constant_">DNS</span> 服务器层次结构中。</span><br></pre></td></tr></table></figure>

<p><strong>递归查询、迭代查询</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>首先，主机 m.<span class="property">n</span>.<span class="property">com</span> 向它的本地 <span class="variable constant_">DNS</span> 服务器发送一个 <span class="variable constant_">DNS</span> 查询报文，其中包含期待被转换的主机名 a.<span class="property">b</span>.<span class="property">com</span>；</span><br><span class="line"><span class="number">2.</span>本地 <span class="variable constant_">DNS</span> 服务器将该报文转发到根 <span class="variable constant_">DNS</span> 服务器；</span><br><span class="line"><span class="number">3.</span>该根 <span class="variable constant_">DNS</span> 服务器注意到 com 前缀，便向本地 <span class="variable constant_">DNS</span> 服务器返回 com 对应的顶级域 <span class="variable constant_">DNS</span> 服务器（<span class="variable constant_">TLD</span>）的 <span class="variable constant_">IP</span> 地址列表。</span><br><span class="line"><span class="number">4.</span>意思就是，我不知道 a.<span class="property">b</span>.<span class="property">com</span> 的 <span class="variable constant_">IP</span>，不过这些 <span class="variable constant_">TLD</span> 服务器可能知道，你去问他们吧；</span><br><span class="line"><span class="number">5.</span>本地 <span class="variable constant_">DNS</span> 服务器则向其中一台 <span class="variable constant_">TLD</span> 服务器发送查询报文；</span><br><span class="line">该 <span class="variable constant_">TLD</span> 服务器注意到 b.<span class="property">com</span> 前缀，便向本地 <span class="variable constant_">DNS</span> 服务器返回权威 <span class="variable constant_">DNS</span> 服务器的 <span class="variable constant_">IP</span> 地址。</span><br><span class="line"><span class="number">6.</span>意思就是，我不知道 a.<span class="property">b</span>.<span class="property">com</span> 的 <span class="variable constant_">IP</span>，不过这些权威服务器可能知道，你去问他们吧；</span><br><span class="line"><span class="number">7.</span>本地 <span class="variable constant_">DNS</span> 服务器又向其中一台权威服务器发送查询报文；</span><br><span class="line">终于，该权威服务器返回了 a.<span class="property">b</span>.<span class="property">com</span> 的 <span class="variable constant_">IP</span> 地址；</span><br><span class="line"><span class="number">8.</span>本地 <span class="variable constant_">DNS</span> 服务器将 a.<span class="property">b</span>.<span class="property">com</span> 跟 <span class="variable constant_">IP</span> 地址的映射返回给主机 m.<span class="property">n</span>.<span class="property">com</span>，m.<span class="property">n</span>.<span class="property">com</span> 就可以用该 <span class="variable constant_">IP</span> 向 a.<span class="property">b</span>.<span class="property">com</span> 发送请求啦。</span><br></pre></td></tr></table></figure>

<img src="../image/image-20230205104035365.png" alt="image-20230205104035365" style="zoom:80%;" />

<p><strong>前端的DNS优化</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以在html页面头部写入dns缓存地址</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;x-dns-prefetch-control&quot;</span> content=<span class="string">&quot;on&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://bdimg.share.baidu.com&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="8-浏览器的主要功能"><a href="#8-浏览器的主要功能" class="headerlink" title="8.浏览器的主要功能"></a>8.浏览器的主要功能</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">是向服务器发出请求，在浏览器窗口中展示所选择的网络资源。这里所说的资源一般是指 <span class="variable constant_">HTML</span> 文档，也可以是 <span class="variable constant_">PDF</span>、图片或其他的类型。资源的位置由用户使用 <span class="variable constant_">URI</span>（统一资源标示符）指定。</span><br><span class="line">浏览器的主要组成部分是什么？</span><br><span class="line"><span class="number">1</span>、用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。</span><br><span class="line"><span class="number">2</span>、浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</span><br><span class="line"><span class="number">3</span>、呈现引擎 - 负责显示请求的内容。如果请求的内容是 <span class="variable constant_">HTML</span>，它就负责解析 <span class="variable constant_">HTML</span> 和 <span class="variable constant_">CSS</span> 内容，并将解析后的内容显示在屏幕上。</span><br><span class="line"><span class="number">4</span>、网络 - 用于网络调用，比如 <span class="variable constant_">HTTP</span> 请求。其接口与平台无关，并为所有平台提供底层实现。</span><br><span class="line"><span class="number">5</span>、用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面法。</span><br><span class="line"><span class="number">6</span>、<span class="title class_">JavaScript</span> 解释器。用于解析和执行 <span class="title class_">JavaScript</span> 代码。</span><br><span class="line"><span class="number">7</span>、数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 <span class="title class_">Cookie</span>。</span><br></pre></td></tr></table></figure>

<h4 id="9-从用户输入url到页面展示的过程"><a href="#9-从用户输入url到页面展示的过程" class="headerlink" title="9.从用户输入url到页面展示的过程"></a>9.从用户输入url到页面展示的过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">用户输入url   地址栏判断用户输入的内容是搜索内容还是请求的url ，如果是搜索内容，使用默认搜索引擎，合并带搜索关键字的<span class="variable constant_">URL</span></span><br><span class="line">如果是请求的url，加上协议，拼接成完整的url</span><br><span class="line"><span class="number">1.</span>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 <span class="variable constant_">DNS</span> 解析，以获取请求域名的服务器 <span class="variable constant_">IP</span> 地址。如果请求协议是 <span class="variable constant_">HTTPS</span>，那么还需要建立 <span class="variable constant_">TLS</span> 连接。</span><br><span class="line"><span class="number">2.</span>接下来就是利用 <span class="variable constant_">IP</span> 地址和服务器建立 <span class="variable constant_">TCP</span> 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 <span class="title class_">Cookie</span> 等数据附加到请求头中，然后向服务器发送构建的请求信息。</span><br><span class="line"><span class="number">3.</span>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。） 在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 <span class="number">301</span> 或者 <span class="number">302</span>，那么说明服务器需要浏览器重定向到其他 <span class="variable constant_">URL</span>。这时网络进程会从响应头的 <span class="title class_">Location</span> 字段里面读取重定向的地址，然后再发起新的 <span class="variable constant_">HTTP</span> 或者 <span class="variable constant_">HTTPS</span> 请求，一切又重头开始了</span><br><span class="line"><span class="number">4.</span>提交文档</span><br><span class="line">浏览器进程将网络进程接收到的 <span class="variable constant_">HTML</span> 数据提交给渲染进程</span><br><span class="line"><span class="number">5.</span>渲染阶段</span><br><span class="line"><span class="number">5.1</span>构建 <span class="variable constant_">DOM</span> 树</span><br><span class="line"><span class="number">5.2</span>样式计算</span><br><span class="line">  <span class="number">1.</span>把 <span class="variable constant_">CSS</span> 转换为浏览器能够理解的结构 -  styleSheets</span><br><span class="line">  <span class="number">2.</span>转换样式表中的属性值，使其标准化    --div &#123;font-<span class="attr">weight</span>: bold&#125;  把bold转化为<span class="number">700</span>，字符串的颜色转化为数字</span><br><span class="line">  <span class="number">3.</span>计算出 <span class="variable constant_">DOM</span> 树中每个节点的具体样式</span><br><span class="line"><span class="number">5.3</span>布局阶段</span><br><span class="line"><span class="number">1.</span>创建布局树 </span><br><span class="line"><span class="number">2.</span>布局计算   <span class="comment">//计算每个节点在页面的位置</span></span><br><span class="line"><span class="number">5.4</span>分层</span><br><span class="line"><span class="number">1.</span>对布局树进行分层，并生成分层树。</span><br><span class="line"><span class="number">5.5</span>绘制</span><br><span class="line"><span class="number">1.</span>调用<span class="variable constant_">GPU</span>进程为每个图层生成绘制列表，并将其提交到合成线程</span><br><span class="line"><span class="number">5.6</span>分块、光栅化</span><br><span class="line"><span class="number">1.</span> 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图</span><br><span class="line"><span class="number">5.7</span>合成</span><br><span class="line">合成线程发送绘制图块命令<span class="title class_">DrawQuad</span>给浏览器进程。</span><br><span class="line"><span class="number">6.</span>浏览器</span><br><span class="line"><span class="number">1.</span>浏览器进程根据 <span class="title class_">DrawQuad</span> 消息生成页面，并显示到显示器上</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 面试套话：</span><br><span class="line">“检查缓存、先解析<span class="variable constant_">URL</span>、然后<span class="variable constant_">DNS</span>域名解析、再发起<span class="variable constant_">HTTP</span>请求建立<span class="variable constant_">TCP</span>连接、服务端响应返回页面资源进行渲染、然后断开<span class="variable constant_">TCP</span>连接”</span><br><span class="line"><span class="number">2</span> 详细过程：</span><br><span class="line"><span class="number">1</span>、（找）<span class="variable constant_">DNS</span>解析 -&gt; 寻找哪台机器上有你需要资源 根据网址找<span class="variable constant_">IP</span></span><br><span class="line"><span class="number">2</span>、<span class="variable constant_">TCP</span>连接 -&gt; 客户端和服务器，<span class="variable constant_">TCP</span>作为其传输层协议</span><br><span class="line"><span class="number">3</span>、发送<span class="variable constant_">HTTP</span>请求 -&gt; <span class="variable constant_">HTTP</span>报文是包裹在<span class="variable constant_">TCP</span>报文中发送的 请求行，请求报头，请求正文</span><br><span class="line"><span class="number">4</span>、服务器处理请求并返回<span class="variable constant_">HTTP</span>报文 -&gt; 状态码,响应报头和响应报文。</span><br><span class="line"><span class="number">5</span>、浏览器解析渲染页面 -&gt; 浏览器在收到<span class="variable constant_">HTML</span>,<span class="variable constant_">CSS</span>,<span class="variable constant_">JS</span>文件后依次渲染</span><br><span class="line"><span class="number">6</span>、连接结束 -&gt; 断开<span class="variable constant_">TCP</span>连接 四次挥手</span><br></pre></td></tr></table></figure>

<h4 id="10-说一下web攻击有哪些"><a href="#10-说一下web攻击有哪些" class="headerlink" title="10.说一下web攻击有哪些"></a>10.说一下web攻击有哪些</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XSS(跨站脚本攻击)</span></span><br><span class="line">是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当用户登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息</span><br><span class="line"><span class="comment">//CSRF（跨站请求伪造</span></span><br><span class="line">：攻击者诱导用户进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用用户在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</span><br><span class="line"><span class="title class_">Sql</span> 注入攻击，是通过将恶意的 <span class="title class_">Sql</span>查询或添加语句插入到应用的输入参数中，再在后台 <span class="title class_">Sql</span>服务器上解析执行进行的攻击</span><br><span class="line"><span class="variable constant_">XSS</span>避免方式：</span><br><span class="line"><span class="number">1</span>、url参数使用<span class="built_in">encodeURIComponent</span>方法转义</span><br><span class="line"><span class="number">2</span>、尽量不是有<span class="title class_">InnerHtml</span>插入<span class="variable constant_">HTML</span>内容</span><br><span class="line"><span class="number">3</span>、使用特殊符号、标签转义符。</span><br><span class="line"><span class="variable constant_">CSRF</span>避免方式：</span><br><span class="line"><span class="number">1</span>、添加验证码</span><br><span class="line"><span class="number">2</span>、使用token 或( 把token 隐藏在 http 的 head 头中。本质上和下面没有区别)</span><br><span class="line">  <span class="number">2.1</span>服务端给用户生成一个token，加密后传递给用户</span><br><span class="line">  <span class="number">2.2</span>用户在提交请求时，需要携带这个token</span><br><span class="line">  <span class="number">2.3</span>服务端验证token是否正确</span><br><span class="line">  <span class="number">3.</span><span class="title class_">Referer</span>验证</span><br><span class="line"><span class="title class_">Referer</span> 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截</span><br><span class="line"><span class="comment">//DDoS又叫分布式拒绝服务</span></span><br><span class="line">其原理就是利用大量的请求造成资源过载，导致服务不可用。</span><br><span class="line"><span class="title class_">DDos</span> 避免方式：</span><br><span class="line"><span class="number">1</span>、限制单<span class="variable constant_">IP</span>请求频率。(<span class="variable constant_">DNS</span>通过监控分析异常流量，限制其请求频率)</span><br><span class="line"><span class="number">2</span>、防火墙等防护设置禁止<span class="variable constant_">ICMP</span>包等</span><br><span class="line"><span class="number">3</span>、检查特权端口的开放</span><br></pre></td></tr></table></figure>

<p><strong>CSRF 和 XSS 的区别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>区别一：</span><br><span class="line"><span class="variable constant_">CSRF</span> ：需要用户先登录网站 A ，获取 cookie</span><br><span class="line"><span class="variable constant_">XSS</span> ：不需要登录。</span><br><span class="line"><span class="number">2.</span>区别二：（原理的区别）</span><br><span class="line"><span class="variable constant_">CSRF</span> ：是利用网站 A 本身的漏洞，去请求网站 A 的 api 。</span><br><span class="line"><span class="variable constant_">XSS</span> ：是向网站 A 注入 <span class="variable constant_">JS</span> 代码，然后执行 <span class="variable constant_">JS</span> 里的代码，篡改网站 A 的内容。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="11-说一下ajax原理"><a href="#11-说一下ajax原理" class="headerlink" title="11.说一下ajax原理"></a>11.说一下ajax原理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">    btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 1.实例化异步对象</span></span><br><span class="line">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">      <span class="comment">// 2.设置请求的 地址 和方法</span></span><br><span class="line">      xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://ajax-api.itheima.net/api/news&#x27;</span>)</span><br><span class="line">      <span class="comment">// 3.注册回调函数 服务器响应内容回来之后触发</span></span><br><span class="line">      xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">response</span>))</span><br><span class="line">        <span class="comment">// console.dir(xhr)</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 4.发送请求</span></span><br><span class="line">      xhr.<span class="title function_">send</span>()</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="number">1.</span>创建 <span class="title class_">Ajax</span>的核心对象 <span class="title class_">XMLHttpRequest</span>对象</span><br><span class="line"><span class="number">2.</span>通过 <span class="title class_">XMLHttpRequest</span> 对象的 <span class="title function_">open</span>() 方法与服务端建立连接</span><br><span class="line"><span class="number">3.</span>构建请求所需的数据内容，并通过<span class="title class_">XMLHttpRequest</span> 对象的 <span class="title function_">send</span>() 方法发送给服务器端</span><br><span class="line"><span class="number">4.</span>通过 <span class="title class_">XMLHttpRequest</span> 对象提供的 onreadystatechange  或load 事件监听服务器端你的通信状态</span><br><span class="line"><span class="number">5.</span>接受并处理服务端向客户端响应的数据结果</span><br><span class="line"><span class="number">6.</span>将处理结果更新到 <span class="variable constant_">HTML</span>页面中</span><br></pre></td></tr></table></figure>

<h4 id="12-说一下前端性能优化"><a href="#12-说一下前端性能优化" class="headerlink" title="12.说一下前端性能优化"></a>12.说一下前端性能优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、减少http请求数； <span class="number">2</span> 、图片优化； <span class="number">3</span>、使用<span class="variable constant_">CDN</span>； <span class="number">4</span>、开启<span class="variable constant_">GZIP</span>； <span class="number">5</span>、构建优化；</span><br><span class="line"><span class="number">1.</span> 减少http请求数</span><br><span class="line">(<span class="number">1</span>）合并图片。当图片较多时，可以合并为一张大图，从而减少http请求数。</span><br><span class="line">(<span class="number">2</span>）合并压缩css样式表和js脚本。</span><br><span class="line">一般我们会把css样式表文件放到文件的头部。比如，放到标签中，这样可以让<span class="variable constant_">CSS</span>样式表尽早地完成下载。对应js脚本文件，一般我们把他放到页面的尾部。</span><br><span class="line">(<span class="number">3</span>）充分利用缓存。</span><br><span class="line">可以在html页面头部写入dns缓存地址</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;x-dns-prefetch-control&quot;</span> content=<span class="string">&quot;on&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://bdimg.share.baidu.com&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="number">2.</span> 图片优化</span><br><span class="line">(<span class="number">1</span>）尽可能的使用<span class="variable constant_">PNG</span>格式的图片，它相对来说体积较小。</span><br><span class="line">(<span class="number">2</span>）图片的延迟加载，也叫做懒加载。</span><br><span class="line"><span class="number">3.</span> 使用<span class="variable constant_">CDN</span></span><br><span class="line"><span class="variable constant_">CDN</span>即内容分发网络，可以使用户就近取得所需内容，解决网络拥挤的状况，提高用户访问网站的响应速度。</span><br><span class="line"><span class="number">4.</span> 开启<span class="variable constant_">GZIP</span></span><br><span class="line"><span class="variable constant_">GZIP</span>即数据压缩，用于压缩使用<span class="title class_">Internet</span>传输的所有文本资源。开启<span class="variable constant_">GZIP</span>的方法很简单，到对应的web服务配置文件中设置一下即可。以<span class="title class_">Apache</span>为例，在配置文件httpd.<span class="property">conf</span>中添加。</span><br><span class="line"><span class="number">5.</span> 构建优化</span><br><span class="line">使用 <span class="title class_">Tree</span>-shaking、<span class="title class_">Scope</span> hoisting、<span class="title class_">Code</span>-splitting</span><br><span class="line"><span class="title class_">Tree</span>-shaking是一种在构建过程中清除无用代码的技术。使用<span class="title class_">Tree</span>-shaking可以减少构建后文件的体积。</span><br></pre></td></tr></table></figure>

<h4 id="13-页面渲染优化"><a href="#13-页面渲染优化" class="headerlink" title="13.页面渲染优化"></a>13.页面渲染优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="variable constant_">HTML</span>文档结构层次尽量少，最好不深于六层；</span><br><span class="line"><span class="number">2.</span>脚本尽量后放，放在&lt;/body&gt;前即可；</span><br><span class="line"><span class="number">3.</span>少量首屏样式内联放在标签内；</span><br><span class="line"><span class="number">4.</span>样式结构层次尽量简单；不要嵌套太多，尽量不要超过三层，少用标签选择器，后代选择器，否则渲染阶段，计算样式很耗性能，尽量使用<span class="keyword">class</span></span><br><span class="line"><span class="number">5.</span>在脚本中尽量减少<span class="variable constant_">DOM</span>操作，尽量缓存访问<span class="variable constant_">DOM</span>的样式信息，避免过度触发回流；</span><br><span class="line">减少通过<span class="title class_">JavaScript</span>代码修改元素样式，尽量使用修改<span class="keyword">class</span>名方式操作样式或动画；</span><br><span class="line">重排与重绘的代价非常昂贵。如果操作需要进行多次重排与重绘，建议先让元素脱离文档流，处理完毕后再让元素回归文档流，这样浏览器只会进行两次重排与重绘（脱离时和回归时）。</span><br><span class="line"><span class="number">6.</span>善于使用事件委托</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>流程控制优化</span><br><span class="line">避免使用<span class="keyword">for</span>...<span class="keyword">in</span>（它能枚举到原型，所以很慢）</span><br><span class="line"><span class="number">2.</span>交互优化</span><br><span class="line"><span class="number">2.1</span> 异步无阻塞加载<span class="variable constant_">JS</span></span><br><span class="line">jS的加载与执行会阻塞页面渲染，可以将<span class="title class_">Script</span>标签放到页面的最底部。但是更好的做法是异步无阻塞加载<span class="variable constant_">JS</span>。有多种无阻塞加载<span class="variable constant_">JS</span>的方法：defer、<span class="keyword">async</span>、动态创建script标签、使用<span class="variable constant_">XHR</span>异步请求<span class="variable constant_">JS</span>代码并注入到页面。</span><br><span class="line">但更推荐的做法是使用defer或<span class="keyword">async</span>。如果使用defer或<span class="keyword">async</span>请将<span class="title class_">Script</span>标签放到head标签中，以便让浏览器更早地发现资源并在后台线程中解析并开始加载<span class="variable constant_">JS</span>。</span><br><span class="line"><span class="number">2.2</span>   使用<span class="title class_">Intersection</span> <span class="title class_">Observer</span>实现懒加载</span><br><span class="line">懒加载是一个比较常用的性能优化手段，下面列出了一些常用的做法：</span><br><span class="line">可以通过<span class="title class_">Intersection</span> <span class="title class_">Observer</span>延迟加载图片、视频、广告脚本、或任何其他资源。</span><br><span class="line">可以先加载低质量或模糊的图片，当图片加载完毕后再使用完整版图片替换它。</span><br><span class="line"><span class="number">3.</span>优先加载关键的<span class="variable constant_">CSS</span></span><br><span class="line"><span class="variable constant_">CSS</span>资源的加载对浏览器渲染的影响很大，默认情况下浏览器只有在完成&lt;head&gt;标签中<span class="variable constant_">CSS</span>的加载与解析之后才会渲染页面。如果<span class="variable constant_">CSS</span>文件过大，用户就需要等待很长的时间才能看到渲染结果。针对这种情况可以将首屏渲染必须用到的<span class="variable constant_">CSS</span>提取出来内嵌到&lt;head&gt;中，然后再将剩余部分的<span class="variable constant_">CSS</span>用异步的方式加载。可以通过<span class="title class_">Critical</span>做到这一点。</span><br><span class="line"><span class="number">4.</span>构建优化</span><br><span class="line"><span class="number">4.1</span>使用预编译</span><br><span class="line">拿<span class="title class_">Vue</span>举例，如果您使用单文件组件开发项目，组件会在编译阶段将模板编译为渲染函数。最终代码被执行时可以直接执行渲染函数进行渲染。而如果您没有使用单文件组件预编译代码，而是在网页中引入vue.<span class="property">min</span>.<span class="property">js</span>，那么应用在运行时需要先将模板编译成渲染函数，然后再执行渲染函数进行渲染。相比预编译，多了模板编译的步骤，所以会浪费很多性能</span><br><span class="line"><span class="number">4.2</span>服务端渲染(ssR)</span><br><span class="line">单页应用需要等<span class="variable constant_">JS</span>加载完毕后在前端渲染页面，也就是说在<span class="variable constant_">JS</span>加载完毕并开始执行渲染操作前的这段时间里浏览器会产生白屏。</span><br><span class="line">服务端渲染（<span class="title class_">Server</span> <span class="title class_">Side</span> <span class="title class_">Render</span>，简称<span class="variable constant_">SSR</span>）的意义在于弥补主要内容在前端渲染的成本，减少白屏时间，提升首次有效绘制的速度。可以使用服务端渲染来获得更快的首次有效绘制。</span><br><span class="line">比较推荐的做法是：使用服务端渲染静态<span class="variable constant_">HTML</span>来获得更快的首次有效绘制，一旦<span class="title class_">JavaScript</span>加载完毕再将页面接管下来。</span><br><span class="line"><span class="number">4.3</span>使用<span class="variable constant_">HTTP</span>缓存头</span><br></pre></td></tr></table></figure>



<h4 id="14-如何理解CDN？实现原理"><a href="#14-如何理解CDN？实现原理" class="headerlink" title="14.如何理解CDN？实现原理"></a>14.如何理解CDN？实现原理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内容分发网络：</span><br><span class="line">构建在现有网络基础之上的智能虚拟网络，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</span><br><span class="line"><span class="variable constant_">CDN</span> 的关键技术主要有内容存储和分发技术。简单来讲，<span class="variable constant_">CDN</span>就是根据用户位置分配最近的资源。</span><br><span class="line">应用<span class="variable constant_">CDN</span>后，<span class="variable constant_">DNS</span> 返回的不再是 <span class="variable constant_">IP</span> 地址，而是一个<span class="title function_">CNAME</span>(<span class="title class_">Canonical</span> <span class="title class_">Name</span> ) 别名记录，指向<span class="variable constant_">CDN</span>的全局负载均衡。</span><br><span class="line"><span class="variable constant_">CNAME</span>实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是<span class="variable constant_">CDN</span>实现的关键</span><br></pre></td></tr></table></figure>

<h4 id="15-说一下跨域以及解决方法"><a href="#15-说一下跨域以及解决方法" class="headerlink" title="15.说一下跨域以及解决方法"></a>15.说一下跨域以及解决方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">跨域：触发跨域条件：</span><br><span class="line"><span class="number">1.</span>在浏览器当中， <span class="number">2.</span>请求后端接口 <span class="number">3.</span>触发了浏览器的同源策略</span><br><span class="line">是由浏览器的同源策略造成的,不同源则跨域</span><br><span class="line">同源策略,是浏览器对 <span class="title class_">JavaScript</span> 实施的安全策略，浏览器为了保证网页的安全，只要协议、域名、端口有任何一个不同，都被当作是不同的域。</span><br><span class="line">跨域原理，即是通过各种方式，避开浏览器的安全限制</span><br><span class="line"></span><br><span class="line">解决方案</span><br><span class="line"><span class="number">1.</span><span class="title class_">JSON</span>P</span><br><span class="line">ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 <span class="title class_">JSON</span> 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</span><br><span class="line">步骤：</span><br><span class="line">① 去创建一个 script</span><br><span class="line">② script 的 src 属性设置接口地址</span><br><span class="line">③ 接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</span><br><span class="line">④ 通过定义函数名去接受返回的数据</span><br><span class="line"><span class="comment">//动态创建 script</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置 script 的 src 属性，并设置请求地址</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3000/?callback=getData&#x27;</span>;</span><br><span class="line"><span class="comment">// 让 script 生效</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line"></span><br><span class="line">缺点：<span class="title class_">JSON</span>P 只支持 get，因为 script 标签只能使用 get 请求； <span class="title class_">JSON</span>P 需要后端配合返回指定格式的数据 设置响应头返回文档类型，应该设置成javascript。</span><br><span class="line">为什么jsonp中的src不受同源跨域的影响</span><br><span class="line">这个脚本是由A主机的<span class="variable constant_">HTML</span>文件的嵌入的script标签发起请求获取的，因此这个脚本的来源是属于A主机的。jsonp的script标签请求回来的资源与当前域是相同的域，因此不受同源策略的影响</span><br><span class="line"><span class="number">2.</span><span class="variable constant_">CORS</span></span><br><span class="line">使用额外的 <span class="variable constant_">HTTP</span> 头来告诉浏览器 让运行在一个 origin上的<span class="title class_">Web</span>应用被准许访问来自不同源服务器上的指定的资源。服务器设置对<span class="variable constant_">CORS</span>的支持原理：服务器设置<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span> <span class="variable constant_">HTTP</span>响应头之后，浏览器将会允许跨域请求</span><br><span class="line"><span class="number">3.</span>proxy代理+ <span class="title class_">Nginx</span></span><br><span class="line">nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。</span><br><span class="line">跨域问题的产生是因为浏览器的同源政策造成的，但是服务器与服务器之间的数据交换是没有这个限制。</span><br><span class="line">反向代理就是采用这种方式，建立一个虚拟的代理服务器来接收 internet 上的链接请求，然后转发给内部网络上的服务器，并将从服务器上得到的结果，返回给 internet 上请求链接的客户端。现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理</span><br><span class="line"><span class="number">4.</span><span class="variable language_">window</span>.<span class="title function_">postMessage</span>() 利用h5新特性<span class="variable language_">window</span>.<span class="title function_">postMessage</span>()</span><br><span class="line">跨域场景：前后端分离式开发、调用第三方接口</span><br><span class="line"><span class="number">5.</span><span class="title class_">Vue</span> <span class="variable constant_">CLI</span> 中的代理配置：开发环境下可以通过 vue.<span class="property">config</span>.<span class="property">js</span> 文件中的 devServer.<span class="property">proxy</span> 配置项来将请求转发至 <span class="variable constant_">API</span> 服务器，避免跨域问题</span><br><span class="line"><span class="number">6.</span><span class="title class_">WebSocket</span>：提供了一个双向的通信通道，可以在任意域名之间传递数据，并且可以支持跨域共享资源。</span><br></pre></td></tr></table></figure>

<p>**proxy代理+ Nginx **         &#96;在vue.config.js文件新增以下代码&#96;&#96;</p>
<img src="../image/image-20230205195809447.png" alt="image-20230205195809447" style="zoom:80%;" />

<h4 id="16-渐进增强与优雅降级的理解及区别"><a href="#16-渐进增强与优雅降级的理解及区别" class="headerlink" title="16.渐进增强与优雅降级的理解及区别"></a>16.渐进增强与优雅降级的理解及区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>渐进增强（<span class="title class_">Progressive</span> <span class="title class_">Enhancement</span>）：</span><br><span class="line">一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</span><br><span class="line"><span class="number">2.</span>优雅降级（<span class="title class_">Graceful</span> <span class="title class_">Degradation</span>）：</span><br><span class="line">一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 <span class="title class_">CSS3</span> 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 <span class="variable constant_">CSS</span> hack是通过在<span class="variable constant_">CSS</span>样式中加入一些特殊的符号，让不同的浏览器识别不同的符号 </span><br><span class="line">两者区别</span><br><span class="line"><span class="number">1</span>、广义：</span><br><span class="line">其实要定义一个基准线，在此之上的增强叫做渐进增强，在此之下的兼容叫优雅降级</span><br><span class="line"><span class="number">2</span>、狭义：</span><br><span class="line">渐进增强一般说的是使用 <span class="title class_">CSS3</span> 技术，在不影响老浏览器的正常显示与使用情形下来增强体验，而优雅降级则是体现 html 标签的语义，以便在 js/css 的加载失败/被禁用时，也不影响用户的相应功能</span><br></pre></td></tr></table></figure>

<h4 id="17-说一下浏览器样式兼容"><a href="#17-说一下浏览器样式兼容" class="headerlink" title="17.说一下浏览器样式兼容"></a>17.说一下浏览器样式兼容</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一、<span class="variable constant_">CSS</span> 初始化</span><br><span class="line">每个浏览器的 css 默认样式不尽相同，所以最简单有效的方式就是对其进行初始化（覆盖默认样式</span><br><span class="line"></span><br><span class="line">常见 :  *&#123; <span class="attr">margin</span>: <span class="number">0</span>; <span class="attr">padding</span>: <span class="number">0</span>;&#125;</span><br><span class="line">库：normalize.<span class="property">css</span></span><br><span class="line">二、浏览器私有属性</span><br><span class="line">常用的前缀有：firefox浏览器 ：-moz-, chrome、safari ：-webkit-, <span class="variable constant_">IE</span>浏览器 ：-ms-（目前只有 <span class="variable constant_">IE</span> <span class="number">8</span>+支持）</span><br><span class="line">三、<span class="variable constant_">CSS</span> hack（条件 hack、属性级 hack、选择符级 hack）</span><br><span class="line"><span class="variable constant_">CSS</span> hack是通过在<span class="variable constant_">CSS</span>样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，<span class="variable constant_">CSS</span> hack就是让你记住这个标准），以达到应用不同的<span class="variable constant_">CSS</span>样式的目的。</span><br><span class="line">例:.<span class="property">kwstu</span>&#123;margin-<span class="attr">left</span>:20px;_margin-<span class="attr">left</span>:20px;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-说一下七层网络模型"><a href="#18-说一下七层网络模型" class="headerlink" title="18.说一下七层网络模型"></a>18.说一下七层网络模型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>应用层 <span class="number">2.</span>表示层 <span class="number">3.</span>会话层 <span class="number">4.</span>传输层(https加密在这一层) <span class="number">5.</span>网络层 <span class="number">6.</span>数据链路层 <span class="number">7.</span>物理层</span><br></pre></td></tr></table></figure>

<img src="../image/image-20230209202850828.png" alt="image-20230209202850828" style="zoom:80%;" />

<h4 id="19-前端如何解决首屏加载慢"><a href="#19-前端如何解决首屏加载慢" class="headerlink" title="19.前端如何解决首屏加载慢"></a>19.前端如何解决首屏加载慢</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>路由懒加载</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">User</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;@/views/user&#x27;</span>)  <span class="comment">//导入组件</span></span><br><span class="line"><span class="number">2.</span><span class="variable constant_">DNS</span>缓存</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;x-dns-prefetch-control&quot;</span> content=<span class="string">&quot;on&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://bdimg.share.baidu.com&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="number">3.</span> 减少http请求数</span><br><span class="line">(<span class="number">1</span>）合并图片。当图片较多时，可以合并为一张大图，从而减少http请求数。 图片尽可能的使用<span class="variable constant_">PNG</span>格式的图片，体积相对较小 图片懒加载</span><br><span class="line">(<span class="number">2</span>）合并压缩css样式表和js脚本。</span><br><span class="line"><span class="number">4.</span>使用<span class="variable constant_">CDN</span></span><br><span class="line"><span class="number">5.</span>开启<span class="variable constant_">GZIP</span> 数据压缩</span><br><span class="line"><span class="number">6.</span>减少重绘和回流 ，提高dom树渲染效率</span><br><span class="line"><span class="number">7.</span>css选择器 层级尽量不要超过三层，计算样式很费效率</span><br><span class="line"><span class="number">8.</span>充分利用http缓存</span><br><span class="line"><span class="number">9.</span>适当采用 keep-alive 缓存组件</span><br></pre></td></tr></table></figure>

<h4 id="20-http和https的区别"><a href="#20-http和https的区别" class="headerlink" title="20.http和https的区别"></a>20.http和https的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">区别： https 是 http 的“升级”版本：</span><br><span class="line"><span class="number">1.</span>http的默认端口号是<span class="number">80</span>，https的默认端口号是<span class="number">443</span></span><br><span class="line"><span class="number">2.</span><span class="variable constant_">HTTPS</span> 是 <span class="variable constant_">HTTP</span> 协议的更加安全的版本，通过使用<span class="variable constant_">SSL</span>/<span class="variable constant_">TLS</span>进行加密传输的数据；  <span class="variable constant_">SSL</span> 是安全层，<span class="variable constant_">TLS</span> 是传输层安全</span><br><span class="line"><span class="number">3.</span>连接方式： <span class="variable constant_">HTTP</span>（三次握手）和 <span class="variable constant_">HTTPS</span> （三次握手+数字证书）连接方式不一样；由于https比http多了一个<span class="variable constant_">SSL</span>连接，所以速度上没有http快</span><br><span class="line"><span class="number">4.</span>传输的数据 使用 <span class="variable constant_">HTTP</span> 可能看到传输数据是： “明文信息”， <span class="variable constant_">HTTPS</span> 传输的不再是文本，而是二进制流，使得传输更高效，且加密处理更加安全</span><br></pre></td></tr></table></figure>

<h4 id="21-TCP和UDP区别"><a href="#21-TCP和UDP区别" class="headerlink" title="21.TCP和UDP区别"></a>21.TCP和UDP区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 安全性 ：  数据包在传输过程中容易丢失；大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 <span class="variable constant_">UDP</span> 协议并不知道如何组装这些数据包，从而把这些数据包不能还原成完整的文件，对于错误的数据包，<span class="variable constant_">UDP</span> 并不提供重发机制，只是丢弃当前的包  ，而<span class="variable constant_">TCP</span>，对于数据包丢失的情况，<span class="variable constant_">TCP</span> 提供重传机制；<span class="variable constant_">TCP</span> 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件</span><br><span class="line"><span class="number">2.</span>速度 ： <span class="variable constant_">UDP</span>虽然不可靠，但速度非常快，应用场景 在线视频等 ，<span class="variable constant_">TCP</span>牺牲了速度(三次握手建立连接)，从而保证了数据的可靠性，</span><br><span class="line"><span class="number">3.</span><span class="variable constant_">TCP</span> 是面向链接的，而 <span class="variable constant_">UDP</span> 是面向无连接的。<span class="variable constant_">TCP</span> 的三次握手保证了连接的可靠性; <span class="variable constant_">UDP</span> 是无连接的、不可靠的一种数据传输协议，</span><br><span class="line">首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送</span><br><span class="line">确认信号，发送端不知道数据是否会正确接收。</span><br></pre></td></tr></table></figure>

<h4 id="22-三次握手-四次挥手过程"><a href="#22-三次握手-四次挥手过程" class="headerlink" title="22.三次握手 四次挥手过程"></a>22.三次握手 四次挥手过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">先介绍一下术语： 三次握手</span><br><span class="line">                <span class="number">1.</span><span class="variable constant_">SYN</span>：同步位  <span class="variable constant_">SYN</span>=<span class="number">1</span>，表示进行一个连接情求</span><br><span class="line">                <span class="number">2.</span> <span class="variable constant_">ACK</span> ：确认位  <span class="variable constant_">ACK</span> =<span class="number">1</span> 确认有效   <span class="variable constant_">ACK</span> = <span class="number">0</span> 确认无效</span><br><span class="line">                <span class="number">3.</span>ack：确认号   对方发送的序号加一</span><br><span class="line">                <span class="number">4.</span>seq ：序号	seq =x x是随机的</span><br><span class="line">           过程：</span><br><span class="line">           <span class="number">1.</span>首先客户端向服务端主动请求，带有<span class="variable constant_">SYN</span>=<span class="number">1</span>表示连接请求，还有一个随机的序号 seq=x， <span class="number">2.</span> 服务端收到后，向客户端发送            <span class="variable constant_">SYN</span>=<span class="number">1</span>，表示请求连接，<span class="variable constant_">ACK</span>=<span class="number">1</span>，确认有效，发送一个确认号，ack = x+<span class="number">1</span>,(客户端的随机序号加<span class="number">1</span>),并也发一个 seq = y随机序号，</span><br><span class="line">         <span class="number">3.</span>客户端接收到后，给服务器发送 <span class="variable constant_">ACK</span>=<span class="number">1</span> 确认有效，ack = y + <span class="number">1</span> (服务端的随机序号加<span class="number">1</span>) seq = x+<span class="number">1</span> (发送客户端上一次发送        的随机序号加<span class="number">1</span>)  完成连接</span><br><span class="line">           </span><br><span class="line">    四次挥手：</span><br><span class="line">    术语 ： <span class="number">1.</span><span class="variable constant_">FIN</span> =<span class="number">1</span> 断开连接 </span><br><span class="line">    过程：</span><br><span class="line">    <span class="number">1.</span> 首先客户端向服务端发送 <span class="variable constant_">FIN</span>=<span class="number">1</span>( 并且客户端会停止向服务端发送数据) 表示断开连接，发送一个随机序号 seq=U ，</span><br><span class="line">    <span class="number">2.</span>服务端接收到了，给客户端发送 <span class="variable constant_">ACK</span> = <span class="number">1</span> 表示确认有效 ，ack=U+<span class="number">1</span>(客服端的随机序号+<span class="number">1</span>)，seq=<span class="title function_">V</span>(给客户端发送一个随机序号)处于     半关闭状态</span><br><span class="line">    <span class="number">3.</span>服务端再给客服端发送 <span class="variable constant_">FIN</span> =<span class="number">1</span> ( 并且服务端会停止向客户端发送数据) ack = U+<span class="number">1</span>(客户端的随机序号+<span class="number">1</span>)，<span class="variable constant_">ACK</span>=<span class="number">1</span> 确认有效，       seq=<span class="title function_">W</span>(发送一个随机序列号给客户端)</span><br><span class="line">    <span class="number">4.</span>客户端给服务端发送seq=U+<span class="number">1</span>(第一次的随机序列号+<span class="number">1</span>) ，<span class="variable constant_">ACK</span>=<span class="number">1</span> 确认有效 ack = w+<span class="number">1</span>(服务端的随机序列号+<span class="number">1</span>) 完成断开连接</span><br></pre></td></tr></table></figure>

<img src="../image/image-20230217205401698.png" alt="image-20230217205401698" style="zoom:80%;" />

<img src="../image/image-20230217210156006.png" alt="image-20230217210156006" style="zoom:80%;" />

<h4 id="23-说一下http和https的区别"><a href="#23-说一下http和https的区别" class="headerlink" title="23.说一下http和https的区别"></a>23.说一下http和https的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="variable constant_">HTTPS</span>协议需要<span class="variable constant_">CA</span>证书，费用较高；而<span class="variable constant_">HTTP</span>协议不需要；</span><br><span class="line">- <span class="variable constant_">HTTP</span>协议是超文本传输协议，信息是明文传输的，<span class="variable constant_">HTTPS</span>则是具有安全性的<span class="variable constant_">SSL</span>加密传输协议；</span><br><span class="line">- 使用不同的连接方式，端口也不同，<span class="variable constant_">HTTP</span>协议端口是<span class="number">80</span>，<span class="variable constant_">HTTPS</span>协议端口是<span class="number">443</span>；</span><br><span class="line">- <span class="variable constant_">HTTP</span>协议连接很简单，是无状态的；<span class="variable constant_">HTTPS</span>协议是有<span class="variable constant_">SSL</span>和<span class="variable constant_">HTTP</span>协议构建的可进行加密传输、身份认证的网络协议，比<span class="variable constant_">HTTP</span>更加安全</span><br></pre></td></tr></table></figure>

<h4 id="24-说一下http的请求方法"><a href="#24-说一下http的请求方法" class="headerlink" title="24.说一下http的请求方法"></a>24.说一下http的请求方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>get</span><br><span class="line"><span class="number">2.</span>post</span><br><span class="line"><span class="number">3.</span><span class="keyword">delete</span></span><br><span class="line"><span class="number">4.</span>put</span><br></pre></td></tr></table></figure>

<h4 id="25-前端优化手段"><a href="#25-前端优化手段" class="headerlink" title="25.前端优化手段"></a>25.前端优化手段</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前端性能优化分为两类，一类是文件加载更快，另一类是文件渲染更快。 </span><br><span class="line"><span class="number">1.</span> 加载更快的方法： 让传输的数据包更小（压缩文件/图片）：图片压缩和文件压缩 减少网络请求的次数：雪碧图/精灵图、节流防抖 减少渲染的次数：缓存（<span class="variable constant_">HTTP</span>缓存、本地缓存、<span class="title class_">Vue</span>的keep-alive缓存等） </span><br><span class="line"><span class="number">2.</span>渲染更快的方法： 提前渲染：ssr服务器端渲染 避免渲染阻塞：<span class="variable constant_">CSS</span>放在<span class="variable constant_">HTML</span>的head中 <span class="variable constant_">JS</span>放在<span class="variable constant_">HTML</span>的body底部 避免无用渲染：懒加载 减少渲染次数：对dom查询进行缓存、将dom操作合并、使用减少重排的标签 </span><br><span class="line"><span class="number">3.</span>加分回答 雪碧图的应用场景一般是项目中不常更换的一些固定图标组合在一起，比如logo、搜索图标、切换图标等。 电商项目中最常用到的懒加载，一般在查看商品展示的时候通常下拉加载更多，因为商品数据太多，一次性请求过来数据太大且渲染的时间太长。</span><br></pre></td></tr></table></figure>

<h4 id="26-说一说服务端渲染？"><a href="#26-说一说服务端渲染？" class="headerlink" title="26.说一说服务端渲染？"></a>26.说一说服务端渲染？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器端生成<span class="variable constant_">HTML</span>直接返回给浏览器、减少网络传输、首屏渲染快、对搜索引擎友好</span><br><span class="line">服务端渲染的优势：减少网络传输，响应快，用户体验好，首屏渲染快，对搜索引擎友好，搜索引擎爬虫可以看到完整的程序源码，有利于<span class="variable constant_">SEO</span>。</span><br></pre></td></tr></table></figure>

<h4 id="27-图片懒加载是怎么实现的？"><a href="#27-图片懒加载是怎么实现的？" class="headerlink" title="27.图片懒加载是怎么实现的？"></a>27.图片懒加载是怎么实现的？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">就是我们先设置图片的data-set属性（当然也可以是其他任意的，只要不会发送http请求就行了，作用</span><br><span class="line">就是为了存取值）值为其图片路径，由于不是src，所以不会发送http请求。 然后我们计算出页面</span><br><span class="line">scrollTop的高度和浏览器的高度之和， 如果图片距离页面顶端的坐标Y（相对于整个页面，而不是浏览</span><br><span class="line">器窗口）小于前两者之和，就说明图片就要显示出来了（合适的时机，当然也可以是其他情况），这时</span><br><span class="line">候我们再将 data-set 属性替换为 src 属性即可。</span><br></pre></td></tr></table></figure>

<h4 id="28-https-协议的工作原理"><a href="#28-https-协议的工作原理" class="headerlink" title="28.https 协议的工作原理"></a>28.https 协议的工作原理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端在使用 <span class="variable constant_">HTTPS</span> 方式与 <span class="title class_">Web</span> 服务器通信时有以下几个步骤：</span><br><span class="line"><span class="number">1.</span> 客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</span><br><span class="line"><span class="number">2.</span> web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输</span><br><span class="line">给客户端。</span><br><span class="line"><span class="number">3.</span> 客户端和 web 服务器端开始协商 <span class="variable constant_">SSL</span> 链接的安全等级，也就是加密等级。</span><br><span class="line"><span class="number">4.</span> 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥</span><br><span class="line">来加密会话密钥，并传送给网站。</span><br><span class="line"><span class="number">5.</span> web 服务器通过自己的私钥解密出会话密钥。</span><br><span class="line"><span class="number">6.</span> web 服务器通过会话密钥加密与客户端之间的通信。</span><br></pre></td></tr></table></figure>

<h4 id="29-TCP-x2F-IP-x2F-如何保证数据包传输的有序可靠"><a href="#29-TCP-x2F-IP-x2F-如何保证数据包传输的有序可靠" class="headerlink" title="29.TCP&#x2F;IP &#x2F; 如何保证数据包传输的有序可靠"></a>29.TCP&#x2F;IP &#x2F; 如何保证数据包传输的有序可靠</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对字节流分段并进行编号然后通过 <span class="variable constant_">ACK</span> 回复和超时重发这两个机制来保证。</span><br><span class="line"><span class="number">1.</span>为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；</span><br><span class="line"><span class="number">2.</span>并为每个已发送的数据包启动一个超时定时器；</span><br><span class="line"><span class="number">3.</span>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，</span><br><span class="line">也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;</span><br><span class="line"><span class="number">4.</span>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</span><br><span class="line"><span class="number">5.</span>接收方收到数据包后，先进行 <span class="variable constant_">CRC</span> 校验，如果正确则把数据交给上层协议，</span><br><span class="line">然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数</span><br><span class="line">据要发给发送方，应答包也可方在数据包中捎带过去</span><br></pre></td></tr></table></figure>

<h4 id="30-为什么ajax发请求不刷新页面"><a href="#30-为什么ajax发请求不刷新页面" class="headerlink" title="30.为什么ajax发请求不刷新页面"></a>30.为什么ajax发请求不刷新页面</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">AJAX</span>是 <span class="title class_">Asynchronous</span> <span class="title class_">JavaScript</span> and <span class="variable constant_">XML</span> 的缩写，指的是通过 <span class="title class_">JavaScript</span> 的 异步通信，从服务器获取 <span class="variable constant_">XML</span> 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</span><br></pre></td></tr></table></figure>

<h4 id="31-git-pull-和-git-fetch-的区别"><a href="#31-git-pull-和-git-fetch-的区别" class="headerlink" title="31.git pull 和 git fetch 的区别"></a>31.git pull 和 git fetch 的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。</span><br><span class="line">- git pull 会将远程仓库的变化下载下来，并和当前分支合并。</span><br></pre></td></tr></table></figure>

<h4 id="32-简单请求和复杂请求"><a href="#32-简单请求和复杂请求" class="headerlink" title="32.简单请求和复杂请求"></a>32.简单请求和复杂请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">简单请求需要满足一下条件</span><br><span class="line"><span class="number">1.</span>head <span class="variable constant_">GET</span> <span class="variable constant_">POST</span> <span class="comment">//请求方式是这三种的一种</span></span><br><span class="line"><span class="number">2.</span> <span class="variable constant_">HTTP</span>头信息不超出以下几种字段</span><br><span class="line"><span class="title class_">Accept</span></span><br><span class="line"><span class="title class_">Accept</span>-<span class="title class_">Language</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>，但仅能是下列之一</span><br><span class="line">application/x-www-form-urlencoded</span><br><span class="line">multipart/form-data</span><br><span class="line">text/plain</span><br></pre></td></tr></table></figure>

<h4 id="33-什么是-webpack-的热更新？它的实现原理是什么？"><a href="#33-什么是-webpack-的热更新？它的实现原理是什么？" class="headerlink" title="33.什么是 webpack 的热更新？它的实现原理是什么？"></a>33.什么是 webpack 的热更新？它的实现原理是什么？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ebpack 的热更新（<span class="title class_">Hot</span> <span class="title class_">Module</span> <span class="title class_">Replacement</span>，简称 <span class="variable constant_">HMR</span>）是一种开发时提高开发效率的技术，可以实现无需刷新页面即可看到代码修改后的效果。在使用 <span class="variable constant_">HMR</span> 后，当修改了代码后，webpack 只会重新编译修改的代码，并将新的模块发送到客户端，替换掉旧的模块，从而达到实时更新页面的目的。</span><br><span class="line"></span><br><span class="line">实现 <span class="variable constant_">HMR</span> 的关键是在客户端和服务器端之间建立一个 <span class="title class_">WebSocket</span> 连接，当代码发生变化时，服务器端会将新的模块发送给客户端，客户端接收到新的模块后会用新模块替换旧模块，从而实现实时更新。</span><br><span class="line"></span><br><span class="line">具体来说，webpack <span class="variable constant_">HMR</span> 主要分为以下几个步骤：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>启动 webpack-dev-server，配置 <span class="variable constant_">HMR</span> 插件</span><br><span class="line"><span class="number">2.</span>当代码变化时，webpack-dev-server 会编译出新的模块</span><br><span class="line"><span class="number">3.</span><span class="variable constant_">HMR</span> runtime（客户端运行时）会通过 <span class="title class_">WebSocket</span> 与服务器通信，获取最新的模块</span><br><span class="line"><span class="number">4.</span>当 <span class="variable constant_">HMR</span> runtime 接收到新模块时，会将新模块加载到浏览器中，并通过模块热替换算法将新模块与旧模块进行比较，只替换有变化的模块部分</span><br><span class="line"><span class="number">5.</span>页面更新完成，无需刷新页面即可看到最新的效果。</span><br><span class="line">总之，<span class="variable constant_">HMR</span> 可以大大提高开发效率，同时也能够减少代码变更时的刷新操作，提高开发体验。</span><br><span class="line"><span class="comment">//webpack</span></span><br><span class="line"><span class="number">1.</span>模块打包：<span class="title class_">Webpack</span> 可以自动分析代码中的依赖关系，并将所有的依赖打包成一个或多个 <span class="title class_">JavaScript</span> 文件，方便浏览器加载和执行。</span><br><span class="line"><span class="number">2.</span>代码转换：<span class="title class_">Webpack</span> 支持使用各种 loader 对代码中的资源进行处理，例如，<span class="title class_">ES6</span>/<span class="number">7</span> 转换成 <span class="title class_">ES5</span>、<span class="variable constant_">CSS</span> 预处理器、<span class="title class_">TypeScript</span> 等。</span><br><span class="line"><span class="number">3.</span>代码分离：<span class="title class_">Webpack</span> 可以将应用程序分离成多个包，只加载必要的模块，从而缩短应用程序的加载时间。</span><br><span class="line"><span class="number">4.</span>性能优化：<span class="title class_">Webpack</span> 可以通过各种插件来优化代码质量和性能，例如压缩代码、去除冗余代码、图片压缩等。</span><br><span class="line"><span class="number">5.</span>支持热更新：<span class="title class_">Webpack</span> 提供了开发环境下的热更新功能，当代码变更时不需要手动刷新页面，而是自动更新页面内容，提高了开发效率。</span><br><span class="line">总之，<span class="title class_">Webpack</span> 是前端工程化中不可或缺的一环，通过自动化和标准化的方式，让我们更加高效地进行开发，提高了项目的可维护性和可拓展性。</span><br></pre></td></tr></table></figure>

<h4 id="34-怎么终止网络请求"><a href="#34-怎么终止网络请求" class="headerlink" title="34.怎么终止网络请求"></a>34.怎么终止网络请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title function_">abort</span>()方法中止网络请求。该方法适用于通过<span class="title class_">XMLHttpRequest</span>对象或fetch <span class="variable constant_">API</span>发起的网络请求</span><br><span class="line"> <span class="title class_">AbortController</span></span><br><span class="line"> <span class="number">1.</span>fetch请求</span><br><span class="line">  <span class="comment">// 创建AbortController实例</span></span><br><span class="line"> <span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="comment">// 获取AbortSignal对象</span></span><br><span class="line"><span class="keyword">const</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/api/data&#x27;</span>, &#123; signal &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理响应数据</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.<span class="property">name</span> === <span class="string">&#x27;AbortError&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求已中止&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求出错&#x27;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中止请求</span></span><br><span class="line">controller.<span class="title function_">abort</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">2.</span>终止原生<span class="variable constant_">XHR</span>请求</span><br><span class="line"> <span class="comment">// 创建AbortController实例</span></span><br><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="comment">// 获取AbortSignal对象</span></span><br><span class="line"><span class="keyword">const</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"><span class="comment">// 创建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 监听AbortSignal对象</span></span><br><span class="line">signal.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求被取消&#x27;</span>);</span><br><span class="line">  <span class="comment">// 执行其他操作</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/api/data&#x27;</span>);</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 处理响应数据</span></span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">controller.<span class="title function_">abort</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>终止axios请求   <span class="title class_">CancelToken</span>是axios中用于取消请求的机制之一</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="comment">// 创建CancelToken对象实例</span></span><br><span class="line"><span class="keyword">const</span> source = axios.<span class="property">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line"><span class="comment">// 向服务器发送请求</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;https://example.com/api/data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.<span class="property">token</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理响应数据</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求已取消&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求出错&#x27;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">source.<span class="title function_">cancel</span>(<span class="string">&#x27;请求被中止&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="七-前端优化"><a href="#七-前端优化" class="headerlink" title="七.前端优化"></a>七.前端优化</h3><h4 id="1-DNS优化"><a href="#1-DNS优化" class="headerlink" title="1.DNS优化"></a>1.DNS优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">内容分发网络：</span><br><span class="line"><span class="variable constant_">CDN</span> 可以提前把数据存在离用户最近的数据节点,提高访问速度的目的</span><br><span class="line">浏览器请求图片数据时，会先去 <span class="variable constant_">CDN</span> 缓存服务器获取。如果获取到数据，那么就直接返回，要我们提前在 <span class="variable constant_">CDN</span> 缓存服务器上传需要的资源，那么我们就可以极大地减少网络流量，同时减少网络延迟。</span><br><span class="line"><span class="variable constant_">CDN</span> 的关键技术主要有内容存储和分发技术。简单来讲，<span class="variable constant_">CDN</span>就是根据用户位置分配最近的资源。</span><br><span class="line">应用<span class="variable constant_">CDN</span>后，<span class="variable constant_">DNS</span> 返回的不再是 <span class="variable constant_">IP</span> 地址，而是一个<span class="title function_">CNAME</span>(<span class="title class_">Canonical</span> <span class="title class_">Name</span> ) 别名记录，指向<span class="variable constant_">CDN</span>的全局负载均衡。</span><br><span class="line"><span class="variable constant_">CNAME</span>实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是<span class="variable constant_">CDN</span>实现的关键</span><br><span class="line"><span class="number">1.</span>浏览器发起图片 <span class="variable constant_">URL</span> 请求，经过本地 <span class="variable constant_">DNS</span> 解析，会将域名解析权交给域名 <span class="variable constant_">CNAME</span> 指向的 <span class="variable constant_">CDN</span> 专用 <span class="variable constant_">DNS</span> 服务器。</span><br><span class="line"><span class="number">2.</span><span class="variable constant_">CDN</span> 的 <span class="variable constant_">DNS</span> 服务器将 <span class="variable constant_">CDN</span> 的全局负载均衡设备 <span class="variable constant_">IP</span> 地址返回给浏览器。</span><br><span class="line"><span class="number">3.</span>浏览器向 <span class="variable constant_">CDN</span> 全局负载均衡设备发起 <span class="variable constant_">URL</span> 请求。</span><br><span class="line"><span class="number">4.</span><span class="variable constant_">CDN</span> 全局负载均衡设备根据用户 <span class="variable constant_">IP</span> 地址，以及用户请求的 <span class="variable constant_">URL</span>，选择一台用户所属区域的区域负载均衡设备，向其发起请求。</span><br><span class="line"><span class="number">5.</span>区域负载均衡设备会为用户选择最合适的 <span class="variable constant_">CDN</span> 缓存服务器（考虑的依据包括：服务器负载情况，距离用户的距离等），并返回给全局负载均衡设备。</span><br><span class="line"><span class="number">6.</span>全局负载均衡设备将选中的 <span class="variable constant_">CDN</span> 缓存服务器 <span class="variable constant_">IP</span> 地址返回给用户。</span><br><span class="line"><span class="number">7.</span>用户向 <span class="variable constant_">CDN</span> 缓存服务器发起请求，缓存服务器响应用户请求，最终将用户所需要偶的内容返回给浏览器。如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。</span><br><span class="line"><span class="number">8.</span>使用 <span class="variable constant_">CDN</span> 服务的网站，只需要将域名解析权交给 <span class="variable constant_">CDN</span> 服务商，接着将需要分发的内容上传到 <span class="variable constant_">CDN</span>，就可以实现内容加速了！</span><br></pre></td></tr></table></figure>

<img src="../image//image-20230306195513652.png" alt="image-20230306195513652" style="zoom:67%;" />

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">### <span class="number">2.</span> <span class="variable constant_">CDN</span>的作用 </span><br><span class="line"></span><br><span class="line"><span class="variable constant_">CDN</span>一般会用来托管<span class="title class_">Web</span>资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用<span class="variable constant_">CDN</span>来加速这些资源的访问。</span><br><span class="line">（<span class="number">1</span>）在性能方面，引入<span class="variable constant_">CDN</span>的作用在于：</span><br><span class="line">- 用户收到的内容来自最近的数据中心，延迟更低，内容加载更快</span><br><span class="line">- 部分资源请求分配给了<span class="variable constant_">CDN</span>，减少了服务器的负载</span><br><span class="line">（<span class="number">2</span>）在安全方面，<span class="variable constant_">CDN</span>有助于防御<span class="title class_">DDoS</span>、<span class="variable constant_">MITM</span>等网络攻击：</span><br><span class="line">- 针对<span class="title class_">DDoS</span>：通过监控分析异常流量，限制其请求频率</span><br><span class="line">- 针对<span class="variable constant_">MITM</span>：从源服务器到 <span class="variable constant_">CDN</span> 节点到 <span class="variable constant_">ISP</span>（<span class="title class_">Internet</span> <span class="title class_">Service</span> <span class="title class_">Provider</span>），全链路 <span class="variable constant_">HTTPS</span> 通信</span><br></pre></td></tr></table></figure>

<h4 id="2-图片懒加载"><a href="#2-图片懒加载" class="headerlink" title="2.图片懒加载"></a>2.图片懒加载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。</span><br><span class="line">懒加载的特点：</span><br><span class="line"><span class="number">1.</span>**减少无用资源的加载**：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</span><br><span class="line"><span class="number">2.</span>**提升用户体验**: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</span><br><span class="line"><span class="number">3.</span>**防止加载过多图片而影响其他资源文件的加载** ：会影响网站应用的正常使用。</span><br><span class="line">实现原理</span><br><span class="line">图片的加载是由<span class="string">`src`</span>引起的，当对<span class="string">`src`</span>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用<span class="title class_">HTML5</span> 的<span class="string">`data-xxx`</span>属性来储存图片的路径，在需要加载图片的时候，将<span class="string">`data-xxx`</span>中图片的路径赋值给<span class="string">`src`</span>，这样就实现了图片的按需加载，即懒加载。</span><br><span class="line">知识点</span><br><span class="line">（<span class="number">1</span>）<span class="string">`window.innerHeight`</span> 是浏览器可视区的高度</span><br><span class="line">（<span class="number">2</span>）<span class="string">`document.body.scrollTop || document.documentElement.scrollTop`</span> 是浏览器滚动的过的距离</span><br><span class="line">（<span class="number">3</span>）<span class="string">`imgs.offsetTop`</span> 是元素顶部距离文档顶部的高度（包括滚动条的距离）</span><br><span class="line">（<span class="number">4</span>）图片加载条件：<span class="string">`img.offsetTop &lt; window.innerHeight + document.body.scrollTop;`</span></span><br></pre></td></tr></table></figure>

<img src="../image/image-20230306201348392.png" alt="image-20230306201348392" style="zoom:80%;" />

<p><strong>代码实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">     &lt;img src=&quot;loading.gif&quot;  data-src=&quot;pic.png&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var imgs = document.querySelectorAll(&#x27;img&#x27;);</span><br><span class="line">function lozyLoad()&#123;</span><br><span class="line">        var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;</span><br><span class="line">        var winHeight= window.innerHeight;</span><br><span class="line">        for(var i=0;i &lt; imgs.length;i++)&#123;</span><br><span class="line">            if(imgs[i].offsetTop &lt; scrollTop + winHeight )&#123;</span><br><span class="line">                imgs[i].src = imgs[i].getAttribute(&#x27;data-src&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  window.onscroll = lozyLoad();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>懒加载和预加载的区别</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</span><br><span class="line"></span><br><span class="line">- **懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载**，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</span><br><span class="line">- **预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。**通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</span><br></pre></td></tr></table></figure>

<h4 id="3-重绘和回流"><a href="#3-重绘和回流" class="headerlink" title="3.重绘和回流"></a>3.重绘和回流</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**减少回流与重绘的措施：**</span><br><span class="line"></span><br><span class="line">- 操作<span class="variable constant_">DOM</span>时，尽量在低层级的<span class="variable constant_">DOM</span>节点进行操作</span><br><span class="line">- 不要使用<span class="string">`table`</span>布局， 一个小的改动可能会使整个<span class="string">`table`</span>进行重新布局</span><br><span class="line">- 使用<span class="variable constant_">CSS</span>的表达式</span><br><span class="line">- 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</span><br><span class="line">- 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</span><br><span class="line">- 避免频繁操作<span class="variable constant_">DOM</span>，可以创建一个文档片段<span class="string">`documentFragment`</span>，在它上面应用所有<span class="variable constant_">DOM</span>操作，最后再把它添加到文档中</span><br><span class="line">- 频繁操作元素将元素先脱离文档流，操作结束后再把它回归文档流。</span><br><span class="line">- 将<span class="variable constant_">DOM</span>的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于**浏览器的渲染队列机制**。</span><br><span class="line">浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**</span><br><span class="line"></span><br><span class="line">**浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**</span><br></pre></td></tr></table></figure>

<h4 id="4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？"><a href="#4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？" class="headerlink" title="4.documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？"></a>4.documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">与<span class="variable language_">document</span>相比，最大的区别是<span class="title class_">DocumentFragment</span>不是真实 <span class="variable constant_">DOM</span> 树的一部分，它的变化不会触发 <span class="variable constant_">DOM</span> 树的重新渲染，且不会导致性能等问题。这样就大大提高了页面的性能。</span><br><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#list&#x27;</span>) <span class="comment">//ul</span></span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Melon&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fragment = <span class="keyword">new</span> <span class="title class_">DocumentFragment</span>()</span><br><span class="line"></span><br><span class="line">fruits.<span class="title function_">forEach</span>(<span class="function">(<span class="params">fruit</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">  li.<span class="property">textContent</span> = fruit</span><br><span class="line">  fragment.<span class="title function_">appendChild</span>(li)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">list.<span class="title function_">appendChild</span>(fragment)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-如何提⾼webpack的打包速度"><a href="#5-如何提⾼webpack的打包速度" class="headerlink" title="5.如何提⾼webpack的打包速度**?**"></a>5.如何提⾼<strong>webpack</strong>的打包速度**?**</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）优化 <span class="title class_">Loader</span>  </span><br><span class="line">对于 <span class="title class_">Loader</span> 来说，影响打包效率首当其冲必属 <span class="title class_">Babel</span> 了。因为 <span class="title class_">Babel</span> 会将代码转为字符串生成 <span class="variable constant_">AST</span>，然后对 <span class="variable constant_">AST</span> 继续进行转变最后再生成新的代码，项目越大，**转换代码越多，效率就越低**</span><br><span class="line">    <span class="number">1.</span>优化 <span class="title class_">Loader</span> 的文件搜索范围</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// js 文件才使用 babel</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="comment">// 只在 src 文件夹下查找</span></span><br><span class="line">        <span class="attr">include</span>: [<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>)],</span><br><span class="line">        <span class="comment">// 不会去查找的路径</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">还可以将 <span class="title class_">Babel</span> 编译过的文件**缓存**起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</span><br><span class="line"><span class="attr">loader</span>: <span class="string">&#x27;babel-loader?cacheDirectory=true&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-vue项目中的优化"><a href="#6-vue项目中的优化" class="headerlink" title="6.vue项目中的优化"></a>6.vue项目中的优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">一.代码层的优化</span><br><span class="line"><span class="number">1.</span>v-<span class="keyword">if</span> 和v-show区分场景使用</span><br><span class="line">v-<span class="keyword">if</span>是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</span><br><span class="line">v-show，是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且<span class="variable constant_">DOM</span>元素保留；并且只是简单地基于 <span class="variable constant_">CSS</span> 的 display 属性进行切换。</span><br><span class="line">优化：</span><br><span class="line">所以，v-<span class="keyword">if</span> 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景</span><br><span class="line"><span class="number">2.</span>computed和watch分场景使用</span><br><span class="line">computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</span><br><span class="line">watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</span><br><span class="line">运用场景:</span><br><span class="line">当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</span><br><span class="line">当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 <span class="variable constant_">API</span> )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</span><br><span class="line"><span class="number">3.</span>v-<span class="keyword">for</span> 遍历必须为 item 添加 key，且避免同时使用 v-<span class="keyword">if</span></span><br><span class="line">（<span class="number">1</span>）v-<span class="keyword">for</span> 遍历必须为 item 添加 key</span><br><span class="line">加key的原因是，当我们更新dom时，vue的就地复用策略，diff算法对比新旧虚拟dom，如果不加key，则会去遍历查找，对应的新旧虚拟dom，</span><br><span class="line">当更新的内容过多，则十分消耗性能，加了key的话，想当于新旧虚拟dom是一种map映射的方式，速度就很快</span><br><span class="line">（<span class="number">2</span>）v-<span class="keyword">for</span> 遍历避免同时使用 v-<span class="keyword">if</span></span><br><span class="line">v-<span class="keyword">for</span> 比 v-<span class="keyword">if</span> 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</span><br><span class="line">例如：</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-for</span>=<span class="string">&quot;user in activeUsers&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123; user.name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">activeUsers</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> user.<span class="property">isActive</span>  <span class="comment">//筛选我们需要展示的数据</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.</span>长列表性能优化</span><br><span class="line"><span class="title class_">Vue</span> 会通过 <span class="title class_">Object</span>.<span class="property">defineProperty</span> 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 <span class="title class_">Vue</span> 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 <span class="title class_">Vue</span> 劫持我们的数据呢？可以通过 <span class="title class_">Object</span>.<span class="property">freeze</span> 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">users</span>: &#123;&#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&quot;/api/users&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">users</span> = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(users);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">5.</span>事件销毁</span><br><span class="line">vue组件销毁的时候，会自动清理它与其他实例的连接，解绑它的全部指令以及事件监听器，但是仅限于组件本身的事件，原生js的事件包括全局的一些方法比如定时器，就不会被销毁，就会造成内存泄漏，解决方法</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="variable language_">this</span>.<span class="property">click</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="variable language_">this</span>.<span class="property">click</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">6.</span>图片懒加载</span><br><span class="line">对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 <span class="title class_">Vue</span> 的 vue-lazyload 插件：</span><br><span class="line"><span class="number">6.1</span>安装插件</span><br><span class="line">  npm install vue-lazyload --save-dev</span><br><span class="line"><span class="number">6.2</span>在入口文件main.<span class="property">js</span>中引入并使用</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueLazyload</span> <span class="keyword">from</span> <span class="string">&#x27;vue-lazyload&#x27;</span></span><br><span class="line"><span class="number">6.3</span>安装这个插件</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueLazyload</span>)</span><br><span class="line">如果要添加自定义项的话</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueLazyload</span>, &#123;</span><br><span class="line"><span class="attr">preLoad</span>: <span class="number">1.3</span>,</span><br><span class="line"><span class="attr">error</span>: <span class="string">&#x27;dist/error.png&#x27;</span>,  <span class="comment">//加载图片失败时的src</span></span><br><span class="line"><span class="attr">loading</span>: <span class="string">&#x27;dist/loading.gif&#x27;</span>, <span class="comment">//加载图片时的src</span></span><br><span class="line"><span class="attr">attempt</span>: <span class="number">1</span>            <span class="comment">//尝试计数</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="number">6.4</span>在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示</span><br><span class="line">   &lt;img v-lazy=<span class="string">&quot;/static/img/1.png&quot;</span>&gt;</span><br><span class="line"><span class="number">7.</span>路由懒加载</span><br><span class="line"><span class="title class_">Vue</span>  是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Foo</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Foo</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="number">8.</span>第三方插件的按需引入</span><br><span class="line">我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：</span><br><span class="line"><span class="number">8.1</span>安装</span><br><span class="line">npm install babel-plugin-component -D</span><br><span class="line"><span class="number">8.2</span>然后，将 .<span class="property">babelrc</span> 修改为：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [[<span class="string">&quot;es2015&quot;</span>, &#123; <span class="string">&quot;modules&quot;</span>: <span class="literal">false</span> &#125;]],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;component&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;element-ui&quot;</span>,</span><br><span class="line">        <span class="string">&quot;styleLibraryName&quot;</span>: <span class="string">&quot;theme-chalk&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">8.3</span>在main.<span class="property">js</span>中引入部分组件</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Select</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"> <span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Button</span>)</span><br><span class="line"> <span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Select</span>)</span><br><span class="line"><span class="number">9.</span>优化无限列表性能</span><br><span class="line">如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller  来优化这种无限列表的场景的。</span><br><span class="line"><span class="number">10.</span>服务端渲染和预渲染</span><br><span class="line">如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller  来优化这种无限列表的场景的。</span><br><span class="line">更有利于搜索引擎</span><br><span class="line">因为 <span class="variable constant_">SPA</span> 页面的内容是通过 <span class="title class_">Ajax</span> 获取，而搜索引擎爬取工具并不会等待 <span class="title class_">Ajax</span> 异步完成后再抓取页面内容，所以在 <span class="variable constant_">SPA</span> 中是抓取不到页面通过 <span class="title class_">Ajax</span> 获取到的内容；而 <span class="variable constant_">SSR</span> 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</span><br><span class="line"><span class="number">11.</span><span class="variable constant_">CND</span></span><br><span class="line"><span class="number">12.</span>gzip压缩</span><br><span class="line"><span class="number">13.</span>浏览器缓存</span><br><span class="line"><span class="number">14.</span>使用 <span class="title class_">Chrome</span> <span class="title class_">Performance</span> 查找性能瓶颈</span><br><span class="line"><span class="title class_">Chrome</span> 的 <span class="title class_">Performance</span>(性能) 面板可以录制一段时间内的 js 执行细节及时间。使用 <span class="title class_">Chrome</span> 开发者工具分析页面性能的步骤如下。</span><br><span class="line">打开 <span class="title class_">Chrome</span> 开发者工具，切换到 <span class="title class_">Performance</span> 面板</span><br><span class="line">点击 <span class="title class_">Record</span> 开始录制</span><br><span class="line">刷新页面或展开某个节点</span><br><span class="line">点击 <span class="title class_">Stop</span> 停止录制</span><br></pre></td></tr></table></figure>



<h3 id="八-项目相关"><a href="#八-项目相关" class="headerlink" title="八.项目相关"></a>八.项目相关</h3><h4 id="1-说一下项目当中的权限是怎么做的呢"><a href="#1-说一下项目当中的权限是怎么做的呢" class="headerlink" title="1.说一下项目当中的权限是怎么做的呢"></a>1.说一下项目当中的权限是怎么做的呢</h4><h4 id="2-说一下你是怎么控制vue项目中的多个控件的显示隐藏"><a href="#2-说一下你是怎么控制vue项目中的多个控件的显示隐藏" class="headerlink" title="2.说一下你是怎么控制vue项目中的多个控件的显示隐藏"></a>2.说一下你是怎么控制vue项目中的多个控件的显示隐藏</h4><h4 id="3-讲讲上传组件的实现思路"><a href="#3-讲讲上传组件的实现思路" class="headerlink" title="3.讲讲上传组件的实现思路"></a>3.讲讲上传组件的实现思路</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">说明:</span><br><span class="line">可以从组件用途,上传的核心,组件实现步骤和功能,这几个维度来回答</span><br><span class="line">答:</span><br><span class="line">上传组件是通过对element-ui的上传组件的二次封装,以满足我们的需求</span><br><span class="line"><span class="number">1.</span>我们项目当中上传组件是用来上传图片,用来显示用户的头像信息</span><br><span class="line"><span class="number">2.</span>核心是使用三方云服务,把图片或文件存储到云服务器,云服务器的存储 url 存储到公司自由服务器</span><br><span class="line"><span class="number">3.</span>首先创建公共组件,组件当中使用element-ui的upload组件,通过样式穿透,覆盖了它的样式,并且通</span><br><span class="line">过http属性,覆盖了它默认的上传行为</span><br><span class="line"><span class="number">4.</span>然后完善了一些细节,增加一些功能,例如上传前验证文件大小和格式(我记得是element提供的一个方法，提供了两个参数一个是type一个是size，然后再做判断),和文件的数量;上传中显示上传进度条;上传完成保存文件地址,点击组件预览大图和删除图片</span><br></pre></td></tr></table></figure>

<h4 id="4-项目中的-axios咋用的"><a href="#4-项目中的-axios咋用的" class="headerlink" title="4.项目中的 axios咋用的"></a>4.项目中的 axios咋用的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">说明:</span><br><span class="line">可以从axios 的作用、如何封装、如何使用这几个维度来回答</span><br><span class="line">答:</span><br><span class="line">axios 在项目中,主要用来发起 <span class="title class_">Ajax</span> 的数据请求,专门用来实现前后端数据交互的。</span><br><span class="line"><span class="number">1.</span>我们在项目中会对 axios 做进一步的封装。会创建一个 src/utils/request.<span class="property">js</span> 的模块,里面调用</span><br><span class="line">axios.<span class="title function_">create</span>() 函数,来创建 axios 的实例对象(防止以后接口不一致，需要换基地址)。在调用 create 函数期间可以全局配置请求的</span><br><span class="line">baseURL 根路径等。</span><br><span class="line"><span class="number">2.</span>对于功能类似的 <span class="variable constant_">API</span> 接口,我们会在 src/api 目录下进行接口的封装。这样可以提高 <span class="variable constant_">API</span> 接口的复</span><br><span class="line">用性。</span><br><span class="line"><span class="number">3.</span>在项目中还会用到 axios 的拦截器。它主要的应用场景是： a. 基于请求拦截器,为有权限的接口</span><br><span class="line">统一添加 <span class="title class_">Authorization</span> 的 token 认证 b. 基于响应拦截器,判断响应状态码是否<span class="number">400</span>或者<span class="number">500</span>,如果</span><br><span class="line">是提示用报错信息,如果为 <span class="number">401</span>,处理 token 失效做退出处理,调整到登录页面</span><br></pre></td></tr></table></figure>

<h4 id="5-系统如何进行权限控制和实现"><a href="#5-系统如何进行权限控制和实现" class="headerlink" title="5.系统如何进行权限控制和实现"></a>5.系统如何进行权限控制和实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">说明:</span><br><span class="line">可以从权限包含哪几方面,如何实现,关键步骤这几个维度来回答</span><br><span class="line">答:</span><br><span class="line">权限用来确保用户只能访问到被分配的资源</span><br><span class="line"><span class="number">1.</span>权限主要分为<span class="number">4</span>个方面,分别是接口权限,路由权限,菜单权限和按钮权限</span><br><span class="line"><span class="number">2.</span>接口权限,保证部分接口要用户登录后才能访问,一般采用 <span class="title function_">jwt</span>(token) 的形式来验证,登录完拿到 token ,将</span><br><span class="line">token 存起来,通过 axios 请求拦截器进行拦截,每次请求的时候头部携带, 没有通过的话一般返回</span><br><span class="line"><span class="number">401</span> ,跳转到登录页面重新进行登录</span><br><span class="line">token</span><br><span class="line"><span class="number">3.</span>路由权限,保证登录后才能访问到其他页面,一般通过路由前置守卫来做控制,在跳转前判断用户要</span><br><span class="line">访问的页面是不是登录页面或者<span class="number">404</span>页面,如果是允许它跳转,如果是其他页面,要判断用户有没有</span><br><span class="line">token,如果有token才允许跳转,如果没有token就跳转到登录页面</span><br><span class="line"><span class="number">4.</span>菜单权限,保证不同的角色有不同的菜单,一般通过让用户有不同路由配置来控制,具体是在登录完</span><br><span class="line">成后,在路由前置守卫中,获取用户的权限信息,然后筛选有权限访问的路由,通过调用路由的</span><br><span class="line">addRoutes 添加动态路由，解决页面刷新<span class="number">404</span>的问题 原因：<span class="number">1.</span>addRoutes添加路由配置不是立即失效，需要下一次跳转才生效 <span class="keyword">return</span> <span class="title function_">next</span>(to.<span class="property">path</span>)</span><br><span class="line"><span class="number">5.</span>按钮权限,保证不同的角色页面上有不同按钮,一般通过定义全局方法,要么在<span class="title class_">Vue</span>原型链上,要么通</span><br><span class="line">过全局混入方法,在页面按钮通过v-<span class="keyword">if</span>调用方法,并且传标识,在用户权限数据当中判断改用户是否有该</span><br><span class="line">按钮的权限</span><br><span class="line">/ <span class="number">1.</span>以原型的方式控制按钮的禁用</span><br><span class="line"> <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasPermission</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line"><span class="comment">//   / 加try catch是因为，当我们退出登录的时候，会清除到userInfo里面的东西，防止报错</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>.<span class="property">roles</span>.<span class="property">points</span>.<span class="title function_">includes</span>(key)</span><br><span class="line">   &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 2.以自定义指令控制</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;has-perm&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el, options</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>.<span class="property">roles</span>.<span class="property">points</span>.<span class="title function_">includes</span>(options.<span class="property">value</span>)) &#123;</span><br><span class="line">        el.<span class="title function_">remove</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3.通过vuex的getters</span></span><br><span class="line"><span class="comment">// 4.通过computed</span></span><br><span class="line"><span class="comment">// 混入mixin</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">hasPermission</span>(<span class="params">key</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>.<span class="property">roles</span>.<span class="property">points</span>.<span class="title function_">includes</span>(key)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="6-页面缓存控制"><a href="#6-页面缓存控制" class="headerlink" title="6.页面缓存控制"></a>6.页面缓存控制</h4><p><strong>背景</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们实现一个列表页面,当点击详情,或者点击其他栏目之后,再返回列表页面的时候,我们希望回到离开之前的列表页面,并且回来的时候,滚动条的位置,分页信息,频道信息都是我们离开之前样子,这种情况下我们就需要做页面的缓存</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">通过使用&lt;keep-alive&gt;组件来包裹&lt;router-view&gt;实现缓存页面,在这里我们还得注意保存下滚动条的位置和防止所有页面都被缓存</span><br><span class="line">这样的问题，当前从我的模块切换到主页模块,频道没变,但是滚动条的位置恢复到第一个条记录那里，解决了离开某个页面，回来的还是那个页面，但我们有时候并不希望所有的组件都缓存，缓存所有的组件，不但用处不大，且消耗内存，导致程序性能下降，这时可以有<span class="number">4</span>种方法</span><br><span class="line"><span class="number">1.</span>通过v-<span class="keyword">if</span> 我们给所有的路由配置一个meta对象，设置一个属性为keepAlive，属性值根据我们想不想这个组件缓存如果想的话，就设置为<span class="literal">true</span>，不想的话设置为<span class="literal">false</span>，在我们的路由出口下下面这样设置，如果keepAlive为<span class="literal">true</span>就会缓存了</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keppAlive&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-else</span>&gt;</span> <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="number">2.</span>&lt;keep-alive&gt;&lt;/keep-alive&gt;还有三个方法</span><br><span class="line"> &lt;keep-alive :includes=<span class="string">&quot;[]&quot;</span>&gt;&lt;<span class="regexp">/keep-alive&gt; /</span><span class="regexp">//</span>数组里包含了我们要缓存的组件名称</span><br><span class="line"> &lt;keep-alive :excludes=<span class="string">&quot;[]&quot;</span>&gt;&lt;<span class="regexp">/keep-alive&gt; /</span><span class="regexp">//</span>数组里包含了我们不缓存的组件名称</span><br><span class="line">还有一个是用正则来筛选</span><br><span class="line">解决滚动条，离开当前页面后回到当前页面滚动条没有缓存</span><br><span class="line"><span class="number">1.</span> <span class="comment">/* 固定文章列表的高度,让滚动条出现在.article-list元素(也就是我们的列表容器)上 */</span></span><br><span class="line">    .<span class="property">article</span>-list &#123;</span><br><span class="line">      <span class="attr">height</span>: 85vh;</span><br><span class="line">      overflow-<span class="attr">y</span>: auto;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//监听滚动条的滚动,保存滚动条的位置 给我们的列表加上ref属性</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">listRef</span>.<span class="property">onscroll</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;scrollTop&#x27;</span>, e.<span class="property">target</span>.<span class="property">scrollTop</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="comment">// 变为激活状态</span></span><br><span class="line">    <span class="title function_">activated</span>(<span class="params"></span>) &#123;  <span class="comment">//keep-alive激活状态的生命周期</span></span><br><span class="line">      <span class="comment">// 给.article-list元素赋值滚动条的位置数据</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">listRef</span>.<span class="property">scrollTop</span> = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;scrollTop&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-讲讲-excel-导入和导出的实现"><a href="#7-讲讲-excel-导入和导出的实现" class="headerlink" title="7.讲讲 excel 导入和导出的实现?"></a>7.讲讲 excel 导入和导出的实现?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">公司的导入导出因为数据量并不大,所以采用的主要方式的前端主导的导入导出的方案</span><br><span class="line"><span class="number">1.</span>导入的实现,通过第<span class="number">3</span>方包xlsx把 excel 表格内容解析,转化成 js 的数据类型,然后通过后端批量导入接口</span><br><span class="line">的完成导入</span><br><span class="line"><span class="number">2.</span>这里主要的难点在于数据处理,第<span class="number">3</span>方包处理之后的数据和后端接口要求的数据并不一致(第三方包处理后的数据，对象key是中文的，后端要求是英文的),需要首先定义表头的中英文的映射关系对象,我是新建了一个对象，定义中英的映射关系,然后对数组进行遍历,然后对数组中的对象元素在进行遍历,然后根据映射关系,生成新的对象,和生成新的对象数组,再调用后端的批量导入的接口,传入我们处理好的数据，实现批量导入</span><br><span class="line"><span class="number">4.</span>导出的实现,通过调用的后端接口,获取需要导出的数据,然后转化成第三方包要求的格式,循环的时候通过过滤器处理后端返回的数据和表格数据不一致的问题(过滤掉后端返回数据(数组对象)的属性，我们只要属性值，生成一个二维数组)我用到的是loadsh中的_.<span class="property">pick</span>第一个参数是原对象，第二个参数是数组，需要忽略的属性值,设置我们表格的表头,传入我们处理好的数据给第三方包,通过第三方包生成excel文件,然后触发浏览器的下载功能进行下载</span><br><span class="line"><span class="number">5.</span>这里的难点,也主要在于数据处理,不仅通过双向循环对表头中英文做转换,还需要过滤出部分导出</span><br><span class="line">的字段,和对日期字段,和特殊字段做格式化操作</span><br></pre></td></tr></table></figure>

<h4 id="8-Vue-的路由实现模式：hash-模式和-history-模式"><a href="#8-Vue-的路由实现模式：hash-模式和-history-模式" class="headerlink" title="8.Vue 的路由实现模式：hash 模式和 history 模式"></a>8.Vue 的路由实现模式：hash 模式和 history 模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为 hash，</span><br><span class="line">用 <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span> 读取。</span><br><span class="line">特点：hash值会出现在<span class="variable constant_">URL</span>里面，但是不会出现在<span class="variable constant_">HTTP</span>请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的<span class="variable constant_">IE</span>浏览器也支持这种模式。hash路由被称为是前端路由，已经成为<span class="variable constant_">SPA</span>（单页面应用）的标配。</span><br><span class="line">原理： hash模式的主要原理就是**<span class="title function_">onhashchange</span>()事件**：</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">oldURL</span>, event.<span class="property">newURL</span>);</span><br><span class="line">    <span class="comment">//let hash = location.hash.slice(1);</span></span><br><span class="line">&#125;</span><br><span class="line">使用<span class="title function_">onhashchange</span>()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，<span class="variable language_">window</span>就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的<span class="variable constant_">URL</span>都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的<span class="variable constant_">URL</span>关联起来了。</span><br><span class="line"><span class="number">2.</span> history 模式：</span><br><span class="line">history模式的<span class="variable constant_">URL</span>中没有#，它使用的是传统的路由分发模式，即用户在输入一个<span class="variable constant_">URL</span>时，服务器会接收这个请求，并解析这个<span class="variable constant_">URL</span>，然后做出相应的逻辑处理。history模式需要后台配置支持。如果后台没有正确配置，访问时会返回<span class="number">404</span>。</span><br><span class="line">history 采用 <span class="title class_">HTML5</span> 的新特性；且提供了两个新方法： <span class="title function_">pushState</span>()， <span class="title function_">replaceState</span>()可以对浏览器历史记录栈进行修改，以及 popState事件的监听到状态变更,**切换历史状态：** 包括<span class="string">`forward()`</span>、<span class="string">`back()`</span>、<span class="string">`go()`</span>三个方法，对应浏览器的前进，后退，跳转操作。</span><br><span class="line">缺点:就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出<span class="number">404</span>来。</span><br><span class="line">解决方法:<span class="attr">https</span>:<span class="comment">//www.npmjs.com/package/http-proxy-middleware    http-proxy-middleware插件</span></span><br><span class="line">vue中实现history模式</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">mode</span>:history,</span><br><span class="line">&#125;)</span><br><span class="line">- hash模式</span><br><span class="line"><span class="number">1.</span>hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为 hash，</span><br><span class="line">用 <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span> 读取。</span><br><span class="line">  原理: vue通过监听location.<span class="property">hash</span>值的变化俩切换页面  <span class="title function_">onhashchange</span>()事件</span><br><span class="line">  特征: 通过url的锚点改变来切换页面</span><br><span class="line">  优点: 不需要刷新页面(不需要后端配合)</span><br><span class="line">  缺点: 丑</span><br><span class="line">- history模式</span><br><span class="line">  原理: vue通过监听history的api调用来切换页面</span><br><span class="line">  特征: 通过history.<span class="property">pushState</span>方法调用,完成页面跳转,不需要刷新(第一次访问页面是存在刷新的,第二次以后才不刷新)</span><br><span class="line">  优点: 漂亮</span><br><span class="line">  缺点: 需要后端配合,就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出<span class="number">404</span></span><br></pre></td></tr></table></figure>

<h4 id="9-项目中使用CDN"><a href="#9-项目中使用CDN" class="headerlink" title="9.项目中使用CDN"></a>9.项目中使用CDN</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">执行打包的时候，给打包命令加一个   --report      生成 report.<span class="property">html</span> 以帮助分析包内容 我们则查看哪些包体积过大，则使用cdn</span><br><span class="line"><span class="number">1.</span>引入外部的cdn，减少包体积大小  <span class="attr">https</span>:<span class="comment">//cdn.bytedance.com/</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/dayjs/1.10.8/dayjs.min.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="number">2.</span>配置我们的webpack  <span class="attr">https</span>:<span class="comment">//webpack.docschina.org/configuration/externals#example</span></span><br><span class="line">因为我们的<span class="keyword">import</span> 是默认从node-modelus去找的</span><br><span class="line">在vue.<span class="property">config</span>.<span class="property">js</span></span><br><span class="line"><span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">externals</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? &#123;  <span class="comment">//判断当前是否是在生产环境，因为我们vue调试工具在生产环境下会失效，好像使用cdn后，就会进去生产环境，但我们还想调试代码</span></span><br><span class="line">        查看模式 <span class="attr">https</span>:<span class="comment">//cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F</span></span><br><span class="line">      <span class="comment">// window可以省略</span></span><br><span class="line">      <span class="comment">// 左边- import from &#x27;xxx&#x27;</span></span><br><span class="line">      <span class="comment">// 右边- window.yyy</span></span><br><span class="line">      <span class="comment">// 通过import from &#x27;xxx&#x27; 会去window.yyy上面去找东西</span></span><br><span class="line">      <span class="attr">dayjs</span>: <span class="string">&#x27;window.dayjs&#x27;</span>,</span><br><span class="line">      <span class="attr">xlsx</span>: <span class="string">&#x27;XLSX&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;cos-js-sdk-v5&#x27;</span>: <span class="string">&#x27;COS&#x27;</span>,</span><br><span class="line">      <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;element-ui&#x27;</span>: <span class="string">&#x27;ELEMENT&#x27;</span></span><br><span class="line">    &#125; : &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  在public中的index.<span class="property">html</span>中也需要判断 </span><br><span class="line">语法 <span class="attr">https</span>:<span class="comment">//cli.vuejs.org/zh/guide/html-and-static-assets.html#%E6%8F%92%E5%80%BC</span></span><br><span class="line">&lt;% <span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span>===<span class="string">&#x27;production&#x27;</span>) &#123; %&gt; </span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/dayjs/1.10.8/dayjs.min.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">      &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<h4 id="10-讲讲国际化的实现思路"><a href="#10-讲讲国际化的实现思路" class="headerlink" title="10.讲讲国际化的实现思路"></a>10.讲讲国际化的实现思路</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">国际化的实现思路主要是通过 vue-i18n 国际化插件实现的</span><br><span class="line"><span class="number">1.</span>首先需要提前准备好国际化需要的语言包,也就是语言之间的对应关系的语言包文件</span><br><span class="line"><span class="number">2.</span>在项目里安装了 vue-i18n 国际化包,在 <span class="title class_">Vue</span> 原型上挂载了转化方法</span><br><span class="line"><span class="number">3.</span>在组件中需要做国际化的地方 通过转化方法$t,对对应的文字进行方法调用转化为特定的语言显示</span><br><span class="line"><span class="number">5.</span>数据持久化(不让刷新后的语言模式恢复到默认模式)</span><br><span class="line"><span class="number">6.</span>在用户点击语言切换的下拉选项,通过给 $i18n.<span class="property">locale</span> 赋值当前语言类型,页面会自动更换语言显</span><br><span class="line">示</span><br></pre></td></tr></table></figure>

<h3 id="九-前端话术"><a href="#九-前端话术" class="headerlink" title="九.前端话术"></a>九.前端话术</h3><h4 id="1-什么是前端跨平台"><a href="#1-什么是前端跨平台" class="headerlink" title="1.什么是前端跨平台"></a>1.什么是前端跨平台</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前端跨平台是指可以在不同的操作系统、不同的浏览器或设备上运行相同的前端应用程序，达到统一的用户体验</span><br><span class="line">主要技术是： <span class="number">1.</span>响应式设计  通过 <span class="title class_">CSS3</span> 媒体查询和弹性布局等技术，使得网站在不同的设备上能够自适应地显示，并提供统一的用户体验。</span><br><span class="line">           <span class="number">2.</span>uniapp 一套代码，可打包到多个终端。</span><br></pre></td></tr></table></figure>

<h4 id="2-dev保护分支"><a href="#2-dev保护分支" class="headerlink" title="2.dev保护分支"></a>2.dev保护分支</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dev&quot;</span> 保护分支通常是指在 <span class="title class_">Git</span> 分支模型中，用于开发和测试的主干分支。在一些团队中，通常将 <span class="string">&quot;dev&quot;</span> 分支设置为保护分支，以确保该分支上的代码是经过审核和验证的。</span><br><span class="line">具体来说，保护 <span class="string">&quot;dev&quot;</span> 分支可以规范以下操作：</span><br><span class="line"><span class="number">1.</span>直接 push 代码：只有合法的 <span class="title class_">Pull</span> <span class="title class_">Request</span> 被审查并且审核通过之后，才能将代码 push 到 <span class="string">&quot;dev&quot;</span> 分支上。</span><br><span class="line"><span class="number">2.</span>强制 push 代码：设置了保护分支的仓库不允许对文件做 force push 操作，这样可以预防重要的更改因 force push 导致历史记录丢失或被破坏的情况。</span><br><span class="line"><span class="number">3.</span>删除分支：需要特定权限才能够删除 <span class="string">&quot;dev&quot;</span> 分支，这样可以避免误删或者恶意删除 <span class="string">&quot;dev&quot;</span> 分支的情况发生。</span><br><span class="line"><span class="number">4.</span>标题推送：保护 <span class="string">&quot;dev&quot;</span> 分支可以限制谁能够向 <span class="string">&quot;dev&quot;</span> 分支上添加标签，这样可以避免非授权用户在 <span class="string">&quot;dev&quot;</span> 分支上添加标签的情况。</span><br><span class="line">保护 <span class="string">&quot;dev&quot;</span> 分支可以有效保证项目代码的可靠性和稳定性，从而减少开发和测试的错误和风险。同时，根据团队实际情况和流程需求，也可以设置其他分支为保护分支，比如主干分支 <span class="string">&quot;master&quot;</span> 或者长期支持版本的分支。</span><br></pre></td></tr></table></figure>

<h4 id="3-项目本地开发完成后部署到服务器后报404是什么原因呢"><a href="#3-项目本地开发完成后部署到服务器后报404是什么原因呢" class="headerlink" title="3.项目本地开发完成后部署到服务器后报404是什么原因呢"></a>3.项目本地开发完成后部署到服务器后报404是什么原因呢</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">404</span> 错误一般表示找不到资源，这可能是因为项目在本地开发时使用的路由路径和部署到服务器上时实际访问的 <span class="variable constant_">URL</span> 不一致导致的。</span><br><span class="line">具体来说，可以出现 <span class="number">404</span> 错误的原因包括：</span><br><span class="line"><span class="number">1.</span>路由路径不匹配：例如在本地开发时使用的路由路径为 /home，但是部署到服务器上后实际访问的 <span class="variable constant_">URL</span> 为 <span class="attr">http</span>:<span class="comment">//example.com/，没有匹配到 /home 路径，就会返回 404 错误。</span></span><br><span class="line"><span class="number">2.</span>静态资源路径错误：例如页面中引用的 <span class="variable constant_">CSS</span>、<span class="variable constant_">JS</span> 或图片等静态资源路径在服务器上不存在或者路径不正确，也会导致 <span class="number">404</span> 错误。</span><br><span class="line"><span class="number">3.</span>服务器配置问题：例如服务器未正确配置路由或静态资源的映射，或者是防火墙、<span class="title class_">Nginx</span> 等反向代理软件的配置问题，也可能导致 <span class="number">404</span> 错误。</span><br><span class="line">解决方法通常需要结合具体情况，可以检查路由配置、静态资源路径、服务器配置等方面是否与实际情况一致，并进行相应的调整。</span><br></pre></td></tr></table></figure>



<h3 id="十-小程序相关"><a href="#十-小程序相关" class="headerlink" title="十.小程序相关"></a>十.小程序相关</h3><h4 id="1-小程序导航"><a href="#1-小程序导航" class="headerlink" title="1.小程序导航"></a>1.小程序导航</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>声明式导航</span><br><span class="line">&lt;navigator url=<span class="string">&quot;/pages/my/my&quot;</span> open-type=<span class="string">&quot;switchTab&quot;</span>&gt;跳转到tabbar页面&lt;<span class="regexp">/navigator&gt; /</span><span class="regexp">//</span>跳转到tabar页面必须要加open-type</span><br><span class="line"><span class="comment">//非tabbar就可以省略，传参的话直接拼接在路由路径的后面，接收的话在目标路由的onload(options)里面接收,tabbar不能传参</span></span><br><span class="line"><span class="number">2.</span>编程式导航</span><br><span class="line"> <span class="number">2.1</span> 跳转到非tabbar页面 </span><br><span class="line"> <span class="title function_">click</span>(<span class="params"></span>)&#123;</span><br><span class="line">      wx.<span class="title function_">navigateTo</span>(&#123; </span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;/pages/messgae/messgae&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="number">2.2</span> 跳转到tabbar页面</span><br><span class="line">   <span class="title function_">switchTab</span>(<span class="params"></span>) &#123;</span><br><span class="line">    wx.<span class="title function_">switchTab</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;/pages/my/my&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>2.插槽</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>小程序的插槽只是vue在父页面中的&lt;template&gt;&lt;template&gt;换成了view，其他的都一样的</span><br></pre></td></tr></table></figure>



<h3 id="十一-ts相关"><a href="#十一-ts相关" class="headerlink" title="十一.ts相关"></a>十一.ts相关</h3><h4 id="1-ts数据类型"><a href="#1-ts数据类型" class="headerlink" title="1.ts数据类型"></a>1.ts数据类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> number, string, boolean, <span class="literal">null</span>, <span class="literal">undefined</span>, symbol, bigint 与 js 基本数据类型相同，但是都小写</span><br><span class="line"><span class="number">2.</span> 数组, 对象, 函数，与 js 复杂数据类型相同，数组约定 类型[], 对象约定：&#123;属性: 类型&#125;，函数约定：(参数:类型)=&gt;返回值类型</span><br><span class="line"><span class="number">3.</span> 元组类型限制数组和每一个元素的类型，enum 枚举类型可以用点号访问枚举量，interface 接口可以约定对象类型，且运用 <span class="keyword">extends</span>，合并实现面向对象的类型定义，any 代表任意类型，unknown 代表任意类型但不能用于赋值，never 代表类型的空</span><br><span class="line"><span class="number">4.</span> 对象类型可以约定函数重载，语法是：&#123;(参数:类型):返回值类型; (参数:类型):返回值类型&#125;，<span class="title class_">Vue3</span> 中的 defineEmits 采用了对象类型约定函数重载</span><br><span class="line"><span class="number">5.</span> 字符串可以约定模板字符串类型，语法<span class="string">`<span class="subst">$&#123;类型&#125;</span>-<span class="subst">$&#123;类型&#125;</span>`</span>，可以限制字符串具体形式</span><br></pre></td></tr></table></figure>

<h4 id="2-type-和-interface的区别"><a href="#2-type-和-interface的区别" class="headerlink" title="2.type 和 interface的区别"></a>2.type 和 interface的区别</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">interface</span> 不用写 =</span><br><span class="line"><span class="number">2.</span><span class="keyword">interface</span> 可以 <span class="keyword">extends</span>，<span class="keyword">type</span> 可以 &amp;</span><br><span class="line"><span class="number">3.</span><span class="keyword">interface</span> 只能声明复杂类型，<span class="keyword">type</span> 也可以声明简单类型</span><br><span class="line"><span class="number">4.</span><span class="keyword">interface</span> 可以声明很多次被合并，<span class="keyword">type</span> 只能声明一次</span><br><span class="line"><span class="comment">//类型继承</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Car</span> = &#123;</span><br><span class="line">  <span class="attr">speed</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">drive</span>:<span class="function">()=&gt;</span><span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Audi</span> = <span class="title class_">Car</span> &amp; &#123;<span class="attr">name</span>:<span class="string">&#x27;audi&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Car2</span>&#123;</span><br><span class="line">  <span class="attr">speed</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">drive</span>:<span class="function">()=&gt;</span><span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Audi</span> <span class="keyword">extends</span> &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;audi&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-用冒号和-x3D-gt-声明函数返回值类型有什么区别？"><a href="#3-用冒号和-x3D-gt-声明函数返回值类型有什么区别？" class="headerlink" title="3.用冒号和&#x3D;&gt;声明函数返回值类型有什么区别？"></a>3.用冒号和&#x3D;&gt;声明函数返回值类型有什么区别？</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用冒号声明函数返回值表示声明 <span class="keyword">function</span> 或函数重载</span><br><span class="line">用=&gt;声明函数返回值类型表示定义整个函数的类型</span><br><span class="line"><span class="comment">// 定义function</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>):<span class="built_in">number</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义函数重载</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Test2</span> = &#123;</span><br><span class="line">  ():<span class="built_in">number</span>;</span><br><span class="line">  (<span class="attr">a</span>:<span class="built_in">string</span>):<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">test2</span>:<span class="title class_">Test2</span> = (a?:<span class="built_in">string</span>):<span class="function"><span class="params">any</span> =&gt;</span> <span class="keyword">typeof</span> a ===<span class="string">&#x27;string&#x27;</span>? <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line"><span class="comment">// 定义整个函数类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Test3</span> = <span class="function">()=&gt;</span><span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">test3</span>:<span class="title class_">Test3</span> = <span class="function">()=&gt;</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>4.泛型工具</p>
<h3 id="十二-webpack"><a href="#十二-webpack" class="headerlink" title="十二.webpack"></a>十二.webpack</h3><h4 id="1-为什么需要webpack"><a href="#1-为什么需要webpack" class="headerlink" title="1.为什么需要webpack"></a>1.为什么需要webpack</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Webpack</span> 是一个模块打包工具，它可以将项目中的多个模块（如 <span class="title class_">JavaScript</span>、<span class="variable constant_">CSS</span>、图片等）打包成一个或多个静态资源文件，以便在网页中引用。使用 <span class="title class_">Webpack</span> 的好处包括：</span><br><span class="line"><span class="number">1.</span>可以集成多种模块化开发方式，如 <span class="title class_">CommonJS</span>、<span class="variable constant_">AMD</span>、<span class="title class_">ES6</span> 模块等。</span><br><span class="line"><span class="number">2.</span>可以自动化处理模块之间的依赖关系，减少手动管理代码的复杂度。</span><br><span class="line"><span class="number">3.</span>可以进行代码压缩和混淆，减小输出文件的体积，提高页面加载速度。</span><br><span class="line"><span class="number">4.</span>可以支持开发环境和生产环境的不同配置，提高项目的可维护性。</span><br><span class="line">因此，<span class="title class_">Webpack</span> 在现代前端项目开发中被广泛使用，是一个非常重要的工具。</span><br><span class="line"><span class="comment">//大老高的总结</span></span><br><span class="line"><span class="comment">//webpack 帮你解决了什么问题? 它是如何把很多 js 文件 merge 到一个 js 文件的?</span></span><br><span class="line"><span class="comment">//为什么不会有冲突? 如果js 文件之间有依赖， 它是如何解决的?</span></span><br><span class="line"><span class="number">1.</span>webpack本身就是打包工具，它可以将js进行打包 压缩成一个js包，然后里面loader 和plugin相当于webpack的扩展功能，loader主要负责对于非js文件的转化，比如 vue-loader. sass-loader less-loader file-loader url-loader</span><br><span class="line"><span class="number">2.</span>还有plugin。是一些功能插件 主要负责在 打包生命周期中 处理一些逻辑 比如 我们的htmlTemplatePlugin  可以将单页应用中的js进行合成 ，</span><br><span class="line"><span class="number">3.</span>webpack会分析js中的引用关系，也就是说分析成一个依赖树，根据这个树进行打包，所以说引用多次的内容 只会打包一次。如果说引用了但是没有使用会排出打包</span><br></pre></td></tr></table></figure>

<h4 id="2-webpack新特性"><a href="#2-webpack新特性" class="headerlink" title="2.webpack新特性"></a>2.webpack新特性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Webpack</span> <span class="number">5</span> 是 <span class="title class_">Webpack</span> 的最新版本，相比于之前的版本，它带来了许多新特性和优化，包括：</span><br><span class="line"><span class="number">1.</span>开箱即用支持 <span class="title class_">ES6</span> 模块：<span class="title class_">Webpack</span> <span class="number">5</span> 支持对浏览器原生的 <span class="title class_">ES6</span> 模块的导入和导出语法进行转换和打包，不再需要额外的 babel 转换。</span><br><span class="line"><span class="number">2.</span>零配置使用：<span class="title class_">Webpack</span> <span class="number">5</span> 提供了一套默认配置，可以让开发者直接使用，不需要进行额外的配置，只需在命令行中指定入口文件即可开始打包。</span><br><span class="line"><span class="number">3.</span>速度提升：<span class="title class_">Webpack</span> <span class="number">5</span> 通过使用持久化缓存和增强<span class="title class_">Tree</span> <span class="title class_">Shaking</span>算法等手段，大幅提高了打包速度。</span><br><span class="line"><span class="number">4.</span>更好的代码拆分：<span class="title class_">Webpack</span> <span class="number">5</span> 对模块拆分进行了优化，可以更加灵活地配置拆分策略，同时还支持基于引用次数的自动拆分，减少重复加载同一模块的情况。</span><br><span class="line"><span class="number">5.</span>全局资源引用的优化：<span class="title class_">Webpack</span> <span class="number">5</span> 可以通过设置 moduleIds 和 chunkIds，生成固定的 <span class="variable constant_">ID</span>，优化资源的引用顺序和命名规则，减少因为引用顺序问题而产生的副作用，如破坏 <span class="variable constant_">CSS</span> 中的样式、触发 <span class="variable constant_">JS</span> 的副作用等。</span><br><span class="line"><span class="number">6.</span><span class="title class_">WebAssembly</span> 的支持：<span class="title class_">Webpack</span> <span class="number">5</span> 具备对 <span class="title class_">WebAssembly</span> 模块的构建和优化能力。</span><br><span class="line">这些新特性使得 <span class="title class_">Webpack</span> <span class="number">5</span> 更加易用、高效和灵活，促进了现代前端项目的开发。</span><br></pre></td></tr></table></figure>

<h3 id="十三-面试真题"><a href="#十三-面试真题" class="headerlink" title="十三.面试真题"></a>十三.面试真题</h3><h4 id="1-聊聊vue2和vue3的响应式原理"><a href="#1-聊聊vue2和vue3的响应式原理" class="headerlink" title="1.聊聊vue2和vue3的响应式原理"></a>1.聊聊vue2和vue3的响应式原理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>vue2中</span><br><span class="line">在 <span class="title class_">Vue</span> 实例初始化时，通过遍历 data 对象及其所有属性进行递归，并对对象属性使用 <span class="title class_">Object</span>.<span class="property">defineProperty</span> 进行 getter/setter 的绑定。当用到某个数据时，在getter函数中进行依赖收集，当数据发生变更时，在setter 函数异步的调用render函数(使用的是发布订阅)，返回虚拟dom，再调用diff函数，对比新旧虚拟dom，进行差异化更新，最后，patch，渲染页面</span><br><span class="line">缺陷是： <span class="number">1.1</span> 初始化时，需要递归的给每个data中的数据绑定getter和setter，如果数据很多的话，就容易栈溺出，而且页面加载比较慢</span><br><span class="line">         <span class="number">2.2</span> 不能监听对象和数组下标修改属性，或新增属性，解决办法还是有，vue2重写了数组的方法，push put...还有 <span class="variable language_">this</span>.$set()</span><br><span class="line">          语法是 <span class="variable language_">this</span>.$set(target, key, value) 我记得<span class="title class_">Object</span>.<span class="title function_">assign</span>()好像也可以 <span class="comment">// 利用 Object.assign 动态添加属性</span></span><br><span class="line">          <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>.<span class="property">data</span>, &#123;<span class="attr">newData</span>: <span class="string">&#x27;new data&#x27;</span>&#125;)</span><br><span class="line"><span class="number">2.</span>vue3中 响应式系统使用 <span class="title class_">ES6</span> <span class="title class_">Proxy</span> 对象</span><br><span class="line">在创建 reactive 对象时，<span class="title class_">Vue</span>.<span class="property">js</span> <span class="number">3.</span>x 使用 <span class="keyword">new</span> <span class="title class_">Proxy</span>() 函数来包装原始数据对象（例如 data），然后返回一个新的代理对象。</span><br><span class="line">如果应用程序取回被代理的数据，则代理对象会返回封装的值，同时也会收集读取操作的依赖（即类似于 <span class="title class_">Vue</span>.<span class="property">js</span> <span class="number">2.</span>x 的 getter）。</span><br><span class="line">当一个值被修改时，代理对象将通过自身 set 函数来拦截该操作，并触发更新策略。这个过程与 <span class="title class_">Vue</span>.<span class="property">js</span> <span class="number">2.</span>x 类似 -- 所有依赖项将会在更新队列中排队并等待下一个 tick 进行更新。</span><br><span class="line">优点:</span><br><span class="line"><span class="number">2.1</span>数组变化检测的性能得到改善，数组的变化可以直接被 <span class="title class_">Proxy</span> 劫持到。</span><br><span class="line"><span class="number">2.2</span>对象中的属性动态添加/删除问题也得到了解决。<span class="title class_">Proxy</span> 代理对象可直接监听所有新加或移除属性，并进行相应操作。</span><br><span class="line"><span class="number">2.</span>3<span class="built_in">Proxy</span> 监听添加或删除属性比 <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>() 监听大数据对象变化更高效，因为 <span class="title class_">Proxy</span> 只针对被新增、修改和删除对象进行响应。</span><br><span class="line">因此，<span class="title class_">Vue</span>.<span class="property">js</span> <span class="number">3.</span>x 在响应式系统方面的优化显著提升了 <span class="title class_">Vue</span>.<span class="property">js</span> 开发的效率和性能，特别是在处理大量数据时更加具有优势。</span><br></pre></td></tr></table></figure>

<h4 id="2-ref和reactive区别"><a href="#2-ref和reactive区别" class="headerlink" title="2.ref和reactive区别"></a>2.ref和reactive区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用场景不同：</span><br><span class="line"><span class="number">1.</span>ref 主要用于包装基本数据类型（例如数字、字符串等），以便能够通过类似变量的操作直接读取和修改其值；而 reactive 则用于包装复杂数据类型（例如对象、数组等），并将其转换为响应式对象，以便在数据发生变化时自动触发更新。</span><br><span class="line"><span class="comment">//注意一点的是ref也能定义复杂数据类型，它的底层是借助了reactive函数</span></span><br><span class="line"><span class="number">2.</span>对象属性访问方式不同：使用 ref 定义的变量，在模板中需要通过 .<span class="property">value</span> 来获取其实际值，否则会只获取其内部包装对象；而 reactive 对象的内部属性可以直接访问，无需手动添加 .<span class="property">value</span>。</span><br><span class="line"><span class="number">3.</span>内部实现原理不同：ref 通过封装一个普通的 <span class="title class_">JavaScript</span> 值来实现响应式，并使用了 <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>() 方法对其读取和修改进行拦截处理；而 reactive 则是通过 <span class="title class_">Proxy</span> 来代理整个对象，并在其中拦截了对象上的所有操作，从而实现了对嵌套属性的监听支持。</span><br></pre></td></tr></table></figure>

<h4 id="3-vue3的组件通信方式有哪些？和vue2通信的区别"><a href="#3-vue3的组件通信方式有哪些？和vue2通信的区别" class="headerlink" title="3.vue3的组件通信方式有哪些？和vue2通信的区别"></a>3.vue3的组件通信方式有哪些？和vue2通信的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vue3</span><br><span class="line"><span class="number">1.</span><span class="title class_">Props</span>：用于父组件向子组件传递数据的主要方式，使用时需要在子组件中声明 props 接收传递过来的值。</span><br><span class="line"><span class="number">2.</span><span class="title class_">Emit</span>：用于子组件向父组件传递数据的方法，通过在子组件中使用 $emit() 方法触发事件并将数据传递给父组件。</span><br><span class="line"><span class="number">3.</span><span class="title class_">Provide</span> / <span class="title class_">Inject</span>：用于父组件向子孙组件传递数据的一种依赖注入方式，在父组件中使用 provide 提供数据，在子孙组件中使用 inject 注入数据。</span><br><span class="line"><span class="number">4.</span>利用 ref 和 setup 函数内部的变量：在 setup 函数内可以使用 ref 函数来创建响应式引用对象，从而在不同子组件之间进行状态共享。</span><br><span class="line"><span class="number">5.</span>状态管理工具用的是pinia</span><br><span class="line">vue2</span><br><span class="line"><span class="number">1.</span>状态管理工具是vuex</span><br></pre></td></tr></table></figure>

<h4 id="4-vuex和pinia的区别"><a href="#4-vuex和pinia的区别" class="headerlink" title="4.vuex和pinia的区别"></a>4.vuex和pinia的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vuex</span> 和 <span class="title class_">Pinia</span> 都是 <span class="title class_">Vue</span>.<span class="property">js</span> 生态中的状态管理库，并且它们有着不同的特点。</span><br><span class="line"><span class="number">1.</span>数据存储位置不同：</span><br><span class="line"><span class="title class_">Vuex</span> 存储数据的位置是全局唯一的，适用于大型应用或需要多个页面共享状态的场景。而 <span class="title class_">Pinia</span> 存储数据的位置是独立于每个组件实例，因此对其他组件的影响非常小，常用于小型和中型应用，以及针对单个组件封装的插件和组件库。</span><br><span class="line"><span class="number">2.</span>数据操作方式不同：</span><br><span class="line">在 <span class="title class_">Vuex</span> 中，通过 mutations、actions 和 getters 等方式对数据进行操作和获取。相应地，在使用 <span class="title class_">Vuex</span> 时需要提前定义好 state、mutations、actions 和 getters 等模块，这就导致代码量较大，同时也可能出现命名冲突等问题。</span><br><span class="line"><span class="title class_">Pinia</span> 中数据操作的方式则更加简单和易于使用。具体而言，<span class="title class_">Pinia</span> 提供了 <span class="title function_">useStore</span>() 函数来创建 store 实例并访问其中的 state、actions、getters 和 mutations 等属性，这种方式可以减少代码复杂度和提高开发效率。</span><br><span class="line"><span class="number">3.</span>底层实现原理不同：</span><br><span class="line"><span class="title class_">Vuex</span> 的底层使用了 <span class="title class_">Vuex</span>.<span class="property">Store</span> 类来创建一个全局的 <span class="title class_">Store</span> 实例，<span class="title class_">Store</span> 实例包含了 <span class="title class_">State</span>、<span class="title class_">Mutation</span>、<span class="title class_">Action</span>、<span class="title class_">Getter</span> 等对象，<span class="title class_">State</span> 用于管理状态数据，<span class="title class_">Mutation</span> 用于修改状态数据，<span class="title class_">Mutation</span> 必须是同步的修改，<span class="title class_">Action</span> 用于异步修改状态数据，<span class="title class_">Getter</span> 用于获取状态数据。</span><br><span class="line">而 <span class="title class_">Pinia</span> 基于 <span class="title class_">Vue</span>.<span class="property">js</span> 提供的响应式系统，将 state、action 和 getter 统一存储在一个 reactive 对象中，并使用 <span class="title function_">computed</span>() 函数来计算 getter。这种方式简化了状态管理的实现，同时也提供了更好的性能和开发体验。</span><br><span class="line">综上所述，<span class="title class_">Vuex</span> 更适合大型应用，<span class="title class_">Pinia</span> 更适合小型和中型应用。如果需要引入全局状态管理，使用 <span class="title class_">Vuex</span> 特别有优势，如果只是针对单个页面或组件进行状态管理，建议选择 <span class="title class_">Pinia</span>，它的使用体验更好，代码更加简洁易懂</span><br></pre></td></tr></table></figure>

<h4 id="5-项目中的路由你是怎么做的，用的什么模式？"><a href="#5-项目中的路由你是怎么做的，用的什么模式？" class="headerlink" title="5.项目中的路由你是怎么做的，用的什么模式？"></a>5.项目中的路由你是怎么做的，用的什么模式？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>我用的是vue-router@<span class="number">4</span> ，vue3的版本，我首先是去下载路由插件嘛，然后我是创建了一个文件夹，router，里面新建了一个index.<span class="property">ts</span>文件，在文件中我引入了 <span class="keyword">import</span> &#123; createRouter,createWebHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>  ,创建router实例，配置路由规则，导出路由实例，在main.<span class="property">ts</span>中引入，并用use函数注册，use函数在内部就会先判断当前插件注册过没，没有的话就调用插件上的instoll方法，并记录，</span><br><span class="line">安装过的话就直接<span class="keyword">return</span> app ,这也是use能链式调用的原因，还有的话是，路由提供了路由守卫，我用的是router.<span class="property">beforEach</span>,它是在跳转路由之前进行拦截，我当时是用它来做一个路由拦截，判断用户登没登录，它提供了<span class="number">3</span>个参数，一个是to 代表要去哪个路由，<span class="keyword">from</span>是从那个路由来的，next是放行的意思，我之前，还用它做过菜单权限，具体是在登录完成后,在路由前置守卫中,获取用户的权限信息,然后筛选有权限访问的路由,通过调用路由的addRoutes 添加动态路由，解决页面刷新<span class="number">404</span>的问题 原因：<span class="number">1.</span>addRoutes添加路由配置不是立即失效，需要下一次跳转才生效 <span class="keyword">return</span> <span class="title function_">next</span>(to.<span class="property">path</span>)</span><br><span class="line"><span class="number">2.</span>我用的是history模式，路由有两种模式嘛，<span class="number">1</span>种是hash模式，url上会有一个#号，不美观，它的原理是利用onhashchange事件来监听hash值的改变来跳转页面，history的话是url没有那个#号，相对比较美观</span><br><span class="line">  原理: vue通过监听history的api调用来切换页面</span><br><span class="line">  特征: 通过history.<span class="property">pushState</span>方法调用,完成页面跳转,不需要刷新(第一次访问页面是存在刷新的,第二次以后才不刷新)</span><br><span class="line">  优点: 漂亮</span><br><span class="line">  缺点: 需要后端配合,就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出<span class="number">404</span></span><br></pre></td></tr></table></figure>

<h4 id="6-vue3中wacth和wacthEffect的区别"><a href="#6-vue3中wacth和wacthEffect的区别" class="headerlink" title="6.vue3中wacth和wacthEffect的区别"></a>6.vue3中wacth和wacthEffect的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">watch 和 watchEffect 都能监听响应式数据的变化，不同的是它们监听数据变化的方式不同。</span><br><span class="line">watch 会明确监听某一个响应数据，而 watchEffect 则是隐式的监听回调函数中响应数据(只要依赖项变了，就会触发)。</span><br><span class="line">watch 在响应数据初始化时是不会执行回调函数的，watchEffect 在响应数据初始化时就会立即执行回调函数</span><br><span class="line"><span class="comment">// watch 实现防抖</span></span><br><span class="line"><span class="title function_">watch</span>(count, <span class="function">(<span class="params">val, _, onCleanup</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> to = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">  <span class="title function_">onCleanup</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 下一次变化时，清除上一次定时器(下一次变化来之前，执行一次)</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(to)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;，</span><br><span class="line"> &#123;</span><br><span class="line">  watch 选项增加 flush，<span class="string">&#x27;pre&#x27;</span> 代表渲染前，‘post’代表渲染后，设置为 post 可以获取到 dom 引用    </span><br><span class="line">   &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-遇到的状态码有哪些，什么情况遇到的"><a href="#7-遇到的状态码有哪些，什么情况遇到的" class="headerlink" title="7.遇到的状态码有哪些，什么情况遇到的"></a>7.遇到的状态码有哪些，什么情况遇到的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="comment">//1XX：信息性状态码</span></span><br><span class="line"><span class="number">100</span> <span class="title class_">Continue</span>：服务器已经接收到请求头，并且将继续处理这个请求。</span><br><span class="line"><span class="number">101</span> <span class="title class_">Switching</span> <span class="title class_">Protocols</span>：客户端正在请求服务器切换协议，比如从 <span class="variable constant_">HTTP</span> <span class="number">1.1</span> 切换到 <span class="title class_">WebSocket</span>。</span><br><span class="line"><span class="number">2.</span> <span class="comment">//2XX：成功状态码</span></span><br><span class="line"><span class="number">200</span> <span class="variable constant_">OK</span>：请求成功，响应中包含所请求的资源。</span><br><span class="line"><span class="number">201</span> <span class="title class_">Created</span>：在服务器上成功创建了新资源。</span><br><span class="line"><span class="number">204</span> <span class="title class_">No</span> <span class="title class_">Content</span>：服务端已经接收到并成功处理了请求，但不会返回消息体内容。</span><br><span class="line"><span class="number">3.</span> <span class="comment">//3XX：重定向状态码</span></span><br><span class="line"><span class="number">301</span> <span class="title class_">Moved</span> <span class="title class_">Permanently</span>：所请求的资源已经被永久移动到其他位置（<span class="variable constant_">URL</span>），响应中包含对新 <span class="variable constant_">URL</span> 的引用。</span><br><span class="line"><span class="number">302</span> <span class="title class_">Found</span>：所请求的资源暂时被移动到其他位置（<span class="variable constant_">URL</span>），响应中包含对新 <span class="variable constant_">URL</span> 的引用。</span><br><span class="line"><span class="number">304</span> <span class="title class_">Not</span> <span class="title class_">Modified</span>：在使用缓存机制的情况下，表示客户端的缓存资源是最新的，无需重新获取。夹带的数据不会发生改变，由于客户端有该文件的缓存，也就不需要从服务端重新pull该文件，而是直接使用本地缓存。</span><br><span class="line"><span class="number">4.</span> <span class="comment">//4XX：客户端错误状态码</span></span><br><span class="line"><span class="number">400</span> <span class="title class_">Bad</span> <span class="title class_">Request</span>：请求参数有误或语法错误，服务器无法理解此请求。</span><br><span class="line"><span class="number">401</span> <span class="title class_">Unauthorized</span>：请求未认证，需要提供身份验证凭据才能访问所请求的资源。</span><br><span class="line"><span class="number">403</span> <span class="title class_">Forbidden</span>：请求被服务器拒绝，没有足够的权限访问所请求的资源。</span><br><span class="line"><span class="number">404</span> <span class="title class_">Not</span> <span class="title class_">Found</span>：所请求的资源不存在于服务器上。</span><br><span class="line"><span class="number">422</span> <span class="title class_">Unprocessable</span> <span class="title class_">Entity</span>：客户端提交了格式正确但无法处理的实体（例如，重复的用户名）。</span><br><span class="line"><span class="number">5.</span> <span class="comment">//5XX：服务器错误状态码</span></span><br><span class="line"><span class="number">500</span> <span class="title class_">Internal</span> <span class="title class_">Server</span> <span class="title class_">Error</span>：服务器遇到了意外情况，且无法处理这个请求。</span><br><span class="line"><span class="number">502</span> <span class="title class_">Bad</span> <span class="title class_">Gateway</span>：代理服务器从上游服务器接收到一个非法的响应。</span><br><span class="line"><span class="number">503</span> <span class="title class_">Service</span> <span class="title class_">Unavailable</span>：服务不可用，一般是由于负载过大或者正在进行服务升级维护等原因导致。</span><br><span class="line"><span class="number">504</span> <span class="title class_">Gateway</span> <span class="title class_">Timeout</span>：代理服务器在规定时间内没有从上游服务器收到请求，通常是由于高并发压力过大导致。</span><br></pre></td></tr></table></figure>

<h4 id="8-你git是怎么实现版本管理的"><a href="#8-你git是怎么实现版本管理的" class="headerlink" title="8.你git是怎么实现版本管理的"></a>8.你git是怎么实现版本管理的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Git</span>通过记录文件的变化来实现版本管理，具体实现过程如下：</span><br><span class="line"><span class="number">1.</span>在本地工作目录中新建或修改文件。</span><br><span class="line"><span class="number">2.</span>使用git add命令添加文件到<span class="title class_">Git</span>暂存区（<span class="title class_">Index</span>）。</span><br><span class="line"><span class="number">3.</span>使用git commit命令将暂存区的所有更改保存到<span class="title class_">Git</span>仓库的一个新版本中，同时记录这个版本的作者、时间等信息。每个新版本都包含了之前所有版本中所有文件内容的快照，因此每个版本都是完整的副本。</span><br><span class="line"><span class="number">4.</span>如果需要查看历史版本，可以使用git log命令列出所有提交记录，每个记录包含作者、提交日期、提交消息和<span class="variable constant_">SHA</span>-<span class="number">1</span>校验和等信息。可以使用<span class="variable constant_">SHA</span>-<span class="number">1</span>校验和查询特定版本。</span><br><span class="line"><span class="number">5.</span>如果需要回退到某个历史版本，可以使用git checkout或git reset命令切换到指定版本。git checkout会创建一个分离头指针，不建议在此基础上进行编辑，而git reset则可以撤销一个或多个提交记录并更新<span class="variable constant_">HEAD</span>分支指针。</span><br><span class="line"><span class="comment">//在使用Git进行版本管理时，通常需要遵循以下几个基本原则：</span></span><br><span class="line"><span class="number">1.</span>频繁地提交：尽量将一些小的修改提交成多个较小的版本。</span><br><span class="line"><span class="number">2.</span>持续记录版本：只要更改了文件就及时提交，不要将太多未提交文件积累。</span><br><span class="line"><span class="number">3.</span>使用分支：如果需要开发新功能或修复bug，则应在一个新分支上进行，不要在主分支上直接修改。</span><br><span class="line"><span class="number">4.</span>定期合并：当开发完成后，在开发分支上使用git merge命令将更改合并到主分支</span><br></pre></td></tr></table></figure>

<h4 id="9-网络劫持"><a href="#9-网络劫持" class="headerlink" title="9.网络劫持"></a>9.网络劫持</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">网络劫持是指黑客或不法分子在网络中篡改、拦截或模拟网络流量，使得用户访问到的网站或服务与其期望不符。网络劫持可以用于信息窃取、钓鱼攻击、广告投放等目的。</span><br><span class="line">常见的网络劫持方式包括：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span><span class="variable constant_">DNS</span>劫持：将域名解析结果篡改为攻击者的<span class="variable constant_">IP</span>地址，使得用户访问的网站实际上是攻击者伪造的网站。</span><br><span class="line"><span class="number">2.</span><span class="variable constant_">HTTP</span>劫持：在数据传输过程中中间人攻击，修改<span class="variable constant_">HTTP</span>报文，使得用户看到的内容不是原始的响应内容。</span><br><span class="line"><span class="number">3.</span><span class="variable constant_">SSL</span> <span class="title class_">Striping</span>: 在<span class="variable constant_">HTTPS</span>请求时，欺骗用户使用<span class="variable constant_">HTTP</span>连接，然后将请求转发到<span class="variable constant_">HTTPS</span>服务器，并获取加密内容。</span><br><span class="line"><span class="number">4.</span><span class="variable constant_">ARP</span>劫持：在局域网中欺骗其他计算机，让它们把数据发给攻击者而非实际的目标机器。</span><br><span class="line"><span class="number">5.</span><span class="title class_">WiFi</span>重定向：伪装<span class="title class_">WiFi</span>热点，让受害者接入该热点并进入假网站。</span><br><span class="line">为了防止网络劫持，我们需要采取以下措施：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>使用<span class="variable constant_">HTTPS</span>协议：通过使用<span class="variable constant_">HTTPS</span>协议来加密数据传输，可以有效防止<span class="variable constant_">SSL</span> <span class="title class_">Striping</span>和<span class="variable constant_">HTTP</span>劫持。</span><br><span class="line"><span class="number">2.</span>确认证书正确性：确保网站提供的<span class="variable constant_">SSL</span>数字证书是由可信机构颁发的，并且可以验证其合法性。</span><br><span class="line"><span class="number">3.</span>避免连接不安全的<span class="title class_">WiFi</span>：尽量避免在公共场所或未经身份认证的<span class="title class_">WiFi</span>上进行敏感操作。</span><br><span class="line"><span class="number">4.</span>安装防护软件：安装有效的网络安全软件来检测并拦截可能存在的攻击行为。</span><br><span class="line"><span class="number">6.</span>确保<span class="variable constant_">DNS</span>服务器安全：使用可信赖的<span class="variable constant_">DNS</span>服务器，并加强对本机和路由器<span class="variable constant_">DNS</span>配置的管理。</span><br><span class="line">总之，要保障自己的信息安全，需要做好网络安全方面的知识储备和相应的预防措施。</span><br></pre></td></tr></table></figure>

<h4 id="10-项目从0到1的开发流程"><a href="#10-项目从0到1的开发流程" class="headerlink" title="10.项目从0到1的开发流程"></a>10.项目从0到1的开发流程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">首先，从<span class="number">0</span>到<span class="number">1</span>的项目开发需要进行详细的需求分析和技术可行性研究。接下来，可以按照以下步骤进行项目实现：</span><br><span class="line"><span class="number">1.</span>编写项目计划书和开发文档，明确项目的目标、功能需求、技术选型、开发流程、测试方案等。</span><br><span class="line"><span class="number">2.</span>进行系统设计与架构设计，根据实际需求进行技术选型，包括数据库、<span class="title class_">Web</span>框架、服务器等。</span><br><span class="line"><span class="number">3.</span>建立代码仓库和版本控制，选择常用的<span class="title class_">Git</span>或者<span class="variable constant_">SVN</span>等工具进行管理和协同开发。</span><br><span class="line"><span class="number">4.</span>根据需求和设计，在本地建立项目文件，并进行静态页面设计，采用<span class="variable constant_">HTML</span>、<span class="variable constant_">CSS</span>、<span class="variable constant_">JS</span>等技术，初步形成项目框架。</span><br><span class="line"><span class="number">5.</span>写出后台<span class="variable constant_">API</span>接口，实现前端页面渲染所需的数据获取，以及提供必要的服务接口等。</span><br><span class="line"><span class="number">6.</span>在前端与后台之间建立数据交互通道，通过<span class="variable constant_">AJAX</span>或<span class="title class_">WebSocket</span>等技术，实现前后端数据交互，并对数据进行验证和安全加密等。</span><br><span class="line"><span class="number">7.</span>完成业务逻辑的编写，实现前端页面与后台<span class="variable constant_">API</span>的交互，包括表单提交、搜索、筛选、排序、分页、数据展示等。</span><br><span class="line"><span class="number">8.</span>系统性能优化，包括网站速度优化、<span class="variable constant_">CDN</span>以及缓存技术、并发性和负载均衡、数据备份与恢复等。</span><br><span class="line"><span class="number">9.</span>测试和调试，进行单元测试和功能测试，并进行性能测试和安全测试，确保系统符合需求和规格要求。</span><br><span class="line"><span class="number">10.</span>部署和上线，搭建服务器环境并进行部署，包括数据库配置、文件上传、域名设置等。同时，确保系统的安全性，防止系统漏洞被利用。</span><br><span class="line">以上是一般情况下项目从<span class="number">0</span>到<span class="number">1</span>的开发流程，具体的实现细节会因项目类型和技术栈而异，开发过程中还需要不断优化和迭代。</span><br></pre></td></tr></table></figure>

<h4 id="11-项目发布上线后，你会做哪些事情"><a href="#11-项目发布上线后，你会做哪些事情" class="headerlink" title="11.项目发布上线后，你会做哪些事情"></a>11.项目发布上线后，你会做哪些事情</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在项目发布上线后，以下是我会关注和做的事情：</span><br><span class="line"><span class="number">1.</span>监控系统状态：确保系统正常运行，并关注服务器资源、流量峰值、系统负载等指标。可以通过各种监控工具进行监控，如<span class="title class_">Prometheus</span>、<span class="title class_">Zabbix</span>、<span class="title class_">Nagios</span>等。</span><br><span class="line"><span class="number">2.</span>处理异常情况：及时处理前台报错信息和服务端日志，发现问题并快速解决。这部分可以借助日志分析与处理工具，如<span class="title class_">Graylog</span>、<span class="variable constant_">ELK</span>等。</span><br><span class="line"><span class="number">3.</span>维护数据安全：定期备份数据，并制订安全策略，例如设置访问权限、防火墙、<span class="variable constant_">HTTPS</span>协议等。</span><br><span class="line"><span class="number">4.</span>升级和维护系统：持续改进和优化程序性能和功能，升级系统依赖库和组件版本，以保持系统安全、可靠、高效。</span><br><span class="line"><span class="number">5.</span>用户反馈与需求收集：及时处理用户反馈信息并优化相关功能。积极收集用户对系统的建议和需求，保证为用户提供更优质的产品和服务。</span><br><span class="line">考虑系统扩展性：因为业务增长或突发需求，系统面临着很高的扩展压力。在平时的维护中，应该考虑系统的可扩展性，避免以后出现扩展难题。</span><br><span class="line"></span><br><span class="line">以上是开发者在项目发布上线后需要关注和做的事情，这些工作都是持续性质的，以确保系统能够平稳地运行和发展。</span><br></pre></td></tr></table></figure>

<h4 id="12-对meta标签的理解"><a href="#12-对meta标签的理解" class="headerlink" title="12.对meta标签的理解"></a>12.对meta标签的理解</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta&gt;标签是<span class="variable constant_">HTML</span>中的一种特殊标签，用于描述网页文档的各种元信息和属性。主要作用包括以下几个方面。</span><br><span class="line"><span class="number">1.</span>定义网页文档的编码格式：通过设置charset属性来指定文档采用的字符集编码，例如：&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line"><span class="number">2.</span>引入外部资源：例如引入<span class="variable constant_">CSS</span>样式表或者<span class="title class_">JavaScript</span>脚本等，在&lt;head&gt;标签内添加&lt;link&gt;或&lt;script&gt;标签即可。</span><br><span class="line"><span class="number">3.</span>描述网页文档的相关信息：使用&lt;meta name=<span class="string">&quot;keywords&quot;</span>&gt; 和&lt;meta name=<span class="string">&quot;description&quot;</span>&gt;等标签来定义页面的关键词和描述信息，以便搜索引擎正确抓取并展示网页信息。</span><br><span class="line"><span class="number">4.</span>控制缓存策略：通过设置&lt;meta http-equiv=<span class="string">&quot;expires&quot;</span>&gt;或者&lt;meta http-equiv=<span class="string">&quot;cache-control&quot;</span>&gt;等属性来定义页面是否能被缓存，以及缓存有效期。</span><br><span class="line"><span class="number">5.</span>支持移动设备：例如设置&lt;meta name=<span class="string">&quot;viewport&quot;</span>&gt;来为不同尺寸和不同设备自适应地调整页面布局和风格。</span><br><span class="line">总之，&lt;meta&gt;标签可以帮助网页提供更多的信息，同时支持页面的优化与最佳实践，也可以使页面适应更多的场景需求，比如渲染速度、<span class="variable constant_">SEO</span>优化、设备兼容性等。</span><br></pre></td></tr></table></figure>

<h4 id="13-常见语义化标签"><a href="#13-常见语义化标签" class="headerlink" title="13.常见语义化标签"></a>13.常见语义化标签</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>&lt;header&gt; 标签：用于定义文档或文档区域的头部，通常包含网站或页面的logo、导航等重要信息。</span><br><span class="line"><span class="number">2.</span>&lt;nav&gt; 标签：用于定义文档或文档区域的导航链接，通常放置在html页面中最顶部或左侧。</span><br><span class="line"><span class="number">3.</span>&lt;section&gt; 标签：用于定义文档中的一个主要节或内容区块，适合用来划分一系列相关文章或新闻的内容。</span><br><span class="line"><span class="number">4.</span>&lt;article&gt; 标签：用于定义一篇文章或者博客，通常包含在 &lt;main&gt;标签之内。</span><br><span class="line"><span class="number">5.</span>&lt;aside&gt; 标签：用于定义当前文档区域之外的附注、广告、支持信息，并不属于主要内容。</span><br><span class="line"><span class="number">6.</span>&lt;footer&gt; 标签：用于定义文档或文档区域的脚注，通常包含版权声明、联系方式、备案号等信息。</span><br><span class="line"><span class="number">7.</span>&lt;main&gt; 标签：表示文档或者应用的主要或核心内容。</span><br></pre></td></tr></table></figure>

<h4 id="14-vue3怎么判断一个数据是不是响应式的"><a href="#14-vue3怎么判断一个数据是不是响应式的" class="headerlink" title="14.vue3怎么判断一个数据是不是响应式的"></a>14.vue3怎么判断一个数据是不是响应式的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="title function_">isRef</span>(<span class="attr">value</span>: any): boolean：用于判断给定的值是否是一个引用（<span class="title class_">Ref</span>）对象，如果是，则返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。例如：</span><br><span class="line"><span class="keyword">import</span> &#123; ref, isRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isRef</span>(count)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isRef</span>(<span class="number">123</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="number">2.</span><span class="title function_">isReactive</span>(<span class="attr">value</span>: any): boolean：用于判断一个对象是否是响应式的，如果是，则返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。例如：</span><br><span class="line"><span class="keyword">import</span> &#123; reactive, isReactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(state)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="15-说说页面布局吧，弹性布局的话"><a href="#15-说说页面布局吧，弹性布局的话" class="headerlink" title="15.说说页面布局吧，弹性布局的话"></a>15.说说页面布局吧，弹性布局的话</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//，有没有去了解过具体实现的原理，比如用<span class="attribute">flex</span>实现盒子垂直水平居中，其中用到的 displav: flex;<span class="attribute">justify-content</span>: center;<span class="attribute">align-items</span>: center;具体是什么原理实现的</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">具体实现的原理如下：</span><br><span class="line"><span class="number">1</span>.弹性容器默认沿着<span class="selector-tag">main</span> axis（水平轴）和cross axis（垂直轴）两个方向排列；</span><br><span class="line"><span class="number">2</span><span class="selector-class">.display</span>: flex;属性会将该元素设置为一个弹性容器，并使其内部所有子元素成为该容器的弹性项，从而能够自动平分宽度并调整其位置；</span><br><span class="line"><span class="number">3</span><span class="selector-class">.justify-content</span>: center;属性用于控制伸缩项在主轴方向上的对齐方式，把它们水平居中对齐；</span><br><span class="line"><span class="number">4</span><span class="selector-class">.align-items</span>: center;属性用于控制伸缩项在交叉轴方向上的对齐方式，把它们垂直居中对齐。</span><br><span class="line"></span><br><span class="line">因此，当<span class="attribute">display</span>: flex;、<span class="attribute">justify-content</span>: center;和<span class="attribute">align-items</span>: center;属性被应用于一个父容器上时，其中所有的子元素都会被居中对齐。通过灵活运用这些CSS属性，我们可以轻松实现各种复杂的页面布局效果。</span><br></pre></td></tr></table></figure>

<h4 id="16-说一下小程序优化"><a href="#16-说一下小程序优化" class="headerlink" title="16.说一下小程序优化"></a>16.说一下小程序优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">小程序的优化主要包括以下几个方面：</span><br><span class="line"><span class="number">1.</span>减小小程序包体积：可以使用分包、压缩、懒加载等技术，减少小程序包体积，加快小程序启动速度。</span><br><span class="line"><span class="number">2.</span>减少 <span class="variable constant_">HTTP</span> 请求数量：减少网络请求可以提高页面加载速度。可以通过合并 <span class="variable constant_">JS</span> 文件或者合并 <span class="variable constant_">CSS</span> 文件，或者使用 <span class="title class_">WebFont</span> 等技术，将多个请求合并为一个 <span class="variable constant_">HTTP</span> 请求。</span><br><span class="line"><span class="number">3.</span>减少重排和重绘：频繁地对 <span class="variable constant_">DOM</span> 进行操作会导致浏览器不断执行重排和重绘的操作，降低小程序性能。针对此问题可以采用避免使用 table 布局、避免使用多层嵌套的 <span class="variable constant_">DOM</span> 结构、避免频繁修改样式等技术方法来减少反复渲染的次数。</span><br><span class="line"><span class="number">4.</span>合理使用 <span class="title class_">Storage</span>：<span class="title class_">Storage</span> 是一种本地存储机制，如果程序中不断往 <span class="title class_">Storage</span> 中写入数据会带来性能上的损失，因此应该限制 <span class="title class_">Storage</span> 的使用，尽可能使用内存变量。</span><br><span class="line"><span class="number">5.</span>少使用定时器：使用过多定时器会影响小程序的性能。为了避免性能问题，建议使用 requestAnimationFrame 替代 <span class="built_in">setTimeout</span> / <span class="built_in">setInterval</span> 来达到页面刷新的目的。</span><br><span class="line"><span class="number">6.</span>减少渲染，减轻渲染负担：减少不必要的数据更新，可以降低小程序顶层的渲染数量；通过点进进行自定义组件化开发，尽量减轻微信渲染引擎渲染次数。</span><br><span class="line"></span><br><span class="line">总之，小程序优化需要从应用的各个方面进行考量和实践，针对性地采取相应的技术手段和策略。</span><br></pre></td></tr></table></figure>

<h4 id="17-小程序如何实现分包"><a href="#17-小程序如何实现分包" class="headerlink" title="17.小程序如何实现分包"></a>17.小程序如何实现分包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">概念：</span><br><span class="line">主包:打开小程序默认加载的页面(总的大小小于2M，不然就要分包),包含<span class="title class_">Tabar</span>页面和pages页面</span><br><span class="line">分包:打开小程序默认不加载的页面，只要路由跳转访问到页面的时候，才去微信服务器要页面(页面懒加载),需要单独配置</span><br><span class="line"><span class="comment">//配置分包	在app.json中</span></span><br><span class="line">  <span class="string">&quot;subPackages&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;root&quot;</span>: <span class="string">&quot;article_pkg&quot;</span>, <span class="comment">//分包的根路径</span></span><br><span class="line">      <span class="string">&quot;pages&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;pages/article/article&quot;</span> <span class="comment">//分包的页面列表</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure>

<h4 id="18-axios的二次请求是如何封装的"><a href="#18-axios的二次请求是如何封装的" class="headerlink" title="18.axios的二次请求是如何封装的"></a>18.axios的二次请求是如何封装的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>我是先下载axios，然后创建一个request.<span class="property">js</span>文件，引入axios，axios不是有个create方法吗，我是创建一个axios实例，设置基地址，以及请求拦截器，因为我们，项目以后如果有新的基地址的话，就又可以创建一个实例，就很方便</span><br></pre></td></tr></table></figure>

<h4 id="19-常见的http状态码"><a href="#19-常见的http状态码" class="headerlink" title="19.常见的http状态码"></a>19.常见的http状态码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span> <span class="attr">OK</span>: 请求成功，服务器返回请求的数据。</span><br><span class="line"><span class="number">201</span> <span class="title class_">Created</span>: 成功创建资源，服务器已成功创建新资源。</span><br><span class="line"><span class="number">204</span> <span class="title class_">No</span> <span class="title class_">Content</span>: 请求成功，但无返回内容。一般用于删除操作。</span><br><span class="line"><span class="number">304</span> <span class="title class_">Not</span> <span class="title class_">Modified</span>：资源未修改，使用缓存，没有返回数据。</span><br><span class="line"><span class="number">400</span> <span class="title class_">Bad</span> <span class="title class_">Request</span>: 请求失败，由于客户端发送了错误的请求导致服务器无法处理该请求。</span><br><span class="line"><span class="number">401</span> <span class="title class_">Unauthorized</span>: 请求失败，因为缺少或非法的身份验证凭据。</span><br><span class="line"><span class="number">403</span> <span class="title class_">Forbidden</span>: 请求失败，由于服务器拒绝执行请求。通常是因为访问权限不足。</span><br><span class="line"><span class="number">404</span> <span class="title class_">Not</span> <span class="title class_">Found</span>: 资源未找到，服务器无法找到请求的资源。</span><br><span class="line"><span class="number">500</span> <span class="title class_">Internal</span> <span class="title class_">Server</span> <span class="title class_">Error</span>: 服务器内部错误，请求无法被处理。</span><br></pre></td></tr></table></figure>

<h4 id="20-在列表渲染中，在哪些情况下可以使用数组下标作为key-为什么"><a href="#20-在列表渲染中，在哪些情况下可以使用数组下标作为key-为什么" class="headerlink" title="20.在列表渲染中，在哪些情况下可以使用数组下标作为key,为什么?"></a>20.在列表渲染中，在哪些情况下可以使用数组下标作为key,为什么?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>数组中的项目没有唯一<span class="variable constant_">ID</span>，并且项目之间没有明显的排序关系，而只是一些项的集合。</span><br><span class="line"><span class="number">2.</span>列表是静态的，不会改变顺序或动态添加/移除项目。</span><br><span class="line">这两种情况下可以使用数组索引作为key，因为这样做可以提高列表渲染的效率。由于每一个项目都有自己独特的key，<span class="title class_">Vue</span>就不需要花时间去比较它们的值来检测它们是否发生了变化，从而优化性能。但是如果列表具有顺序或者是动态变化的，则不应该使用数组的索引作为key，因为这可能会导致未预期的行为和性能问题。</span><br></pre></td></tr></table></figure>

<h4 id="21-数据代理"><a href="#21-数据代理" class="headerlink" title="21.数据代理"></a>21.数据代理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在 <span class="title class_">Vue</span> 中，可以通过数据代理来实现在组件中访问另一个对象的属性时，将其映射到该组件的实例上。这可以方便地在模板或 js 代码中访问、修改这个对象的属性。</span><br><span class="line">具体来说，<span class="title class_">Vue</span> 实例会在创建时对组件中的 data 对象进行递归遍历，把其中的属性（包括嵌套属性）全部加入到 <span class="title class_">Vue</span> 实例中。每当组件中使用某个属性时，<span class="title class_">Vue</span> 就会自动代理这个属性，使得在组件内部访问该属性等同于访问 <span class="title class_">Vue</span> 实例中的同名属性。而对于 <span class="title class_">Vue</span> 实例上不存在的属性，访问它们会返回 <span class="literal">undefined</span>。</span><br><span class="line"><span class="comment">//还有一种情况是computed</span></span><br><span class="line"><span class="attr">eag</span>:</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;APP&#x27;</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;哈哈&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        <span class="title function_">message</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-项目如何适配不同设备"><a href="#22-项目如何适配不同设备" class="headerlink" title="22.项目如何适配不同设备"></a>22.项目如何适配不同设备</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>小程序适配</span><br><span class="line">小程序开发的时候需要适配的话，单位我们是用的rpx</span><br><span class="line"><span class="comment">//让小程序在不同屏幕下适配 跟vw很像，它是1rpx = 0.5px</span></span><br><span class="line">安装插件 px转rpx   <span class="comment">//px to rem &amp; rpx (cssrem)</span></span><br><span class="line"><span class="comment">//配置 settings.json</span></span><br><span class="line"><span class="string">&quot;cssrem.wxss&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;cssrem.wxssDeviceWidth&quot;</span>: <span class="number">375</span>,</span><br><span class="line"><span class="number">2.</span>pc端适配</span><br><span class="line"> <span class="number">2.1</span>. pc端适配的话就有很多方法了 ，百分比布局，不过应该没人用了，但是可以实现， <span class="number">2.2</span> rem布局，以rem作为我们的单位，它的原理是当我们屏幕变化的时候利用媒体查询，变化我们的根标签html的字体大小，1rem = html字体大小/我们分的份数</span><br><span class="line"><span class="number">2.3</span>. vw vh 也可以达到一个适配的效果，vw是相对以屏幕宽度来变化的 1vw=屏幕宽度/<span class="number">100</span> </span><br><span class="line"><span class="number">3.</span>移动端适配</span><br><span class="line">安装插件 postcss-px-to-viewport</span><br><span class="line">cnpm  i postcss-px-to-viewport --save-dev</span><br><span class="line"><span class="comment">//vite.config.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> viewPort <span class="keyword">from</span> <span class="string">&#x27;postcss-px-to-viewport&#x27;</span></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">  <span class="attr">css</span>:&#123;</span><br><span class="line">    <span class="attr">postcss</span>:&#123;</span><br><span class="line">      <span class="attr">plugins</span>:[</span><br><span class="line">        <span class="title function_">viewPort</span>(&#123;</span><br><span class="line">          <span class="attr">viewportWidth</span>: <span class="number">375</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  )]</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="23-canvas的使用"><a href="#23-canvas的使用" class="headerlink" title="23.canvas的使用"></a>23.canvas的使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas width=<span class="string">&quot;400&quot;</span> height=<span class="string">&quot;400&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;img&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 有了画板</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;canvas&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 画笔</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 画板位置大小</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> rect = canvas.<span class="title function_">getBoundingClientRect</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(rect);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 鼠标按下，开始，鼠标移动，画线，鼠标抬起，结束</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousedown&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 鼠标是不是按在画板上 - 命中检测</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          e.<span class="property">clientX</span> &lt; rect.<span class="property">x</span> ||</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          e.<span class="property">clientX</span> &gt; rect.<span class="property">x</span> + rect.<span class="property">width</span> ||</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          e.<span class="property">clientY</span> &lt; rect.<span class="property">y</span> ||</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          e.<span class="property">clientY</span> &gt; rect.<span class="property">y</span> + rect.<span class="property">height</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        ) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 在方块内部</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 鼠标移动就画画</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// x,y 相对于 canvas</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> x = e.<span class="property">clientX</span> - rect.<span class="property">x</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> y = e.<span class="property">clientY</span> - rect.<span class="property">y</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> <span class="title function_">draw</span> = (<span class="params">ev</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">let</span> nextX = ev.<span class="property">clientX</span> - rect.<span class="property">x</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">let</span> nextY = ev.<span class="property">clientY</span> - rect.<span class="property">y</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// 开始画画</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          ctx.<span class="title function_">beginPath</span>(); <span class="comment">// 我要开始描线了</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          ctx.<span class="title function_">moveTo</span>(x, y); <span class="comment">// 起点</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          ctx.<span class="property">lineWidth</span> = <span class="number">10</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          ctx.<span class="title function_">lineTo</span>(nextX, nextY); <span class="comment">// 终点</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          ctx.<span class="property">strokeStyle</span> = <span class="string">&quot;red&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          ctx.<span class="title function_">stroke</span>(); <span class="comment">// 描线</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// 更新起点</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          x = nextX;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          y = nextY;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, draw);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 鼠标抬起</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseup&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, draw);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;mouseup&quot;</span>, draw);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 生成图片</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// img.src = canvas.toDataURL(); // 生成 base64 图片</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        canvas.<span class="title function_">toBlob</span>(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">const</span> file = <span class="keyword">new</span> <span class="title class_">File</span>([blob], <span class="string">&quot;canvas.png&quot;</span>, &#123; <span class="attr">type</span>: <span class="string">&quot;image/png&quot;</span> &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">//. 包装成图片文件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// 通过文件生成图片链接</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          img.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(file);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="comment">// 清空画板</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          ctx.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;, <span class="string">&quot;image/png&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">//总结</span></span><br><span class="line"><span class="number">1.</span>首先定义我们canvas的大小</span><br><span class="line"><span class="number">2.</span>获取canvas元素，定义画笔，获取画板的位置，</span><br><span class="line"><span class="number">3.</span>监听鼠标按下事件，判断鼠标是不是在画板上，在画板上才做相应的操作，</span><br><span class="line">监听鼠标移动事件，计算相对于canvas中鼠标的位置，调用画笔上的一些方法，描线，</span><br><span class="line"><span class="number">4.</span>鼠标抬起的时候，清除鼠标移动和鼠标抬起事件</span><br></pre></td></tr></table></figure>

<h4 id="24-真实开发git的操作流程"><a href="#24-真实开发git的操作流程" class="headerlink" title="24.真实开发git的操作流程"></a>24.真实开发git的操作流程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>我会在dev分支上拉代码，创建一个做我自己的一个功能模块的分支，开发完之后，组长会合并我们的代码，解决代码冲突，上线到开发环境，验证功能是否实现</span><br><span class="line"><span class="number">2.</span>如果我们开发人员通过测试，会把代码，合并到qa测试分支，上线到测试环境，这时会经过测试人员和产品经理测试</span><br><span class="line"><span class="number">3.</span>通过测试，就把qa分支合并到master分支上了，最终上线到生产环境</span><br><span class="line"><span class="comment">//紧急bug修复的话，直接在master分支拉代码，修复，合并</span></span><br></pre></td></tr></table></figure>

<img src="../image/image-20230417203238109.png" alt="image-20230417203238109" style="zoom:80%;" />

<h4 id="25-v-show和v-if的了解-优先级-在vue2和vue3中"><a href="#25-v-show和v-if的了解-优先级-在vue2和vue3中" class="headerlink" title="25.v-show和v-if的了解?优先级?在vue2和vue3中"></a>25.v-show和v-if的了解?优先级?在vue2和vue3中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v-show和v-<span class="keyword">if</span>都是<span class="title class_">Vue</span>.<span class="property">js</span>中用于条件渲染的指令，但它们有一些区别。</span><br><span class="line"></span><br><span class="line">v-<span class="keyword">if</span>是惰性的，即如果它的表达式在初始渲染时为<span class="literal">false</span>，则会跳过整个元素的渲染。如果表达式在运行时变为<span class="literal">true</span>，则插入该元素。如果它在运行时变为<span class="literal">false</span>，则将此元素从<span class="variable constant_">DOM</span>中删除。由于v-<span class="keyword">if</span>的行为类似于将元素添加到<span class="variable constant_">DOM</span>中或从<span class="variable constant_">DOM</span>中删除，因此它具有更高的切换开销，适合用于不经常发生改变的情况。</span><br><span class="line"></span><br><span class="line">相反，v-show只是简单地控制元素的<span class="variable constant_">CSS</span>属性display的值。它没有像v-<span class="keyword">if</span>那样的惰性，不管初始值是什么，都始终在页面上渲染该元素。因此，v-show在需要经常切换显示/隐藏状态的情况下表现更好。</span><br><span class="line"></span><br><span class="line">在<span class="title class_">Vue</span> <span class="number">2</span>和<span class="title class_">Vue</span> <span class="number">3</span>中，v-<span class="keyword">if</span>具有更高的换算优先级。这意味着，如果您在同一元素上同时使用了v-<span class="keyword">if</span>和v-show指令，则v-<span class="keyword">if</span>将优先于v-show进行计算，因此v-show将总是忽略。当然，在实际编码过程中，应避免在同一元素上同时混合使用v-<span class="keyword">if</span>和v-show以避免潜在的逻辑错误。</span><br></pre></td></tr></table></figure>

<h4 id="26-v-for和v-if的了解-优先级-在vue2和vue3中"><a href="#26-v-for和v-if的了解-优先级-在vue2和vue3中" class="headerlink" title="26.v-for和v-if的了解?优先级?在vue2和vue3中"></a>26.v-for和v-if的了解?优先级?在vue2和vue3中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在<span class="title class_">Vue2</span>中，v-<span class="keyword">for</span>指令的优先级高于v-<span class="keyword">if</span>指令的优先级。也就是说，如果v-<span class="keyword">for</span>和v-<span class="keyword">if</span>同时出现在同一标签上，v-<span class="keyword">for</span>会先执行，并且优先级高于v-<span class="keyword">if</span>。</span><br><span class="line"><span class="number">2.</span>而在<span class="title class_">Vue3</span>中，v-<span class="keyword">if</span>指令的优先级高于v-<span class="keyword">for</span>指令的优先级。这意味着，如果v-<span class="keyword">if</span>和v-<span class="keyword">for</span>同时存在于同一元素上，则v-<span class="keyword">if</span>将优先于v-<span class="keyword">for</span>执行。这是因为，在<span class="title class_">Vue3</span>的编译器中，v-<span class="keyword">if</span>指令被编译成一个条件渲染函数，而不是像<span class="title class_">Vue2</span>那样在每次迭代时都进行条件检查。</span><br></pre></td></tr></table></figure>

<h4 id="27-Vue-observable-有了解吗"><a href="#27-Vue-observable-有了解吗" class="headerlink" title="27.Vue.observable 有了解吗"></a>27.Vue.observable 有了解吗</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue2 中模拟 vue3 中 reactive 的 api <span class="comment">//Vue3 里面没有过滤器，直接用函数处理</span></span><br></pre></td></tr></table></figure>

<h4 id="28-vue3-的-Treeshaking-特性"><a href="#28-vue3-的-Treeshaking-特性" class="headerlink" title="28.vue3 的 Treeshaking 特性"></a>28.vue3 的 Treeshaking 特性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Treeshaking</span> 摇树，不是 <span class="title class_">Vue3</span> 的特性，是 vite 和 webpack <span class="number">5</span> 的特性</span><br><span class="line">实际代码中用到的依赖，才会被打包</span><br></pre></td></tr></table></figure>

<h4 id="29-TS-中函数和-Js-函数有什么区别呢"><a href="#29-TS-中函数和-Js-函数有什么区别呢" class="headerlink" title="29.TS 中函数和 Js 函数有什么区别呢"></a>29.TS 中函数和 Js 函数有什么区别呢</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ts 会编译成 js，所以运行上没有本质区别</span><br><span class="line">ts 的函数，需要对参数和返回值分别定义类型</span><br><span class="line">ts 中，函数可以用对象类型声明，而且可以声明函数重载</span><br></pre></td></tr></table></figure>

<h4 id="30-fetch-x2F-xhr-有什么区别？和-axios-有什么区别？"><a href="#30-fetch-x2F-xhr-有什么区别？和-axios-有什么区别？" class="headerlink" title="30.fetch&#x2F;xhr 有什么区别？和 axios 有什么区别？"></a>30.fetch&#x2F;xhr 有什么区别？和 axios 有什么区别？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fetch 两段 then</span><br><span class="line"><span class="title function_">fetch</span>(url, &#123; method, <span class="attr">headers</span>: &#123;&#125;, body &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>status, res.<span class="title function_">json</span>()).<span class="title function_">then</span>(result)</span><br><span class="line">fetch 调用 url，请求方法，头部设置，请求体设置</span><br><span class="line">第一段then，获取状态码，然后配置处理方式（json，text，blob）</span><br><span class="line">第二段then，处理结果</span><br><span class="line">xhr 有五步</span><br><span class="line"><span class="number">1.</span> <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="number">2.</span> xhr.<span class="title function_">setHeaders</span>()</span><br><span class="line"><span class="number">3.</span> xhr.<span class="title function_">open</span>(方法, url)</span><br><span class="line"><span class="number">4.</span> xhr.<span class="title function_">send</span>()</span><br><span class="line"><span class="number">5.</span> xhr.<span class="property">onreadystatechange</span> 状态为 <span class="number">4</span>，状态码为 <span class="number">200</span> - <span class="number">500</span> 时，处理结果</span><br><span class="line">axios</span><br><span class="line"><span class="number">1.</span> 配置 axios 实例（timeout，基地址，结果处理方式）</span><br><span class="line"><span class="number">2.</span> 配置请求拦截器</span><br><span class="line"><span class="number">3.</span> axios.<span class="property">get</span></span><br><span class="line">区别：</span><br><span class="line"><span class="number">1.</span> axios 是第三方库，基于 xhr，fetch/xhr 是浏览器原生的</span><br><span class="line"><span class="number">2.</span> axios 兼容性和 xhr 一样， 可以兼容 ie <span class="number">10</span> - ie11, fetch 不兼容 <span class="variable constant_">IE</span></span><br><span class="line"><span class="number">3.</span> xhr 有 onProgress，可以处理上传进度问题</span><br><span class="line"><span class="number">4.</span> fetch 第二段then的参数，类型是 流（stream）</span><br><span class="line"><span class="number">5.</span> xhr 的 readystate 有<span class="number">5</span>个状态</span><br></pre></td></tr></table></figure>

<h4 id="31-树形结构是怎么实现的"><a href="#31-树形结构是怎么实现的" class="headerlink" title="31.树形结构是怎么实现的"></a>31.树形结构是怎么实现的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用递归组件时，我们可以定义一个组件，该组件能够以递归方式调用自身。在每次调用自身时，我们需要先判断当前节点是否为叶子节点。如果是，则直接渲染该节点的内容；如果不是，则继续递归子节点并将它们渲染出来</span><br></pre></td></tr></table></figure>

<h4 id="32-异步组件"><a href="#32-异步组件" class="headerlink" title="32.异步组件"></a>32.异步组件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">等待异步组件时渲染一些额外的内容，让应用有更好的用户体验</span><br><span class="line">如果平时我们直接引入组件的话，app组件会等所有的组件加载完，才会展示页面，当网速较低时，我们可以异步引入组件，在配合<span class="title class_">Suspense</span>，让app组件先渲染，再在<span class="title class_">Suspense</span>中等待组件渲染时提供一些额外的内容</span><br><span class="line"><span class="number">1.</span>异步引入组件</span><br><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>)) <span class="comment">//要注册的，省略了</span></span><br><span class="line">使用<span class="title class_">Suspense</span>包裹组件，并配置好<span class="keyword">default</span>与fallback</span><br><span class="line">&lt;template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">Suspense</span>&gt;</span> //原理就是插槽，名字不能改，因为底层给slot命名是这样的</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span> //default是我们需要展示组件的地方</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Child</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:fallback</span>&gt;</span>  //fallback是我们在网速加载很慢时，等待组件加载时，展示的内容</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>加载中....<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="33-git，commit之后没有推送，又写了代码怎么合并这两次本地的代码"><a href="#33-git，commit之后没有推送，又写了代码怎么合并这两次本地的代码" class="headerlink" title="33.git，commit之后没有推送，又写了代码怎么合并这两次本地的代码"></a>33.git，commit之后没有推送，又写了代码怎么合并这两次本地的代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>使用git stash命令将当前未提交的代码保存到工作区堆栈中。</span><br><span class="line"><span class="number">2.</span>使用git pull命令拉取远程仓库的最新代码，并合并到本地分支中。这一步可能导致冲突，请根据提示逐个解决冲突。</span><br><span class="line"><span class="number">3.</span>使用git stash pop命令从堆栈中恢复之前保存的未提交的代码。</span><br><span class="line"><span class="number">4.</span>使用git add和git commit命令将本地修改提交到本地仓库中。</span><br><span class="line"><span class="number">5.</span>最后使用git push将本地仓库的改动推送到远程仓库。</span><br></pre></td></tr></table></figure>

<h4 id="34-你有一个页面，有很多组件，很多图片，用户加载很卡，怎么优化，除了懒加载还有什么方式"><a href="#34-你有一个页面，有很多组件，很多图片，用户加载很卡，怎么优化，除了懒加载还有什么方式" class="headerlink" title="34.你有一个页面，有很多组件，很多图片，用户加载很卡，怎么优化，除了懒加载还有什么方式"></a>34.你有一个页面，有很多组件，很多图片，用户加载很卡，怎么优化，除了懒加载还有什么方式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>图片压缩</span><br><span class="line">图片是web页面中最耗费带宽和加载时间的元素之一。如果您的页面中包含大量未经过压缩的图像，建议使用图像压缩工具（如<span class="title class_">TinyPNG</span>.<span class="property">com</span>）将其压缩，来减小图像文件的大小，并通过样式设置正确的图像尺寸以提高响应速度。</span><br><span class="line"><span class="number">2.</span>使用<span class="variable constant_">CDN</span>加速</span><br><span class="line">使用内容分发网络（<span class="variable constant_">CDN</span>）有效地将网站的静态内容（如<span class="variable constant_">CSS</span>、<span class="title class_">JavaScript</span>、图片）部署到全球范围内的服务器上，以便从距离最近的服务器快速交付这些资产。这样可以更快地下载或缓存页面的静态资源，并使您的网站响应时间更快。</span><br><span class="line"><span class="number">3.</span>代码分割</span><br><span class="line">将代码分割成更小的块后，只加载当前需要的部分，而不是加载整个应用程序代码。在<span class="title class_">Vue</span>.<span class="property">js</span>中，此功能可以通过将应用程序拆分为可重用的组件并使用<span class="title class_">Webpack</span>等构建工具对其进行自动处理实现。</span><br><span class="line"><span class="number">4.</span><span class="variable constant_">SSR</span>（服务端渲染）</span><br><span class="line">使用服务器端渲染（<span class="variable constant_">SSR</span>）技术将应用程序的初始渲染移动到服务器上，生成<span class="variable constant_">HTML</span>、<span class="variable constant_">CSS</span>和<span class="variable constant_">JS</span>，并在最初的请求时将其发送回浏览器。这样可以更快地在用户浏览器中看到应用程序的展示内容。</span><br><span class="line"><span class="number">5.</span>减少 <span class="variable constant_">HTTP</span> 请求数</span><br><span class="line">将 <span class="variable constant_">CSS</span> 和 <span class="title class_">JavaScript</span> 压缩并集成到一个文件中，并减少页面的外部资源请求，从而能够显著地提高网站的加载速度。此外，在实际设计和创作中请尽可能减少 <span class="variable constant_">DOM</span> 元素、<span class="variable constant_">HTTP</span> 请求次数以及 <span class="keyword">try</span>-<span class="keyword">catch</span> 等引擎处理硬件优化。</span><br><span class="line"></span><br><span class="line">这些方法都是常见且有效的优化技巧，可以帮助您改善页面加载卡顿问题，提高网站的性能和用户体验。</span><br></pre></td></tr></table></figure>

<h4 id="35-forEach怎么打断"><a href="#35-forEach怎么打断" class="headerlink" title="35.forEach怎么打断"></a>35.forEach怎么打断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//forEach 是不能被打断的， 如果想要被打断，使用数组的方法 some 、 find 、 every 可以进行打断</span></span><br></pre></td></tr></table></figure>

<h4 id="36-vue3的性能优化的方面体现在哪"><a href="#36-vue3的性能优化的方面体现在哪" class="headerlink" title="36.vue3的性能优化的方面体现在哪"></a>36.vue3的性能优化的方面体现在哪</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span> <span class="number">3</span> 的性能优化主要体现在以下几个方面：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>更快的渲染速度：<span class="title class_">Vue</span> <span class="number">3</span> 引入了新的编译器，可以生成更少的运行时代码，从而提高了应用程序的启动时间和运行时性能。</span><br><span class="line"><span class="number">2.</span>更小的包大小：<span class="title class_">Vue</span> <span class="number">3</span> 将库的大小缩小了近 <span class="number">40</span>%，从而加快了加载速度，并降低了运行时的内存占用。</span><br><span class="line"><span class="number">3.</span>更好的响应能力：<span class="title class_">Vue</span> <span class="number">3</span> 改进了其响应式系统，采用 <span class="title class_">Proxy</span> 监听数据变化，替代了旧版的 <span class="title class_">Object</span>.<span class="property">defineProperty</span>，从而更好地支持 <span class="title class_">TypeScript</span> 和使用 <span class="title class_">Composition</span> <span class="variable constant_">API</span> 进行组件开发。</span><br><span class="line"><span class="number">4.</span>更高效的组件更新：<span class="title class_">Vue</span> <span class="number">3</span> 引入了静态根节点优化和基于 <span class="title class_">Proxy</span> 的依赖追踪，提高了组件更新的效率，使得组件的更新速度更快。</span><br><span class="line"><span class="number">5.</span>更好的虚拟 <span class="variable constant_">DOM</span>：<span class="title class_">Vue</span> <span class="number">3</span> 的虚拟 <span class="variable constant_">DOM</span> 采用了更高效的算法，可以减少大量冗余的操作，同时还可以更好地支持 <span class="title class_">Fragment</span> 和 <span class="title class_">Teleport</span> 等新特性</span><br></pre></td></tr></table></figure>

<h4 id="37-Canvas-和-SVG-区别"><a href="#37-Canvas-和-SVG-区别" class="headerlink" title="37.Canvas 和 SVG 区别"></a>37.Canvas 和 SVG 区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="title class_">Canvas</span> 更加接近 <span class="variable constant_">GPU</span>，性能更强</span><br><span class="line"><span class="number">2.</span> <span class="variable constant_">SVG</span> 一般用于图标，而 <span class="title class_">Canvas</span> 一般用于图表地图和游戏</span><br><span class="line"><span class="number">3.</span> <span class="variable constant_">SVG</span> 是矢量图，放大后不失真，<span class="title class_">Canvas</span> 是位图，放大后失真</span><br><span class="line"><span class="number">4.</span> <span class="variable constant_">SVG</span> 配置在 html 中，而 <span class="title class_">Canvas</span> 在 js 中画图</span><br></pre></td></tr></table></figure>



<h3 id="1000-应用场景-结合实际项目说"><a href="#1000-应用场景-结合实际项目说" class="headerlink" title="1000.应用场景 结合实际项目说"></a>1000.应用场景 结合实际项目说</h3>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/hyh.github.io/2023/06/29/%E9%9D%A2%E8%AF%95%E9%A2%98/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2023 hyh
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/hyh.github.io/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/hyh.github.io/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/hyh.github.io/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接1</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接2</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接3</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接4</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接5</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接6</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>